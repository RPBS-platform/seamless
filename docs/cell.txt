The cell graph has a "master kernel" (usually an IPython REPL, occasionally a command line script, e.g. a cell graph interpreter). Cells and processes are constructed inside the master process. Macros also run inside the master process.
Cell values can be set from the master process.

The master process API
======================

There are only the following primitives:

from seamless.cell import cell, transformer, editor, effector, macro

Transformers, editors and effectors are processes.
Processes have input pins and/or output pins.
All primitives except "macro" are themselves macros

For the rest, there are subclasses of cell in seamless.cells:

from seamless.cell.cells import pythoncell, buffercell, bufferdictcell

(these are also macros).

And finally, you can import non-primitive macros from the library (lib)

from seamless.lib.examples import add, mult

In seamless.core.base there will be some internal classes:
seamless.core.process (base class of transformer, editor, effector)
seamless.core.transformer / seamless.core.editor / seamless.core.effector
seamless.core.inputpin
seamless.core.outputpin
seamless.core.bufferpin
seamless.core.kernel.python_thread
seamless.core.manager

Context syntax
==============

The easiest way to construct graphs is to use context syntax
(see example.txt)

Utilities:
value = seamless.edit(type, startvalue=None, config=None)
In case you don't need a cell, but do prefer a GUI.
"startvalue" and "config" are keyword-only arguments.
"config" is a JSON structure that accepts options (e.g. HTML or Qt or structured text editing). It may also contain a startvalue.
Obviously, you can edit "config" with seamless.edit as well.

A note on types:
You can get the required type of a macro's outputpin by querying the outputpin (which is a class attribute), i.e. seamless.edit.config.type
returns ("json", "config", "seamless.edit")

Properties of the cell system
=============================

- Asynchronous: processes are normally in a separate thread
- Cells are dependent or independent (default). Connecting an output pin of a transformer makes a cell dependent.
- Editor output pins and any input pins may also be declared as buffer pins (see below).
- Buffer cells have in addition special buffer pins (read, write and update).

Auxiliary systems:
Type system (see type.txt)
Macro system (see macro.txt)
Both types and macros can (and should!) be annotated with documentation cells


Contexts
========

A context is a process that contains other processes and cells and their connections
A context has the methods/attributes: cells, processes, save, load, keys, pins, collapse. These attributes are not allowed as pin names
A context is collapsible (if it has a parent). All cells and processes of the context are added to the parent.

Serialization
=============

seamless.context.save(binary=False)
seamless.context.load


A cell graph can be serialized, in two ways. In either way, there is a JSON part that contains the code and parameter cells and the connectivity. For buffers, the management structure is stored together with an index into the buffer part. The two serialization ways differ on how the buffer part is stored:
1) In full JSON format. In case of embedded buffers, there is one giant _buffer object at the end of the JSON file with \x escape codes
2) In binary format. The first 4 bytes = integer containing the length of the JSON part. Then comes the JSON part (some encoding is possible, e.g. zipped). Finally, the binary part with the raw buffers.

Misc
====
All processes can be canceled using the cancel() method. There is also a hive hook for this. It is possible to declare volatile cells that may change during the process. These can be both input or output,
