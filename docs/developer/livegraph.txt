Livegraph
=========

This document describes the design plan that drove the livegraph branch,
 which is one of the four big changes between 0.1 and 0.2.
 (The other three changes were in the cache branch (see cache-branch.txt)
 , namely:
 - Split between high and low level, see docs/developer/architecture.txt
 - A complete redesign of Silk, see docs/plans/silk
 - The change of cells from fat value containers to thin wrappers 
   around cached checksums, manipulated from a manager (hence the name)
This document was written in early 2019, after the caching branch was complete,
 but instabilities proved the necessity of the livegraph branch. The document
 is mostly written from a caching branch POV, i.e. "what needs to be changed from here"
)
Implementation was carried out reasonably close to the spec as described in this document. 
The most important modifications:
1. Many of the sync actions, (namely get/set_value, get/set_checksum (public), get/set_buffer, and
  also ctx.equilibrate, ctx.translate and ctx.get_graph)
  cannot be executed when an asyncio event loop is running, most notably within
  Jupyter Notebooks. nest_asyncio is an unreliable solution.
  Therefore, nest_asyncio was dropped, and async (coroutine) versions were implemented.
  For value/buffer/checksum, this merely invokes the private checksum API and then awaits
  (de)serialization etc. 
  For equilibrate and translate, async equivalents were created.
2. "equilibrate" was replaced by "compute"
3. Some task dependency deadlocks were encountered. In particular, within Structured Cell joins,
  and also get_graph tries to wait for these as well as for SetValue/SetBuffer actions.
  Therefore, Subpath cancel/void was implemented differently to avoid deadlocks, and pseudo-cycles
  are no longer possible.
  This has been labeled issue 3.
4. Deep cells do not work quite the way as in this document. This leads to a memory leak.
  This has been labeled issue 5.


===================

New concept of a "livegraph". This is what the manager
currently maintains, i.e. accessors, statuses, ..., i.e. all that goes beyond the 
simple static hierarchical low-level context.

Code must be split up into the following:

- Task management.
New concept of tasks that derive from Task, are processed asynchronously by adding them to taskmanager. 
Replaces workqueue and cachetask. Also, most manager methods will be replaced by Task classes. Get rid of all async/awaits.
Each manager has its own taskmanager.
Each taskmanager has a counter, which means that each task has a monotonically increasing number.
Two kinds of tasks: sync and async.
When sync task is executed, the event loop is blocked. A sync task should be fast, launching new
 events rather than recursive/reactive execution of methods.
Async (normal) tasks are non-blocking and cancelable (asyncio futures), and can take a long time.
TODO: integrate with communionserver to accept remote events, and return their result
 (keep track of origin connection to send response to; 
  also makes it possible to fwd remote events to all communion partners
  except their origin)

Conversion modifications:
    Do away with content type and copy/ref. There are only cell types now.
    Cell types are None (auto) by default. This means that the inputpins adopt the cell type of whatever cell is connected to them.
    For outputpins, you must connect them to whatever cell type is generated by the worker.
    Do away with value and buffer. All conversions are buffer-to-buffer.
    All buffers and checksums are syntactic. Semantic buffers don't exist. 
      Semantic values can be obtained from syntactic values in an explicit operation. For trivial cases, the syntactic checksum is kept.
    Explicit caching of expressions (checksum + path + type => checksum). Explicit caching of syntactic-checksum-to-semantic-checksum.
    
(NOTE: remember that StructuredCell is only a wrapper. Connections (with paths) are for normal cells!
 Still, the manager will know if there was a wrapper, because paths are registered.)

Do away with status bookkeeping; compute status on demand.

Task manager will keep track of dependencies.

Overhaul accessors and expressions.

Voidness of cells (if non-void, checksum is not None, but checksum may not be known yet)

TODO: StructuredCells with inchannels have a "zero authority" option
(from the high level, this is True by default, and always true for the input and result cells of a high-level transformer). 


Actions
=======
Actions are sync; 
  launch task is done using ensure_future (taskmanager.launch(task)); 
  await is done using run_until_complete (taskmanager.launch_async(task)).
The following actions are possible:

- Register worker/cell. No tasks. 
  (but inform authoritymanager, caches etc.) 

- Connection.   
  - Launch an UponConnectionTask, which does the following:
    - Await all other UponConnectionTasks
    - Cancel any set-cell-value tasks on the target (if a cell)
    - Inform authoritymanager, caches etc., returning an accessor.
      This accessor will automatically be updated if anything modifies the source
      (even if it is already running, but not finished, now)
    - Launch an accessor update task

- Setting a cell checksum.
  (This is done from the command line, usually at graph loading)
  initial=True in case of graph loading; is_buffercell=True when triggered from StructuredCell)
  If "initial" is True, it is assumed that the context is being initialized (e.g. when created from a graph).
  Else, cell cannot be the .data or .buffer attribute of a StructuredCell, and cannot have any incoming connection.
  
  However, if "is_buffercell" is True, then the cell can be a .buffer attribute of a StructuredCell

  If the new checksum is None, do a cell void cancellation.  
  Else: 
    If old checksum is not None, do a cell cancellation.
    Set the cell as being non-void, set the checksum (direct attribute access), and launch a cell update task. 

- Setting a cell value. 
  (This is done from the command line, or editpin/mount/shareserver)
  Verify that the cell has authority and is not a data/buffer from a StructuredCell.
  Do a cell cancellation.
  Launch a set-cell-value task.

- Getting a buffercell path.
  (This is done through StructuredCell Backends. 
    TODO: shareserver and mount should invoke the StructuredCell too; for shareserver, configure allowed paths)
  Verify that target cell is a buffercell (which must be unconnected)
  Await a get-path task on the buffercell

- Setting an authoritative cell path.
  (This is done through StructuredCell Backends. 
    TODO: shareserver and mount should invoke the StructuredCell too; for shareserver, configure allowed paths)
  Verify that target cell is a buffercell (which must be unconnected)
  Verify that the modified path has full authority (see authoritymanager)
    (UPDATE: don't do this. Inchannels will simply overwrite the relevant values)
  Cancel any previous buffercell-join task, collect its modified paths, add current path to it
  Launch a buffercell-join task, with modified paths as an argument

- Setting a non-authoritative cell path.
  (This is done through accessors that have a cell target.) 
  Verify that target cell is a datacell with an associated buffercell (which must be unconnected)
  Cancel any previous buffercell-join task, collect its modified paths, add current path to it
  Launch a set-path task on the buffercell
  Launch a buffercell-join task, with modified paths as an argument, and which awaits the set-path task

- Set cell exception
  (will be invoked by StructuredCell wrapper, upon validation. Eventually, make this available as cell.exception from the high level)

- Get cell checksum (public)
  Await cell checksum task.
  Return Get cell checksum (private)

- Get cell checksum (private)
  Simply return the stored checksum attribute

 

Tasks
=====
Each task is asynchronous and has a list of cell/accessor/expression dependencies.
If the dependency has its checksum changed/set to None,
 cancel all dependent tasks.
Child tasks can be either awaited directly (which means that they get
 canceled together with the parent task), or they can be registered
 with their own dependency.
Update tasks must be unique for each cell/accessor/worker. 
  If one is already running for that cell/accessor/worker, an exception is raised.
  Therefore, the old one must been cancelled before.
  Update tasks are never awaited as child tasks.
Some tasks use refcounting dependencies. This is because multiple accessors
 can resolve to the same expression, and multiple transformers may resolve
 to the same transformation.
 Refcounting tasks use an incref/decref system. If a dependency changes checksum
 or is destroyed, the task is decref'ed
 (a compensatory incref that lasts 20 secs is then awarded). 

List of tasks:
- Cell checksum task
    Updates the checksum of the cell.
  - Await all UponConnectionTasks
  - Await current set-path tasks for the cell. It doesn't matter if they were cancelled.  
  - Await get buffer task
  - Await calculate checksum task
  - If the checksum is not None and cell's void attribute is True, log a warning, set it to False, and launch a cell update task
  - Set the cell's checksum attribute (direct attribute access)
  - If the checksum was None but the void attribute was not None, do a cell void cancellation.

NOTE: among update tasks, only Cell update tasks will get an up-to-date checksum, guaranteed.
This is because operations on cells must be well-ordered.
In contrast, Accessor and Worker update tasks may see out-of-date checksums. But whenever the
 checksum changes, an operation should be launched (cancellation or a new update task) that
 corrects the earlier update.

- Cell update task
  - If the cell's void attribute is True, log a warning and return.
  - Await cell checksum task
  - If the checksum is None, for each output accessor:
      - do a void cancellation
    Else, for each output read accessor:
      - construct (not evaluate!) their expression using the cell checksum 
        Constructing a downstream expression increfs the cell checksum
      - launch an accessor update task

- Accessor update task.
  - Get the expression. If it is None, do an accessor void cancellation
  - If the expression is trivial, obtain its result checksum directly
  - Else, get the expression result checksum from cache. 
    If there is a cache miss, await expression evaluation task
  - Select the write accessor's target. If the expression result checksum is None,
    do an accessor void cancellation.
    Else:
  - If a worker, set the pin to the checksum, and launch a worker update task.
  - If a cell:
      ###If path is None: launch a set-cell-value task. 
        This will launch an update task, when complete.
      Else:
        - Run a set-non-authorative-path *action*, which will launch a set-path task.
        - Launch a cell update task (it will automatically await the set-path task, if any)

- Worker update task.
  - Check that all inputpins/editpin accessors are connected and have valid checksums. If not, return.
  - For each of those checksums, await get-semantic-checksum task
  For a transformer:
    - From the semantic checksums, build a transformation.
    - Launch a transformation task
  For a macro:
    - From the semantic checksums, build a argument dict (await get-buffer and deserialize tasks)
    - Synchronously (re-)run the macro using argument dict
  For a reactor:
    If there is a live reactor instance:
        - Get the semantic checksums from the live reactor
        - Look which ones are different, and build a delta dict (await get-buffer and deserialize tasks)
        - Synchronously invoke code_update on the live reactor, using the delta dict
    Else:
        - Build a live reactor instance
        - From the semantic checksums, build a argument dict (await get-buffer and deserialize tasks)
        - Synchronously invoke code_start and code_update on the live reactor, using the argument dict
    In both cases, gather the emitted outputs, and launch accessor update tasks for each.
    If there are emitted editpins, run "set cell value" actions

- Expression evaluation task.
  Depends on read-accessors, using refcounting.
  - For trivial expressions, obtain the result checksum directly
  - Await expression cache (also remote)
  - If cache miss:
        - Await get buffer task
        - Evaluate the path WITHOUT using the Monitor wrapper (naively, but special mechanics for deep cells). 
        - Await serialization task (using cell type)
        - Await calculate checksum task
        - Add result checksum in expression cache
  - Add result checksum to expression

- Get buffer task.
  Gets the buffer from its checksum
  - Check for a local checksum-to-buffer cache hit (synchronous)
  - Else, check Redis cache (currently synchronous; make it async in a future version)
  - Else, await remote checksum-to-buffer cache
  - Else, if the checksum has provenance, the buffer may be obtained by launching a transformation.
    However, in this case, the transformation must be local OR it must be ensured that remote
    transformations lead to the result value being available (a misconfig here would lead to a
    infinite loop).
  - If successful, add the buffer to local and/or Redis cache (with a tempref or a permanent ref).
  - If all fails, raise Exception


- Get-semantic-checksum task
  Gets a semantic checksum from a syntactic one (celltype is an argument)
  - If the conversion is trivial, return syntactic checksum
  - Await semantic checksum cache (also remote) (includes celltype)
  - If cache miss:
    - Await get buffer task    
    - Await deserialization task (using cell type)
    - Compute semantic checksum (using cell type)
      Store checksum mapping in semantic cache
    - Await serialization task (using cell type)
    - Await calculate checksum task
    - Add result checksum in semantic checksum cache (including celltype)

- Set-cell-value task. 
    Value must not be None.
    - Await all UponConnectionTasks
    - Set cell-to-value cache
    - Await serialization task (using celltype)
    - Await calculate checksum task. If None, raise Exception.
    - Set cell checksum (direct attribute modification)
    - Launch cell update task
    - Pop cell-to-value cache

- Get-path task
    NOTE: only ever invoked through the command line (sync code) on buffercells; 
     in contrast, expression evaluation is a different task that does not use the Monitor
  - Await all UponConnectionTasks
  - Cancel delayed-buffercell-clear task for this buffercell (if any)
  - Gather current set-path tasks for the buffercell
  - Await the tasks (with shield), except if marked as re-entrant
  - Get the dependent buffercell ID. Retrieve its value from buffercell cache. If there is a cache miss:
    - Retrieve its checksum (private API)
    - Await deserialization task (using celltype)
    - Add the value to the buffercell cache
  - Evaluate the path using the Monitor wrapper (naively, but special mechanics for deep cells). 
      This may also spawn new get-path tasks.
  - Cancel delayed-buffercell-clear task for this buffercell (if any)
  - Register a delayed-buffercell-clear task for this buffercell


- Set-path task (takes checksum + checksum_celltype as argument)
   (Will be invoked by write accessors on buffercell targets; NOTE: only invoked via an action!)
UPDATE: also keep track of which inchannel paths have a checksum.
Only trigger target update tasks (as opposed to non-void cancellations) when all relevant inchannel paths have a value.
  - Gather current set-path tasks for the buffercell
  - If none of these tasks are re-entrant:
      Modify the last task so that its checksum step is disabled (cancel it if checksum step is in progress)
    Else: disable our own checksum step
  - Await the tasks (with shield), except if marked as re-entrant
  - Retrieve the checksum of the dependent cell
  - Await get-buffer deserialization task for target cell (using celltype)
  - Mark the current task as re-entrant
  - Await get-buffer + deserialization task for checksum argument (using checksum_celltype)
  - Modify the value using the Monitor (naively, but special mechanics for deep cells)
    This may also spawn new get/set path tasks.
  - Unmark the current task as re-entrant
  - Check if the checksum step has been disabled. If not:
    - Set cell-to-value cache
    - Await serialization task (using celltype)
    - Await calculate checksum task
    - Pop cell-to-value cache

- Buffercell-join task, indicating which paths were modified
UPDATE: also keep track of which inchannel paths have a checksum.
Only trigger target update tasks (as opposed to non-void cancellations) when all relevant inchannel paths have a value.
  - Await asyncio.shield(awaitable) (2nd function argument)
  - Get buffercell checksum (private API)
  - Set datacell checksum (direct attribute modification)
  - Distill which outchannels were modified.
  - For each modified outchannel read accessor:
    - Do a accessor cancellation
    - construct (not evaluate!) their expression using the cell checksum 
      Constructing a downstream expression increfs the cell checksum
    - launch an accessor update task
  - For each non-modified outchannel read accessor:
    - Do an accessor morphing with the updated checksum


- delayed-buffercell-clear task
  (Depends on cell ID, rather than checksum. Destroy mechanics must be implemented correctly)
  Sleep 20 seconds. Afterwards, remove cell ID from buffercell cache.

- Serialization task (using celltype, from value)
  Can be LRU-cached and incref'ed, from value object ID
  Should be launched in a subprocess executor

- Deserialization task (using celltype)
  Can be LRU-cached and incref'ed, based on checksum+celltype.   
  Should be launched in a subprocess executor.

- Calculate checksum task (from buffer) 
  Can be LRU-cached and incref'ed, from value object ID
  Should be launched in a subprocess executor

- Transformer activation task (depends on each input read accessor)
  - Launch and await "Get semantic checksum" task for each input pin
  - Register transformation task (incref if already exists).
    Add the transformer to the list of the transformation's underlying transformers.    

- Transformation task  
  - Check for transformation cache (local, Redis and remote) and exception cache (local, Redis and remote).
  - Else, check if remote transformation servers can do the job.
  - Else, run the job locally.
    NOTE: don't use asyncio executor to launch local transformations, since we need response message queues. Current code works fine.
  - Await the job.
  - If there is an exception, store it in cache.
  - If no exception or None, add transformation result checksum to cache (local and redis)
    Transformation results are small and therefore get stored indefinitely. Incref/decref (launched transformer cancellation/destruction) 
      is only for *running* transformation tasks, removing the transformer from their output, and canceling if the output is empty.
  - For each underlying transformer:  
    - If there is an exception or the transformation checksum is None, do a transformation void cancellation
    - Otherwise, select the output write accessors. For each accessor:
        - Set the as their checksum the transformation checksum (this increfs the checksum)
        - Launch accessor update task

Cancellations
=============
Cancellations are sync, like actions.
- Cell cancellation (with possible void option).  
  The entire cell has changed value. 
  - Cancel all set-path tasks.
  - If void option, set checksum to None, and void to True
  - Select all downstream accessors and do cancellation on them (propagating void).
- Accessor cancellation (with possible void option).
  The accessor has an updated checksum and the result is probably different. 
  - Cancel/decref all tasks that depend on the accessor or its previous expression.
  - If void option, set void to True
  - Clear and decref the accessor's associated expression. (If the expression is freed, this leads to a decref of the associated checksum)
  - Select all downstream cells, accessors and workers, and do cancellation on them (propagating void).
- Accessor morphing. The expression now operates on an expression with a different checksum, but it has been proven that
   the result is unaffected. For all existing expression/accessor-dependent tasks, add the updated expression
   as a caching output (and incref the updated expression).
   Decref the accessor's old associated expression. (If the expression is freed, this leads to a decref of the associated checksum)
   Set and incref the updated expression.
- Transformer cancellation (with possible void option).
  Decref the associated transformation, remove the transformer from its outputs.
  Select all downstream accessors, and do cancellation on them (propagating void).

