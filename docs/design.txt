This is a manifesto intended for those who are interested in programming techniques and paradigms.
For a practical introduction to seamless, see: <TODO>

0. Prelude: What is seamless?
=============================

I am a scientist. Not a computer scientist who wants to make a theoretical, academical contribution.
I am an actual scientist who does computations on protein structures for a living.

I don't like empty buzzwords.

So please don't leave after you read the following statement:

"Seamless is a system for a new programming paradigm: meta-reactive programming"

Are you still here? Good.

1. Introduction to seamless and meta-reactive programming
=========================================================

A quick introduction to reactive programming
============================================

Traditionally, programming has been based on giving the computer long laundry-lists of instructions. Nowadays, fast computers mean that these lists are indeed very long. Most modern programming techniques have not really changed this paradigm, they just make the instruction lists more manageable.
For example, object-oriented programming organizes the code and data into objects, so that only the proper code has access to the proper data. However, to work with objects, there is still an instruction list to construct and manipulate objects.

The central concept of reactive programming (RP) is to reduce the importance of imperative laundry-list code. The goal is not to purify or eliminate imperative code altogether (that would be functional programming *), but rather, to remove imperative code from the driver's seat. Imperative code is organized into nodes that are connected in a graph. The graph defines when and how the code is invoked. The programmer controls both the graph and the nodes.

In reactive frameworks, there are many different node classes. Each node class performs a certain task, and/or contains certain data.
Depending on how the reactive framework was designed, a node class corresponds to a class or function, written in the same programming language as the reactive framework itself. In some reactive frameworks, a node class may also correspond to a node graph.

In seamless, there are only three node classes: text cell, buffer cell, and process. All the state is contained in cells.

Seamless is very minimalist. Its core consists of one Python class for each of the three node classes, plus machinery to manipulate node graphs, plus a reactive observer that executes a process when its input cells change. Everything else is in node graph libraries.

* = Functional reactive programming (FRP) also exists, but seamless is not an FRP framework

So where is the meta?
=====================

Seamless is meta because the cells contain *all* the state: not only the runtime data, but also the programming state. There is only one process class, and processes contain no state at all. No code, no parameters, no runtime properties. Everything is in the cells.

While seamless is written in Python, cells can contain source code in any programming language.
A process constructs a kernel to execute code asynchronously. By default, a process contains an IPython3 kernel that can of course execute Python, but also C/C++, OpenCL, anything that can be run under IPython. Based on its configuration parameters (which are *also* defined in a cell), the process may instead embed a kernel for JavaScript, Julia, etc. (i.e. any Jupyter kernel). These kernels may in turn support the execution of code cells written in other languages (e.g. Elm, Clojure, or even Python). So there is a triple decoupling of programming languages: the language of the code cell, the language of the process kernel, and the language of the "master kernel" that runs Seamless itself.

Is this really new, this meta-reactive programming?
===================================================

Maybe. The general idea comes from Jupyter/IPython, where a Jupyter notebook (cells, organized in a linear sequence)
is connected to an IPython/IJulia/IJavascript/... kernel (process). Seamless is a essentially a generalization of Jupyter to N kernels connected to M cells with arbitrary connectivity. However, Jupyter notebooks make a strict separation between input cells (code in the same language as the kernel, and markdown cells) and output cells (data cells and GUIs). The Jupyter project is seeing a lot of action. It now supports reactive techniques to allow output cells to make calls back into the kernel. However, even with the new JupyterLab, I am not aware of any efforts to make Jupyter meta-reactive, i.e. to give data cells and code cells equal status.
And probably, someone in the computer science community proposed the same concept under a different name already in 1993, but I haven't heard about it.

A closer look at seamless
=========================

Rules
=====

- A cell graph consists of cells, processes and their connections. A cell graph is managed in a seamless context. A seamless context is typically created and manipulated in an interactive shell, called the master kernel. Also part of the cell graph are the types of the cells and the construction parameters of the processes. All cell graph state must be serializable to text.

- All other state is contained inside cells. All state manipulation is done by processes, or through the seamless API via the master kernel. All cell state is written to disk upon save. Transformer processes are executed atomically. Cells that are the output of a transformer become dependent: they do not have a persistent state. Also, it is possible to declare any cell as non-persistent. Processes have no state at all, neither persistent nor non-persistent.

- The state of each cell is self-contained and cannot contain any direct pointers to or explicit dependencies on other cells. Likewise, processes are localized and cannot communicate with each other directly, only via cells. However, seamless has support for distributed systems that are configured using a registrar pattern. A registrar process collects information from cells, and processes can use this information by including an "import" statement in their code. There is one distributed system that is fundamental: seamless.types, to register type names. The type system is the only distributed system where the registration is done in-code, rather than via a registrar process.
Distributed systems included with seamless are:
 silk (for structured data)
 atc (for conversion chaining)
 raedae (templating/rewriting engine for JSON)
 topview (buffer-oriented reactive framework)
 hive (component-oriented reactive framework)
All of these systems include a registrar process. Seamless also includes "workflow", a file-oriented reactive framework, but "workflow" has no registrar since implicit communication can go via the file system.

- State can be organized into (sub)contexts that are embedded and connected in the parent context as if it was a process. A code cell that creates a context is called a macro. A macro is invoked from the master kernel (and therefore, must be written in a language that the master kernel understands, i.e. Python). A macro that is invoked with standard Python objects as arguments is simply executed, and the resulting context is embedded. However, a macro can also be invoked with cell(s) as argument. In that case, inside the subcontext, a live macro object is created. A live macro is a data structure that contains the name of the argument cell(s), the serialized non-cell arguments, and the entire code cell of the macro itself (both its name and its value). Whenever the argument cell(s) change, the live macro object gets re-evaluated. This can happen even after the context is saved to disk and loaded somewhere else where the macro itself has not been defined.
Note: cell names are usually auto-generated based on their type and location in the tree of contexts and subcontexts. However, cells with the exact same name must have the exact same content, and multiple copies of cells with the same name get stored only once. Therefore, if there are multiple live macro objects originating from the same macro, editing the macro code cell will affect *all* macros, unless you clone-and-rename the macro code cell first.

- Seamless is written in Python, and implementations in other languages are welcome. While many of seamless's editor/visualizer processes are coupled to Qt-based and VisPy-based GUI widgets, the GUI is by no means fundamental to seamless. A proper seamless implementation just needs to be able to understand cell graphs, execute transformers and live macros, and respond properly to cell updates. Also, the allowed syntax for the manipulation of cell graphs is completely up to the implementation. A language such as Clojure could offer much more syntactic sugar for this than Python. Multiple seamlesses could also talk to each other over a network to achieve collaborative live programming.

There are two kinds of cells:
1) parameter cells ("just cells"):
 These are text cells.
 They can contain elementary data types (float, int, str, etc.)
 Alternatively, they can be structured data: JSON or a markup language, potentially with a registered type name, although this is optional
 Many text cells contain source code, and many processes take code cells as input cells.
2) buffer cells (array cells):
 These are blocks of binary data, with some kind of serializable run-time management structure on top. The management structure contains at least the type and dimensions of the buffer data. In Python, the management structure is typically a Numpy array.

There are three kinds of processes:
1) Transformers get activated when their input cells change. When activated, transformers compute their output cells.
2) Editors are continuously listening for external signals. When a signal arises, editors compute/modify their output cells.
3) Effectors get activated when their input cells change. When activated, effectors create external signals/effects.

The ways the rules are bent
===========================

- Minimalism
Formally, the core of seamless is minimalist, containing only seven Python classes:
context, cell, buffercell, process, macro, a dependency manager, and a type system registry API.
However, these classes are rather large: for example, "process" must contain machinery to run an asynchronous kernel (these could be Jupyter kernels, but they are currently just hygienic threads). Therefore, in practice, the classes are often specialized. For example, cell(("code","python")) returns in fact an instance of the pythoncell class, with per-cell checks on the sanity of the code (formally, this is completely the responsibility of the process). Likewise, the process class is split into class specializations for transformers, editors and effectors.

In addition, there is the concept of subcells to give more fine-grained control over cell contents. Example:
c = cell().set({"x":10, "y": 20})
subc = c.sub.x
print(subc.value) #10
subc.connect(...)
Subcells also work on buffer cells.

In addition, there are a few more node types for convenience. The distributed systems define their own nodes (silk cells, hive cells, atc transformers/effectors, raedae transformers, topview transformers). The bufferdict cell is a convenient way to create contiguous or interleaving sub-buffers.

Finally, there is syntax to temporarily create a subcontext, execute it, wait until some "finished" signal is given, return the value of a particular cell in the subcontext, and then destroy the subcontext. This is meant to quickly fire up a GUI to edit a Python value inside the master kernel.

- Atomicity
Formally, transformer processes are atomic. In reality, they are controlled by a kernel that takes time to run, and may encounter errors. Therefore, it is desirable to be able to interfere with the transformation using hooks into the kernel: a repl console, a debugger, a cancel signal, etc.
Same for editors: they await events from the external world (typically, the GUI), but you can hook up a repl and signals to control the external world.
In addition, for both editors and transformers, you can define volatile input cells whose value may change at any time*. Volatile input cells can be requested for their value using (). Volatile output cells can be updated at any time by the process. This is useful e.g. to append to a logger cell or to update a progress bar.
Volatile buffer cells (both input and output) behave the same as normal buffer cells, but the mutex lock that guarantees the coherence of the buffer contents during the process is not present.
Both the kernel hooks and the volatile cells provide hooks for signals sent to/from hive.

- State separation
Formally, processes contain no state. In practice, processes often do contain state, in particularly the kernel (see above). Still, to the extent that state exists within a process, such state is completely temporary, and can be easily reconstituted from the input cells. Therefore, process state must be seen as caching, something done for performance reasons. Seamless contains a ledger where processes can store data based on their process ID (for caching between transformer/effector invocations) or by a some magic number that is shared by a certain category of process (the class ID, if you will). At any moment, the user may do save-and-restart and all ledger data will be gone. Also, the ledger data should be freed when it is no longer needed: best to use some kind of storage system based on reference counting. This is all up to the developer of (the code blocks of) a process; seamless doesn't concern itself with it.

* = seamless being async, *any* cell may change during any process, but in case of non-volatile cells, for transformers, that would simply lead to re-invocation once the transformation has finished. For editors, changes in non-volatile cells trigger callback code cells, and volatile cells are only useful if these callbacks take long.

Distributed systems
===================

Hive: nodes are traditional objects (components). The graph (called a hive) defines signals and callbacks to make the components directly communicate with each other. All state is contained inside the components, the signals are just messages. Hive communication is synchronous. A hive can be constructed from code or from a data structure that represents a graph (hivemap). Typically, a hive is constructed statically before it is run.

ATC: a cell conversion engine. You can register converters between various cell formats, and also register effects for each cell format. You can then invoke a ATC transformer with the input format and desired output format, or the ATC effector with the input format and the desired effect. The ATC engine will then automatically chain converters and effectors to achieve the desired transformation or effect.
ATC transformers and effectors are collapsible, just like cell subcontexts. The difference is that the ATC nodes do not *contain* cells and processes, these are just created when the collapse is requested. The collapse is also reversible.

silk: for the construction of silk cells. A silk object is a Python wrapper around an underlying JSON or Numpy object. A silk class adds three facilities:
- Powerful constructors to construct the object in many different ways.
- Easy definition of Python validators (far beyond JSON schemas)
- Easy definition of form descriptors that give hints on how the object should be edited in a GUI.
The silk framework includes various ATC converters that convert a silk class to an HTML form or a QtQuick form.

Raedae: A rewriting engine for JSON cells. Raedae directives are registered for a particular JSON format conversion. Directives include namespaces for inline substitution of data structures. Special syntax is for namespaces that contain (or will contain) external buffers. The conversion is registered with ATC.

All of these engines are global: you can access and modify them inside any Python process by importing them from the seamless module. This means that you can use them independently from the rest of seamless. However, within the reactive paradigm, you will use these frameworks by using the special nodes (cells/processes) defined by each framework. Silk has one special node, the silk cell. For ATC, they are ATC transformers and effectors. Raedae does not have its own nodes, but uses ATC.
Each of the frameworks has a registrar effector process (of which you can construct as many as you like in your cell graph). All silk cells depend on all silk registrars. All ATC processes depend on all ATC registrars. In addition, all ATC processes also depend on all Raedae registrars, because they could potentially involve a Raedae transformation.

seamless.lib.qt: A collection of Qt editors. Requires that you use IPython.

Lightweight
===========

Finally, seamless includes a lightweight OpenGL rendering engine (lightweight). It uses Raedae to transform the scene graph into a very simple OpenGL command graph to render directly from dynamically-bound buffers. After the initial transformation, the scene can be updated simply by editing the buffers. The command graph is rendered using VisPy.
