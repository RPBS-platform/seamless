OUTDATED:

The world consists of cells and controllers
Only cells contain state, and only controllers modify state
A controller may embed an asynchronous *process*
Cells are connected to controllers' input pins (outgoing connections, outcos)
Controllers' output pins can be connected to cells (incoming connections, incos)
 Incos are either *solid* or *liquid*. By default, they are solid, unless the
 output pin is specifically declared liquid.
 If the output pin is a *master pin*, then it makes *master incos*.
  Master incos are automatically liquid.
  Any master inco makes the cell *dependent*

Solid incos:
- Change both the cell's solid value ("solid_value") and its liquid value ("value")
- The cell's solid value is saved when the world is saved
Liquid incos change only the liquid value

cell.set changes both a cell's solid and liquid values
cell.liquid_set only changes the liquid value
manager.reset() resets all cell liquid values to their solid values
(for cells whose liquid value has thus changed, updates are sent to the controllers)

Transformers are controllers that have master output pins
Editors are controllers that do not have master output pins
Effectors (e.g. visualizers) are controllers that do not have output pins at all
Modifiers are also controllers that do not have any output pins at all

Dependent cells:
1) May have only one solid incos (the master inco). Other
   solid incos are forbidden, even if they are not a master inco.
   They still may have any number of liquid incos
   In practical terms: the cell is the "slave" of the controller
    Any changes that you make via an editor are temporary (at best), you would
     only do this for debugging
2) Do not have any solid value that is saved:
   whenever the world is reloaded, the cell is recomputed. This behavior can
  be changed by setting "cached" to true. This does not affect 1) or 3).
  In practical terms: The cell contains no original data, so there is no need
   to save it, but you can cache it for performance reasons
3) Cannot be changed by cell.set, only cell.liquid_set
   In practical terms: you can't use the command line as an editor, unless
    it is temporarily (debugging)
Independent cells:
1) May have any number of solid or liquid incos
    (as long as they are not master incos).
   In practical terms: you can hook up any number of editors to a cell. You can
   choose if they work like a programming aide (solid editing) or a runtime GUI
   (liquid editing)
2) Have a solid value that is saved.
   In practical terms: once you edit something, it stays edited
3) Can be changed with cell.set and cell.liquid_set.
   In practical terms: the command line (REPL) is one editor that is always
    available to you

Modifiers:
Modifiers are controllers that have no output pins. Instead, modifiers (and
only modifiers) have the ability to declare *modifier pins*
Modifier pins may only be connected to buffer cells
(who have a special connection point for it)
Modifier pins always make liquid incons
Modifiers may still embed an asynchronous process (implemented as thread,
requesting the buffer via a thread primitive)

Buffer cells:
Connections to and from buffer cells work a bit differently
Buffers are always allocated by the buffer manager (who reads the construction
parameters ), *not* by upstream controllers.

For incos, the upstream controller receives a buffer object
Buffer objects have a pointer to a memory chunk, dimensions, and contents
The upstream controller is *not* expected to rely on the current contents
The upstream controller is expected to change the contents within the dimensions
The upstream controller is allowed to request a change of dimensions. It is up
to the buffer manager how to deal with this (potentially reallocating the chunk)
The upstream controller may use the memory pointer, but *not* hold on to it
(the buffer manager may change it at any time)
For the rest, incos behave as for other cells: they may be solid or liquid,
master or non-master.
Buffers are implicitly initialized at all-zeros. Therefore, buffer cells
that do not have any solid incos and whose value never has been .set to anything
else than all-zeros, will not be saved when the world is saved

For outcos, the downstream controller also receives a buffer object
The buffer object is the same as for incos, however, the controller is expected
(implicitly!) to read the contents of the buffer object but *not* to modify them.
Likewise, the downstream controller is *not* expected to request changes in the
buffer object dimensions, etc.

Finally, the buffer cell has a *modifier connection point*.
They can be connected to modifier pins in modifiers (the source-target order is
unimportant), resulting in a modifier connection (modco).
A modco transmits a buffer object, just like a buffer inco or outco does. The
connected modifier may do anything that upstream or downstream controllers do.
However, modcos are always liquid.

Subcells:
Imagine a JSON cell "mycell" that contains the following:
[
  {
    "x" : 1,
    "y" : 2,
    "z" : 3,
  },
  {
    "x" : 10,
    "y" : 20,
    "z" : 30,
  }
]

It is possible to refer to subcells of mycell:
>>> s = mycell.subcell[0].y
>>> s.value
2
Subcell expressions may contain attribute access and item access
(including slices, but no negative indices).
It is not checked to what extent the subcell expressions refer to a real subvalue.
Subcells that do not point to a real subvalue behave as undefined cells
However, it is possible to .set (and .liquid_set) subcells, and
 for JSON, at least, missing elements are filled in as needed.

 >>> s = mycell.subcell[3].z
 >>> s.set(100)
 >>> mycell.value
 [
   {
     "x" : 1,
     "y" : 2,
     "z" : 3,
   },
   {
     "x" : 10,
     "y" : 20,
     "z" : 30,
   },
   None,
   {
     "z": 100
   }
 ]

It is possible to connect a subcell to controllers as if it were a cell.
Outcons behave normally; they have a listener to the paren cell (and to any
parent subcell). Incons behave in the same way as .set
Dependent subcells follow rule 1) and rule 3) for dependent cells. However, they
do not enforce any of the rules on the parent cells. Whenever a parent (sub)cell
has its value or solid_value modified, the dependent subcell is exempt from the
modification and has its old value restored.
Dependent cells do enforce all of the rules on their subcells.

Buffer cells and buffer dict cells
Buffer cells have pretty sophisticated construction parameters, e.g.
- Type and shape of the buffer
- Policies how to grow/reallocate it
- Policies for async modification, i.e. double or triple buffering
- Governing if the buffer is on the CPU (and if so, pinned or not), on the GPU
(and if so, visible to CUDA and/or OpenGL), or in unified memory.

Bufferdict cells are cells whose subcells are buffers. Bufferdict cells'
construction parameters are a dict of buffer construction parameters, but they
support additional syntax, e.g. to make two buffers point to different parts
of the same memory block.

There is a supermacro to create a buffer dict cell from a JSON cell that
contains a bufferdict construction parameter dict.

Cell names
Cells can have a name, but this is optional: cells can be nameless.
Nameless cells are assumed to be all constructed in the same global namespace.
Before you can construct any nameless cells, you must do
seamless.cell.register in the global namespace. Whenever a cell name is called
for (i.e. for debugging messages), the variable name(s) are looked up in the
namespace. If the cell can't be found, some ID is printed instead.
Cells that are part of an aggregate must be constructed from the aggregate
(the @macro and @supermacro decorators temporarily disable the possibility of
nameless cells).


Aggregates, macros and supermacros

Aggregates:
from seamless.cell import cell, python_cell, aggregate
ag = aggregate()
ag.randomseed = cell("int", 0)
ag.randomgen = python_cell()
