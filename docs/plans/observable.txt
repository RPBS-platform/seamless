Analysis of using Observable with Seamless
==========================================

I wrote this quite some time ago, before realizing that "manually" interacting with Seamless in JS using
 the Seamless client library is in fact not that difficult... Still, Observable is a good option in case
 of visualization of realtime streaming data.

    On the long-term, a fantastic in-browser edit-display framework is available: Observable.
   Observable is in agreement with much of the design philosophy of Seamless. Reactive, interactive, cell-based, dependency graph.
   It has a Jupyter-like reactive web editor (which is unfortunately not open source).
   However, it has a very flexible runtime where you can add new cells and link them up to the outside world.
   So one could embed an Observable notebook inside a web page as soon as a web *editor* could be embedded too.

Observable vs Seamless
1. Semantic differences
Observable:
The basis of the cell is a co-routine. Side effects, promises, animated properties
 are encouraged. Very fine control over execution order, but uncachable.
Loading data via URL is encouraged => hidden dependencies
Seamless:
Dependencies are very controlled. No URLs or function pointer, everything is text or binary.
Workers are expected to return soon, or run in a separate thread.
 No generators or promises. Seamless wants to equilibrate.
Side effects are carefully controlled, especially with "pure" attribute.
 This makes seamless much more like a pure functional language (term rewriting),
 whereas execution in Observable is much more tick-driven.
Seamless is very meta, as much as Lisp. Macros can generate topology.
Code cells are just text data. Code generation is much much easier.
 Seamless is not tied to one language.
Caching in seamless is easy, and macros are cached as well.
Seamless does reactive imports, whereas Observable's notebook imports are static.
Both are very strong in importing and modifying the imported graph. With Observable, it is simpler,
 but Seamless has more options (forking, or modifying all instances, or just changing
  execution strategy alone).
2. Syntactic differences
Observable:
The web editor has automatic dependency detection, and all code becomes a JS cell.
The web editor is therefore tied to "almost JS".
For example, a markdown cell becomes JS code returning markdown-interpreted HTML.
Using the runtime directly is much more powerful, but loses all the sugar.
Seamless:
Code is just Python. You must put it in a cell, explicitly, and ask a cell for its value,
 explicitly. Less sugar, but more flexible.
Seamless graph execution is easily rerouted elsewhere, e.g. to big clusters.
 Caching and retrieval-by-value are very important.
3. Conclusions
Observable is more agile and intuitive and integrates well with web technologies. It runs client-side.
Seamless is more explicit, flexible and rigorous and integrates well with numerical code. It runs server-side.
You can do visualizations with Seamless, but Observable is easier to use
 (web technologies) and will run better (no server-client latencies).
You can do computations with Observable, but Seamless is much better. Observable is not as eager
 as Jupyter, but it still computes too much compared to Seamless. Only Seamless can do
  well-defined, reproducible computations that run where the big data is and where the
  number crunching power is.
4. Summary.
The best is a combination of Seamless <=> Vue/React <=> Observable. The first <=> is generate/AJAX
 and the second <=> is embed/observe.
Start your plots and visualizations and widgets in Seamless (with Jupyter) if you prefer, 
 but move to Observable for serious work.
Start your algorithms in Observable if you prefer, but move to Seamless for serious work.

Seamless can also replace task-scheduling tools like Make, Gradle, Webpack, etc., trying to push away from the file system
 as a source of authority. Serving a file or serving a computation becomes blurred. Observable is not nearly so radical.

BIG LIMITING FACTOR: With Observable, you can 1) interactively reactively edit notebooks in the web editor;
2) embed a notebook via the Runtime, and set up dynamic data sources (and sinks). What you cannot do is both, since
 the web editor is not open source and has no remote API. An issue has been raised at observable-runtime's GitHub page.

UPDATE: URLSearchParams functions as a remote API: see https://github.com/observablehq/notebook-runtime/issues/140
To make a bifunctional (interactive+dynamicdata AND embeddable+dynamicdata) notebook:
- Start with a cell "cellsync_inject = null"
- Define a cellsync(attr, value) Observable cell. The function checks:
  - If "EXTERN" has been defined, pull/push the value from http://EXTERN/attr
    this uses URLSearchParams, which is just a cell that is always present.
  - If no "EXTERN" has been defined, check that the JS function "cellsync_inject" has been defined. If not, error.
  - During interactive development, define EXTERN (it should poll a Seamless server/service)
  - When embedding, just inject "cellsync_inject" as a function. No need for custom variables ("virtual cells").
    Check that JS functions can be injected like this!
