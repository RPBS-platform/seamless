Things to do for graph management
=================================

(None of them are very urgent)

- Adapt graph format wrt structured cells. Do we need to store
    "buffer" *and* "value"? They are always the same!
    Better to make some kind of "validated" attribute
    Also, when loading the graph, if it is trusted, not only update
    transformer cache and expression cache with elements mined from
    the graph, but also prevent StructuredCell joins if validated=True
    => loading and doing compute on a colored graph should do nothing, no transformations and no data loading!

TODO: buffer provenance cache
TODO: buffer size cache.
TODO: expression cache policy. Normally, cache only if the result buffer is much smaller than 
 the input buffer.

TODO: expression provenance cache: expression-result-to-expression. 
TODO: buffersize cache (checksum-to-buffersize) in ValueCache. Also in Redis and via communionserver
Both provenance caches (transformation and expression) are kept as local cache for any buffersize,
but they are offloaded to Redis only for larger buffers (>= 100 bytes)
TODO: implement and document text below:
TODO: graph storing/loading: Checksums of accessors (connections) are stored/loaded as well as the checksum of cells
NOTE: .protocol conversion/validation caches are never offloaded to Redis.
However, validation is only invoked if:
- The cell value (not the checksum!) is changed authoratively from the command line (SetCellValueTask)
- By an accessor, if the checksum of the accessor (or its target cell) changes
Therefore, graphs that contain results (including partial results; almost every graph contains some expression results)
can be loaded in trusted or non-trusted mode. In both cases, all checksums are set, but the differences are as follows.

In non-trusted mode: 
No caches are filled at all. This means that all expressions get re-evaluated, starting from authorative cells.
All transformations will be re-executed as well. 
However, since all results will (should!) be the same as the checksums of their outputs, there will be no propagations.
Reactors and macros get re-launched also.
However, checksums of reactor output pin accessors are set to "provisional" (TODO). When a reactor outputs a value, the
provisional status cleared. Whenever a reactor gives an exception,
all provisional accessors are void-cancelled. After equilibration, all provisional accessors are void-cancelled as well.

In trusted mode: 
All caches get filled:
- Transformation result cache
- Expression result cache
- Validation/conversion caches
This means that even though accessors/transformations will be initially re-evaluated, they all immediately get a cache hit.
In addition, since the cache hit is the same as their checksum, there will be no propagations.
Reactors and macros get re-launched anyway, which is as it should be (TODO: unless declared as pure). 
Reactors should give the same outputs, but if they do not, it gets overwritten.