TODO: Before the presentation:
Store and load computation graphs:
X Tests to "color" the graph (use Redis to fill in values)
X Tests for remote deployment of jobs
X Test for remote execution of a graph
X 01h00 Get Bash transformer working again (fix 2 bugsF)
- Docker transformer (DELAY)
- Conversions for Galaxy, Mobyle, SnakeMake (DELAY)
- Simple protein-based example

Presentation:
Two distinct goals:
- Seamless as Mobyle replacement at the RPBS
  Seamless as an enhanced Jupyter notebook
  Instead of using Jupyter directly to run the computations,
   the developer uses Jupyter a dependency graph of Seamless cells
   Seamless cells can be modified by the user (data cells) or the developer (code cells)
    *independent* of Jupyter; 
  Server, developer, user, collaboration
  Show simple example (oscar-star)  
- The RPBS as a center for provenance, reproducibility, and interoperability
  (implications for deployment)
  Explain about provenance and their relation to *banks*: you just re-submit the calculation
  Unified description of protocol, computation, result
  Goes far beyond Mobyle replacement (confirmed by people I talked with):
  - Checksum calculus, mathematical foundation 
  - FAIR principles, solves them at a technical level
    and solves them cheaply; given raw CPU power and data storage, easy to build
     valorization server (DNS server, Google)
Regression
Explain mechanics that currently work

Time path: 
I. Mobyle replacement
    - Simple example
    - End of the year: demo NAR web servers
        DaReUS-Loop server, structural alphabet server (based on near-native ensembles)
    - Time plan to replace all servers
II. Deployment, caching servers
    - Remote interactive mode execution
    - Docker-level deployment (one seamless, one service; include Jupyter)
    - Configuration! (job level, server level, ...) (endless talks with Julien)
    - Docker environment config (Linux distro), ORCID authority
III. Social context
- Development blog; guardian
- IFB interoperability workgroup, CAPRI evaluation

Limiting factors:
Examples (especially: more practical examples)
Documentation (especially: explaining the concepts)

Improvements: [two months fulltime of implementation]
Bugs: missing code paths, especially type conversion (also int/float/... cells) [a few days]
Bugs: interaction between Seamless features, smoother API (e.g. type inference) [continuous]
Interaction with rest of the world (bring back polyglot, add R) [a few days]
    => Compiled language without a compiler
Easier to work with:
- Automatic generation of web form GUIs [a day for initial proof-of-principle]
- Graph GUI [a day for initial proof-of-principle]
- Libraries/subcontexts/constructors [a few days]
- Logging error messages, cache misses, network traffic, progress bars [one week for a first implementation ]
- Job/cache control (canceling, job database, address cache memory leaks) [up to 2 weeks for a prototype]
- Better control of execution details (execution options, non-deterministic input pins, ephemeral cells, reactor start/stop side effects) [one week for initial implementation]
- Shells, or workers-as-Jupyter-kernels [a few days]
Big Data: deep cells [a few days], full streams (reduction, multi-inputs) [a few days]
Slash [a few days for reintegration]
GPU support: block cells [a week]

Long-term features:
Special constructs
Latency reduction: Stream-stream, GPU-GPU
Full-featured Silk
Git integration (with modularity)
Debugger integration
All the very-long-term stuff: DSL commands, Idris, plugin-socket