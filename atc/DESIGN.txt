.silk => .silkschema.xml                                  (self-contained)
.silkschema.xml => .schema.json                           (needs previous .silkschemas)
.schema.json => .minischema.json                          (self-contained)
.minischema.json + (optional) .silkschema.xml  => pyclass (needs previous silk pyclasses)

from seamless.atc.nodes import InputNode, OutputNode, TypeNode, ChainNode, ConvNode, MethodNode, WeaveNode

from silk import typeparse, build_minischema, register_minischema, register, get_blocks, xmlschemaparse

inp = InputNode(("schema", "silk"))
silk_definitions = OutputNode(("python", "register", "definitions", "silk"))
xml_silkschema = TypeNode(("xml", "schema", "silk"))
json_minischema = TypeNode(("json", "minischema"))
minischema_definitions = TypeNode(("python", "register", "definitions", "minischema"))
conv_typeparse = ConvNode(inp, xml_silkschema, typeparse)
conv_minischema = ConvNode(xml_silkschema, json_minischema, build_minischema)
conv_minischema_register = ConvCode(json_minischema, minischema_definitions, register_minischema)

def register_all(minischema_definitions, xmlschema):
    from .. import _minischemas
    schema = xmlschemaparse(xmlschema)
    all_blocks = get_blocks(schema)
    silk_definitions = []
    for definition in minischema_definitions:
        try:
            blocks = all_blocks[definition]
            register(
              _minischemas[definition],
              validation_blocks = blocks["validationblocks"],
              error_blocks = blocks["errorblocks"],
              method_blocks = blocks["methodblocks"],
            )
            silk_definitions.append(definition)
        except:
          ...
    return silk_definitions
weave = WeaveNode(minischema_definitions, xmlschema)
conv_register_all = ConvNode(weave, outp, register_all)
seamless.atc.register_nodal_converter(inp, outp)

ConvNode: inputtype, outputtype, function pointers
  Function pointer, not a cell!
  ATC supports decomposing a nodal operator into parts
    The ConvNodes will be cells/transformers
    Two possibilities:
    - Function pointer has code => becomes a code cell, ConvNode becomes ConvTransformer
    - Function pointer has no code => remains a function;
       design decision: OpNode becomes a special kind of transformer (builtin transformer)
         or: Function pointer becomes a special kind of cell (compiled Python cell)
ChainNode: inputpin, outputtype; no function pointer! relies on the existing ATC conversion machinery
  ChainNode can be decomposed on its own => ChainTransformer

MethodNode:  type, function pointer  (not cell)
Can be decomposed into MethodProcess, same conditions as ConvNode
InputNode, OutputNode => Pins

WeaveNode: combined multiple types into one. Collapsed into multi-cell.
