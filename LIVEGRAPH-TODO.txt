TODO in parallel: 
- status report, link to metainfo (see below)
    - no need to store in graph, as it gets reconstituted
- metainfo:
    - store exception and stdout/stderr of a transformation, include in status report
        also store if result was obtained from cache, or remotely
    - same for macro and reactor (easier, because 1:1)
    - same for cell:
        - structuredcell validation error
        - error in obtaining value from checksum (also if provenance fails)
    - implement storage for metainfo in graph
- logging system, based on event loop (in parallel to metainfo)
- progress bar system

TODO afterwards: dealing properly with explicit None values.
Make it so that transformations and reactors CAN set None on their result
 Same for None explicitly set on cells (cell.set_value(None), or cell.set_none() by a graph;
  cell.set_void() explicitly sets a cell to void-None)
 Read accessors that retrieve None when reading their path (as opposed to AttributeError/KeyError)
  also are considered "explicit None".
 Transformations that resulted in an exception are NOT explicit None (they are "void-None").
 Explicit None values are NOT void and do NOT lead to void cancellation
 Explicit None values are allowed on input pins that have their support explicitly enabled.

===================

The manager has too many functions. New concept of a "livegraph". This is what the manager
currently maintains, i.e. accessors, statuses, ..., i.e. all that goes beyond the 
simple static hierarchical low-level context.

Code must be split up into the following:

- Event loop management.
(see core/events). 
New concept of events that derive from Event, are processed asynchronously by adding them to eventloop. 
Replaces workqueue and cachetask. Also, most manager methods will be replaced by Event classes. Get rid of all async/awaits.
Each manager has its own event loop.
Each event loop has a counter, which means that each event has a monotonically increasing number.
 This number is not stored in the Event instance, but the loop keeps track of it through its counter.
Three kinds of events: SyncEvent, AsyncEvent, SingletonEvent.
When SyncEvent is executed, event loop is blocked. A SyncEvent should be fast, launching new
 events rather than recursive/reactive execution of methods.
AsyncEvents are non-blocking and cancelable (asyncio futures), and can take a long time.
SingletonEvents are related to flushing and status updates.
 When a SingletonEvent is pushed to the event loop, its event counter is stored.
 When it is pushed again, its event counter is updated.
 SingletonEvents that have an event counter higher than their actual event counter, are ignored
 (because the same event will be executed later on) 
TODO: manager must be active. Abolish context/worker _active prop (DONE).
TODO: integrate with communionserver to accept remote events, and return their result
 (keep track of origin connection to send response to; 
  also makes it possible to fwd remote events to all communion partners
  except their origin)

- manager.py. 
    Holds all other systems
    Maintains centralized API :
        - Section I: Registration (divide among subsystems)
        - Section II: Connection (divide among subsystems)
        - Section III: Set cell values
        - Section IV: Get cell values
        - Section V: Set worker results (passthrough)
        - Section VI: Equilibration
        - Section VII: Destruction
  NEW: connecting updates authority (see below)

- livegraph.py. Maintaining the livegraph: caches, accessors. Stores workers as well. Events for updates, integrate with
  task/job/cache system.

- authority.py. NEW: maintaining accessor authority (authoritative or not). It is illegal to modify
 non-authoritative paths from command line.

- Maintaining runtime statuses. Events for status update. NEW: preliminary.
Get rid of OVERRULED.

- Task/job/cache system, new classes that holds the mappings and launches tasks.
1. values.py. Value manager. Deals with getting and setting values. NEW: provenance, that can launch jobs if needed.
2. jobs.py. Job manager. Deals with jobs and their links to cells. Keep track of relevant caches. Maintain exceptions also.


UPDATE:

Conversion modifications:
    Do away with content type and copy/ref. There are only cell types now.
    Cell types are None (auto) by default. This means that the inputpins adopt the cell type of whatever cell is connected to them.
    For outputpins, you must connect them to whatever cell type is generated by the worker.
    Do away with value and buffer. All conversions are buffer-to-buffer.
    All buffers and checksums are syntactic. Semantic buffers don't exist. 
      Semantic values can be obtained from syntactic values in an explicit operation.
    Explicit caching of expressions (checksum + path + type => checksum). Explicit caching of syntactic-checksum-to-semantic-checksum.
    
(NOTE: remember that StructuredCell is only a wrapper. Connections (with paths) are for normal cells!
 Still, the manager will know if there was a wrapper, because paths are registered.)

Do away with status bookkeeping; compute status on demand.

Do away with events. Instead, actions spawn asynchronous tasks.
Task manager will keep track of dependencies.

Overhaul accessors and expressions.

TODO: voidness of cells (if non-void, checksum is not None, but checksum may not be known yet)

Actions
=======
Actions are sync; 
  launch task is done using ensure_future (taskmanager.launch(task)); 
  await is done using run_until_complete (taskmanager.launch_async(task)).
The following actions are possible:

- Register worker/cell. No tasks. 
  (but inform authoritymanager, caches etc.) 

- Connection. If the source has no checksum, do nothing.
  (but inform authoritymanager, caches etc.) 
  If the source is void:
    if source is a cell, do a cell cancellation, and launch a cell update task.
    if source is an outputpin/editpin, do a worker cancellation (no-op until we support optional pins).
     Then launch a worker update task.
     Workers are no longer executed with any unconnected output pins.

- Setting a cell checksum.
  (This is done from the command line, usually at graph loading)
  initial=True in case of graph loading; is_buffercell=True when triggered from StructuredCell)
  If "initial" is True, it is assumed that the context is being initialized (e.g. when created from a graph).
  Else, cell cannot be the .data or .buffer attribute of a StructuredCell, and cannot have any incoming connection.
  
  However, if "is_buffercell" is True, then the cell can be a .buffer attribute of a StructuredCell

  If the new checksum is None, do a cell void cancellation.  
  Else: 
    If old checksum is not None, do a cell cancellation.
    Set the cell as being non-void, set the checksum (direct attribute access), and launch a cell update task. 

- Setting a cell value. 
  (This is done from the command line, or editpin/mount/shareserver)
  Verify that the cell has authority and is not a data/buffer from a StructuredCell.
  Do a cell cancellation.
  Launch a set-cell-value task.

- Getting a buffercell path.
  (This is done through StructuredCell Backends. 
    TODO: shareserver and mount should invoke the StructuredCell too; for shareserver, configure allowed paths)
  Verify that target cell is a buffercell (which must be unconnected)
  Await a get-path task on the buffercell

- Setting an authoritative cell path.
  (This is done through StructuredCell Backends. 
    TODO: shareserver and mount should invoke the StructuredCell too; for shareserver, configure allowed paths)
  Verify that target cell is a buffercell (which must be unconnected)
  Verify that the modified path has full authority (see authoritymanager)
  Cancel any previous buffercell-join task, collect its modified paths, add current path to it
  Launch a set-auth-path task
  Launch a buffercell-join task, with modified paths as an argument, and which awaits the set-buffercell-path task

- Setting a non-authoritative cell path.
  (This is done through accessors that have a cell target.) 
  Verify that target cell is a datacell with an associated buffercell (which must be unconnected)
  Cancel any previous buffercell-join task, collect its modified paths, add current path to it
  Launch a set-path task on the buffercell
  Launch a buffercell-join task, with modified paths as an argument, and which awaits the set-path task

- Set cell exception
  (will be invoked by StructuredCell wrapper, upon validation. Eventually, make this available as cell.exception from the high level)

- Get cell checksum (public)
  Await cell checksum task.
  Return Get cell checksum (private)

- Get cell checksum (private)
  Simply return the stored checksum attribute


TODO: buffercell cache: buffercell ID to value (live Python object, NOT buffer!).
TODO: semantic-to-syntactic-checksum cache
TODO: provenance cache
TODO: deepcell monitor
TODO: two kind of accessors: read accessors and write accessor.
Each connection is modelled as a read accessor + write accessor. 
A read accessor has an associated expression.
TODO: buffer size cache.
TODO: exception cache. Works like transformer result cache, but needs better facilities to flush
 (after all, exceptions are less deterministic than results).
TODO: expression cache policy. Normally, cache only if the result buffer is much smaller than 
 the input buffer.
 

Tasks
=====
Each task is asynchronous and has a list of cell/accessor/expression dependencies.
If the dependency has its checksum changed/set to None,
 cancel all dependent tasks.
Child tasks can be either awaited directly (which means that they get
 canceled together with the parent task), or they can be registered
 with their own dependency.
Update tasks must be unique for each cell/accessor/worker. 
  If one is already running for that cell/accessor/worker, an exception is raised.
  Therefore, the old one must been cancelled before.
  Update tasks are never awaited as child tasks.
Some tasks use refcounting dependencies. This is because multiple accessors
 can resolve to the same expression, and multiple transformers may resolve
 to the same transformation.
 Refcounting tasks use an incref/decref system. If a dependency changes checksum
 or is destroyed, the task is decref'ed
 (a compensatory incref that lasts 20 secs is then awarded). 

List of tasks:
- Cell checksum task
    Updates the checksum of the cell.
  - Await current set-path/set-auth-path tasks for the cell. It doesn't matter if they were cancelled.  
  - Await get buffer task
  - Await calculate checksum task
  - If the checksum is not None and cell's void attribute is True, log a warning, set it to False, and launch a cell update task
  - Set the cell's checksum attribute (direct attribute access)
  - If the checksum was None but the void attribute was not None, do a cell void cancellation.

- Cell update task
  - If the cell's void attribute is True, log a warning and return.
  - Await cell checksum task
  - If the checksum is None, for each output accessor:
      - do a void cancellation
    Else, for each output read accessor:
      - construct (not evaluate!) their expression using the cell checksum 
        Constructing a downstream expression increfs the cell checksum
      - launch an accessor update task

- Accessor update task.
  For a read accessor:
    - Await/incref expression evaluation task. Incref the expression. 
    - If the expression checksum is None: run a void cancellation and return
    - Select all downstream write accessors,set as their checksum the checksum of our expression
        (this increfs the checksum), and launch an update task.
  For a write accessor:
    For each target:
      If a cell:
        - Select target cell
        - If cell is void, give a warning, and set to non-void
        - If the path is empty:
          Set the cell checksum (direct attribute access). If checksum is None, set void.
        - Else, run a set-non-authorative-path *action*, which will launch a set-path task.
        - Launch a cell update task (it will automatically await the set-path task, if any)
      If a worker:
        - Cancel the previous update task if any
        - Decref the current transformation task.
        - Launch a new worker update task.

- Worker update task.
  - Check that all inputpins/editpin accessors are connected and have valid checksums. If not, return.
  - For each of those checksums, await get-semantic-checksum task
  For a transformer:
    - From the semantic checksums, build a transformation.
    - Launch a transformation task
  For a macro:
    - From the semantic checksums, build a argument dict (await get-buffer and deserialize tasks)
    - Synchronously (re-)run the macro using argument dict
  For a reactor:
    If there is a live reactor instance:
        - Get the semantic checksums from the live reactor
        - Look which ones are different, and build a delta dict (await get-buffer and deserialize tasks)
        - Synchronously invoke code_update on the live reactor, using the delta dict
    Else:
        - Build a live reactor instance
        - From the semantic checksums, build a argument dict (await get-buffer and deserialize tasks)
        - Synchronously invoke code_start and code_update on the live reactor, using the argument dict
    In both cases, gather the emitted outputs, and launch accessor update tasks for each.
    If there are emitted editpins, run "set cell value" and/or "set authoritative cell path" actions

- Expression evaluation task.
  Depends on read-accessors, using refcounting.
  - For trivial expressions, obtain the result checksum directly
  - Await expression cache (also remote)
  - If cache miss:
        - Await get buffer task
        - Evaluate the path WITHOUT using the Monitor wrapper (naively, but special mechanics for deep cells). 
        - Await serialization task (using cell type)
        - Await calculate checksum task
        - Add result checksum in expression cache
  - Add result checksum to expression

- Get buffer task.
  Gets the buffer from its checksum
  - Check for a local checksum-to-buffer cache hit (synchronous)
  - Else, check Redis cache (currently synchronous; make it async in a future version)
  - Else, await remote checksum-to-buffer cache
  - Else, if the checksum has provenance, the buffer may be obtained by launching a transformation.
    However, in this case, the transformation must be local OR it must be ensured that remote
    transformations lead to the result value being available (a misconfig here would lead to a
    infinite loop).
  - If successful, add the buffer to local and/or Redis cache (with a tempref or a permanent ref).
  - If all fails, raise Exception


- Get-semantic-checksum task
  Gets a semantic checksum from a syntactic one (celltype is an argument)
  - If the conversion is trivial, return syntactic checksum
  - Await semantic checksum cache (also remote) (includes celltype)
  - If cache miss:
    - Await get buffer task    
    - Await deserialization task (using cell type)
    - Compute semantic checksum (using cell type)
      Store checksum mapping in semantic cache
    - Await serialization task (using cell type)
    - Await calculate checksum task
    - Add result checksum in semantic checksum cache (including celltype)

- Set-cell-value task. 
    Value must not be None.
    - Set cell-to-value cache
    - Await serialization task (using celltype)
    - Await calculate checksum task. If None, raise Exception.
    - Set cell checksum (direct attribute modification)
    - Launch cell update task
    - Pop cell-to-value cache

- Get-path task
    NOTE: only ever invoked through the command line (sync code) on buffercells; 
     in contrast, expression evaluation is a different task that does not use the Monitor
  - Cancel delayed-buffercell-clear task for this buffercell (if any)
  - Gather current set-path/set-auth-path tasks for the buffercell
  - Await the tasks (with shield), except if marked as re-entrant
  - Get the dependent buffercell ID. Retrieve its value from buffercell cache. If there is a cache miss:
    - Retrieve its checksum (private API)
    - Await deserialization task (using celltype)
    - Add the value to the buffercell cache
  - Evaluate the path using the Monitor wrapper (naively, but special mechanics for deep cells). 
      This may also spawn new get-path tasks.
  - Cancel delayed-buffercell-clear task for this buffercell (if any)
  - Register a delayed-buffercell-clear task for this buffercell

- Set-auth-path task
    NOTE: only ever invoked through the command line (sync code) on buffercells; 
  - Cancel delayed-buffercell-clear task for this buffercell (if any)
  - Gather current set-path/set-auth-path tasks for the buffercell
  - If none of these tasks are re-entrant:
      Modify the last task so that its checksum step is disabled (cancel it if checksum step is in progress)
    Else: disable our own checksum step
  - Await the tasks (with shield), except if marked as re-entrant
  - Get the dependent buffercell ID. Retrieve its value from buffercell cache. If there is a cache miss:
    - Retrieve its checksum (private API)
    - Await deserialization task (using celltype)
    - Add the value to the buffercell cache
  - Mark the current task as re-entrant
  - Modify the value using the Monitor wrapper (naively, but special mechanics for deep cells)
      This may also spawn new get-path tasks.
  - Unmark the current task as re-entrant
  - Check if the checksum step has been disabled. If not:
    - Set cell-to-value cache
    - Await serialization task (using celltype)
    - Await calculate checksum task
    - Cancel delayed-buffercell-clear task for this buffercell (if any)
    - Register a delayed-buffercell-clear task for this buffercell
    - Pop cell-to-value cache

- Set-path task (takes checksum + checksum_celltype as argument)
   (Will be invoked by write accessors on buffercell targets; NOTE: only invoked via an action!)
  - Gather current set-path/set-auth-path tasks for the buffercell
  - If none of these tasks are re-entrant:
      Modify the last task so that its checksum step is disabled (cancel it if checksum step is in progress)
    Else: disable our own checksum step
  - Await the tasks (with shield), except if marked as re-entrant
  - Retrieve the checksum of the dependent cell
  - Await get-buffer deserialization task for target cell (using celltype)
  - Mark the current task as re-entrant
  - Await get-buffer + deserialization task for checksum argument (using checksum_celltype)
  - Modify the value using the Monitor (naively, but special mechanics for deep cells)
    This may also spawn new get/set path tasks.
  - Unmark the current task as re-entrant
  - Check if the checksum step has been disabled. If not:
    - Set cell-to-value cache
    - Await serialization task (using celltype)
    - Await calculate checksum task
    - Pop cell-to-value cache

- Buffercell-join task, indicating which paths were modified
  - Await asyncio.shield(awaitable) (2nd function argument)
  - Get buffercell checksum (private API)
  - Set datacell checksum (direct attribute modification)
  - Distill which outchannels were modified.
  - For each modified outchannel read accessor:
    - Do a accessor cancellation
    - construct (not evaluate!) their expression using the cell checksum 
      Constructing a downstream expression increfs the cell checksum
    - launch an accessor update task
  - For each non-modified outchannel read accessor:
    - Do an accessor morphing with the updated checksum


- delayed-buffercell-clear task
  (Depends on cell ID, rather than checksum. Destroy mechanics must be implemented correctly)
  Sleep 20 seconds. Afterwards, remove cell ID from buffercell cache.

- Serialization task (using celltype, from value)
  Can be LRU-cached and incref'ed, from value object ID
  Should be launched in a subprocess executor

- Deserialization task (using celltype)
  Can be LRU-cached and incref'ed, based on checksum+celltype.   
  Should be launched in a subprocess executor.

- Calculate checksum task (from buffer) 
  Can be LRU-cached and incref'ed, from value object ID
  Should be launched in a subprocess executor

- Transformer activation task (depends on each input read accessor)
  - Launch and await "Get semantic checksum" task for each input pin
  - Register transformation task (incref if already exists).
    Add the transformer to the list of the transformation's underlying transformers.    

- Transformation task  
  - Check for transformation cache (local, Redis and remote) and exception cache (local, Redis and remote).
  - Else, check if remote transformation servers can do the job.
  - Else, run the job locally.
    NOTE: don't use asyncio executor to launch local transformations, since we need response message queues. Current code works fine.
  - Await the job.
  - If there is an exception, store it in cache.
  - If no exception or None, add transformation result checksum to cache (local and redis)
    Transformation results are small and therefore get stored indefinitely. Incref/decref (launched transformer cancellation/destruction) 
      is only for *running* transformation tasks, removing the transformer from their output, and canceling if the output is empty.
  - For each underlying transformer:  
    - If there is an exception or the transformation checksum is None, do a transformation void cancellation
    - Otherwise, select the output write accessors. For each accessor:
        - Set the as their checksum the transformation checksum (this increfs the checksum)
        - Launch accessor update task

Cancellations
=============
Cancellations are sync, like actions.
- Cell cancellation (with possible void option).  
  The entire cell has changed value. 
  - Cancel all set-path / set-auth-path tasks.
  - If void option, set checksum to None, and void to True
  - Select all downstream accessors and do cancellation on them (propagating void).
- Accessor cancellation (with possible void option).
  The accessor has an updated checksum and the result is probably different. 
  - Cancel/decref all tasks that depend on the accessor or its previous expression.
  - If void option, set void to True
  - Clear and decref the accessor's associated expression. (If the expression is freed, this leads to a decref of the associated checksum)
  - Select all downstream cells, accessors and workers, and do cancellation on them (propagating void).
- Accessor morphing. The expression now operates on an expression with a different checksum, but it has been proven that
   the result is unaffected. For all existing expression/accessor-dependent tasks, add the updated expression
   as a caching output (and incref the updated expression).
   Decref the accessor's old associated expression. (If the expression is freed, this leads to a decref of the associated checksum)
   Set and incref the updated expression.
- Transformer cancellation (with possible void option).
  Decref the associated transformation, remove the transformer from its outputs.
  Select all downstream accessors, and do cancellation on them (propagating void).