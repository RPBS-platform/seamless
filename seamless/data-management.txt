Data management in Seamless
===========================

NOTE: The Seamless graph offers a unified format to describe:
- protocols (web services, unfilled web forms): a graph with code cells, undefined input cells, and undefined output cells.
- computations (jobs, filled-in web forms): a graph with code cells, input cells, and undefined output cells.
- results: a graph with code cells, input cells and output cells, where every cell is defined.
However, Seamless graphs contain no values at all, only checksums.
This means that they are small (and we should store them essentially forever)
On the other hands, this also means that every checksum needs to be backed up by data storage 
(checksum-to-value caching), else a Seamless graph becomes useless.
Therefore, from a Seamless point-of-view, data management is nothing more or less than *persistence*:
 deciding how long to maintain a checksum-to-value cache entry (*). 

It is observed that there are fundamentally *two kinds of values*:

Small values:
For example: "4", "1AVX", True. These values are even smaller than their checksum.
In principle, they can be maintained with *(semi-)permanent persistence*. Redis supports the entry of a value with a certain
 lifetime. Whenever the value is accessed, the lifetime can be renewed. With this, we can support the
 storage of all small values that have been used in Seamless jobs, say, for the last 10 years.
These values are also:
- Entered directly as parameters in a web form / command line
- Not privacy-sensitive
- Without provenance/meta-data. It is useless to store all computations that use the value "4" for any parameter, or
   all calculations that have "4" as the result. There are many, and there is no scientific value.

Big values:
- They are much larger than their checksums, there is no upper limit (could be terabytes!).
- These are uploaded from a file in a web form, or specified as file name arguments on the command line.
  Or they contain source code that performs computation.
- They can be privacy-sensitive
- Storing their provenance/meta-data is very useful, and essential to correct data management. 
  When were they first defined, by whom, where they produced by a Seamless graph, or by some other 
  calculation, what is the format, is it code on GitHub, what is the license, etc.

I propose two different concepts, workspaces and minispaces, to deal with data management for the
 platform.

Workspaces
==========
....
Auto-clean workspaces...
....
We could try to support workspaces that are private. 
 In that case, their checksums would bbe still visible, but all of their provenance/meta-data is not. 
We could try to set up a system where requests to the RPBS of the
 value corresponding to a checksum are rejected if a checksum is only in private workspaces, 
 unless the request comes from inside the RPBS, or unless the request has been authorized by a
However, in that case, the data and meta-data would still be stored with us, and therefore hackable.
 External workspaces (see below) are a much better solution.

Minispaces
==========
Minispaces are live Seamless instances where all input cells are shared, i.e. accessible via REST share server.
These Seamless instances have no *local* cache, they are only connected to Redis, 
 so they use almost no memory (and no disk space) by themselves.
They only receive *small values* and *checksums of big values*. Whenever they receive a small value,
 they compute-and-store the checksum and offload the value to Redis, in (semi-)permanent persistence.
Minispaces are tied to a web form. Whenever ...
For non-interactive web forms, the minispace is a Seamless context of just cells
 (with potentially some schemas to perform validation). When a "run"  
 ...
For interactive web forms, the minispace is a Seamless context of the entire computation graph. 
It is hooked up a-priori with some workspace(s) to store outputs and intermediate results.


Data security through external workspaces
=========================================
We cannot guarantee data security at the RPBS. But sensitive data/code can be stored elsewere, let's 
say, at a hospital, and the data will never be accessed by the RPBS. Thus, data security is achieved.
Because: the checksum of the sensitive data/code will be publicly available, and the RPBS can 
still construct jobs that use these checksums, even if the data/code is stored at the hospital. 
This requires that the job is sent to Seamless-running-at-the hospital to be executed there.
Likewise, the hospital may choose to only send the job result checksum back, not its value. 
In that case, the RPBS can still store the job result checksum in the result graph, 
and store the result graph at the RPBS, so reproducibility is maintained.
But the job result value can then only be obtained by people at the hospital, and whoever they choose
 to share their data with (hopefully, the journal where they publish their results).


(*) = checksum-to-value cache, provenance cache, etc. are implemented as a sinngle Redis database, backed up
 by a big hard disk. This Redis database will run on the "console" machine at the RPBS, and be accessible
 over the network, so every Seamless instance running on our cluster has direct access. This will make 
 Lustre superfluous).