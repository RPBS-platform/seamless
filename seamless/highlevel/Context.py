import traceback
from copy import deepcopy
from collections import namedtuple
import weakref
import itertools
import threading, time
import asyncio, concurrent
import inspect
import functools
from functools import partial
from zipfile import ZipFile
from io import BytesIO

from .Base import Base
from ..core import macro_mode
from ..core.macro_mode import macro_mode_on, get_macro_mode
from ..core.context import context, Context as CoreContext
from ..core.cell import cell
from ..core.mount import mountmanager #for now, just a single global mountmanager
from .assign import assign
from .proxy import Proxy
from ..midlevel import copying

Graph = namedtuple("Graph", ("nodes", "connections", "params", "lib"))

shareserver = None

def run_in_mainthread(func):
    def func2(*args, **kwargs):
        ctx = args[0]
        manager = ctx._manager
        if threading.current_thread() != threading.main_thread():
            manager.taskmanager.add_synctask(func, args, kwargs, with_event=False)
        else:
            func(*args, **kwargs)    
    functools.update_wrapper(func2, func)
    return func2

Graph = namedtuple("Graph", ("nodes", "connections", "params", "lib"))

shareserver = None


def get_status(parent, children, nodes, path):
    from ..core.context import StatusReport
    result = StatusReport()
    if path is not None:
        lp = len(path)
    all_children = itertools.chain(children.items(), nodes.items())
    for childname0, child in all_children:    
        if path is not None:            
            if childname0[:lp] != path:
                continue
            childname0 = childname0[lp:]
        if len(childname0) != 1:
            continue
        childname = childname0[0]
        if isinstance(child, dict):  # node
            if child["type"] != "context":
                continue
            subpath = (childname,)
            if path is not None:
                subpath = path + subpath
            child = SubContext(parent, subpath)
        s = child.status
        if s != "Status: OK":
            result[childname] = s
    if len(result):
        return result
    else:
        return "Status: OK"

class Context(Base):
    _mount = None
    _translating = False
    _shares = None
    _translate_count = 0 
    _auto_translate = False 
    _gen_context = None
    _libmacro_graph = None
    _weak = False  # True for autogenerated contexts that have no strong reference

    @classmethod
    def from_graph(cls, graph, manager):
        self = cls(manager=manager)
        self.set_graph(graph)
        graph = deepcopy(graph)
        return self

    def set_graph(self, graph):
        graph = deepcopy(graph)        
        nodes = {}        
        for node in graph["nodes"]:
            p = tuple(node["path"])
            node["path"] = p
            nodes[p] = node
            nodetype = node["type"]
            nodecls = nodeclasses[nodetype]
            child = nodecls(parent=self,path=p)
        connections = graph["connections"]
        for con in connections:
            if con["type"] == "connection":
                con["source"] = tuple(con["source"])
                con["target"] = tuple(con["target"])
            elif con["type"] == "link":
                con["first"] = tuple(con["first"])
                con["second"] = tuple(con["second"])
        self._graph = Graph(nodes, connections, graph["params"], graph.get("lib", {}))
        self._translate()
        return self

    def __init__(self, dummy=False, manager=None):
        super().__init__(None, ())
        from seamless.core.manager import Manager
        self._dummy = dummy
        if manager is not None:            
            assert isinstance(manager, Manager), type(manager)
            self._manager = manager
        else:
            self._manager = Manager()
        self._graph = Graph({},[],{},{})
        self._children = {}
        self._needs_translation = True
        self._parent = weakref.ref(self)
        self._traitlets = {}
        self._observers = set()
        
        def auto_trans():
            while 1:
                if self.auto_translate:                    
                    self.translate()
                time.sleep(1)
        thread = threading.Thread(target=auto_trans)
        thread.daemon = True
        thread.start()
        self._auto_translate_thread = thread

    def _get_node(self, path):
        try:
            return self._graph[0][path]
        except KeyError:
            try:
                return self._libmacro_graph.nodes[path]
            except KeyError:
                raise KeyError(path) from None

    def _get_path(self, path):
        child = self._children.get(path)
        if child is not None:
            return child
        node = self._graph[0].get(path)
        if node is not None:
            if node["type"] == "libmacro":
                return LibMacro(self, path=path)
            assert node["type"] == "context", (path, node["type"]) #if not context, should be in children!
            return SubContext(self, path)
        return Proxy(self, path, "w")

    def _get_subcontext(self, path):
        child = self._children[path]

    def __getattr__(self, attr):
        if attr.startswith("_"):
            raise AttributeError(attr)
        if attr in type(self).__dict__:
            raise AttributeError(attr)
        path = (attr,)
        return self._get_path(path)

    def __setattr__(self, attr, value):
        if attr.startswith("_"):
            return object.__setattr__(self, attr, value)
        members = {k:v for k,v in inspect.getmembers(type(self))}
        if attr in members and isinstance(members[attr], property):
            return object.__setattr__(self, attr, value)
        attr2 = (attr,)
        if isinstance(value, Reactor):
            value._init(self, (attr,) )
            self._translate()
        elif isinstance(value, Transformer):
            if value._parent is None:
                self._graph[0][attr2] = value
                self._children[attr2] = value
                value._init(self, attr2 )
                self._translate()
            else:
                assign(self, attr2, value)
            """
        elif attr2 in self._children:
            child = self._children[attr2]
            if isinstance(child, Cell):
                child.set(value)
            """
        else:
            assign(self, attr2, value)

    def __delattr__(self, attr):
        self._destroy_path((attr,))

    def _add_traitlet(self, path, trigger):
        from .SeamlessTraitlet import SeamlessTraitlet
        traitlet = self._traitlets.get(path)
        traitlet = SeamlessTraitlet(value=None)
        traitlet.parent = weakref.ref(self)
        traitlet.path = path
        if trigger:
            traitlet._connect_seamless()
        self._traitlets[path] = traitlet
        self._translate()
        return traitlet

    def mount(self, path=None, mode="rw", authority="cell", persistent=None):
        assert not self._dummy
        if self._parent() is not self:
            raise NotImplementedError
        if path is None:
            self._mount = None
            return
        self._mount = {
            "path": path,
            "mode": mode,
            "authority": authority,
            "persistent": persistent
        }
        self._translate()
    
    def equilibrate(self, timeout=None):
        if self._dummy:
            return
        self.translate()
        return self._gen_context.equilibrate(timeout)

    def self(self):
        raise NotImplementedError

    def _translate(self):
        self._needs_translation = True

    def translate(self, force=False):
        return self._do_translate(force=force, explicit=True)

    @property 
    def auto_translate(self):
        return self._auto_translate

    @auto_translate.setter
    def auto_translate(self, value):
        if not isinstance(value, bool):
            raise TypeError(type(value))
        self._auto_translate = value

    def _get_graph(self, copy):    
        from ..core.manager.tasks.structured_cell import StructuredCellJoinTask
        from ..core.manager.tasks import SetCellValueTask, SetCellBufferTask
        join_task_types = (
            SetCellValueTask, SetCellBufferTask, StructuredCellJoinTask
        )

        if self._gen_context is not None:
            taskmanager = self._gen_context._get_manager().taskmanager
            def get_join_tasks(taskmanager):
                tasks = []
                for task in taskmanager.tasks:
                    if isinstance(task, join_task_types):
                        tasks.append(task)
                return tasks
            remaining, _ = taskmanager.equilibrate(
                timeout=10, report=2, 
                get_tasks_func=get_join_tasks
            )
            assert not len(remaining), remaining
        try:
            self._translating = True
            manager = self._manager
            copying.fill_checksums(manager, self._graph.nodes)            
        finally:
            self._translating = False
        nodes, connections, params, lib = self._graph
        nodes = [v for k,v in sorted(nodes.items(), key=lambda kv: kv[0])]
        if copy:
            connections = deepcopy(connections)
            nodes = deepcopy(nodes)
            params = deepcopy(params)
            lib = deepcopy(lib)
        graph = {
            "nodes": nodes, 
            "connections": connections, 
            "params": params,
            "lib": lib,
        }
        return graph

    def get_graph(self):
        return self._get_graph(copy=True)

    def get_zip(self):
        # TODO: option to follow deep cell checksums
        force = (self._gen_context is None)
        self._do_translate(force=force)
        graph = self.get_graph()
        nodes0 = graph["nodes"]
        nodes = {tuple(node["path"]):node for node in nodes0}
        checksums = copying.get_checksums(nodes)
        manager = self._gen_context._get_manager()        
        buffer_dict = copying.get_buffer_dict_sync(manager, checksums)
        archive = BytesIO()
        with ZipFile(archive, mode="w") as zipfile:
            for checksum, buffer in buffer_dict.items():
                zipfile.writestr(checksum, buffer)
        result = archive.getvalue()
        archive.close()
        return result

    def add_zip(self, zip):
        if self._gen_context is None:
            self._do_translate(force=True)
        manager = self._gen_context._get_manager()
        if isinstance(zip, bytes):
            archive = BytesIO(zip)
            zipfile = ZipFile(archive, "r")
        elif isinstance(zip, str):
            zipfile = ZipFile(zip, "r")
        elif isinstance(zip, ZipFile):
            zipfile = zip
        else:
            raise TypeError(type(zip))        
        return copying.add_zip(manager, zipfile)

    def include(self, lib, only_zip=False, full_path=False):
        from .library import Library
        if not isinstance(lib, Library):
            raise TypeError(type(lib))
        if only_zip:
            lib.include_zip(self)
        else:
            lib.include(self, full_path=full_path)
            self._translate()

    @run_in_mainthread
    def _do_translate(self, force=False, explicit=False):        
        from ..midlevel.translate import translate, import_before_translate
        from ..midlevel.pretranslate import pretranslate
        if self._dummy:
            return
        graph0 = self._get_graph(copy=False)
        #from pprint import pprint; pprint(graph0)
        if not force and not self._needs_translation:
            return
        """
        if self._translating:
            raise Exception("Nested invocation of ctx.translate")
        """
        if self._translating:
            return
        graph = pretranslate(self, graph0)
        if graph is not graph0:
            libmacro_nodes = {node["path"]: node for node in graph["nodes"]}
            self._libmacro_graph = Graph(
                libmacro_nodes,
                graph["connections"],
                graph["params"],
                graph["lib"]
            )
        self._translate_count += 1
        try:            
            self._translating = True
            ctx = None
            if self._gen_context is not None:
                self._gen_context.destroy()
            import_before_translate(graph)
            with macro_mode_on():
                ub_ctx = context(
                    toplevel=True,
                    manager=self._manager
                )
                if self._mount is not None:
                    ub_ctx._mount = self._mount.copy()
                self._unbound_context = ub_ctx                
                translate(graph, ub_ctx)
                self._connect_share()
            self._gen_context = ub_ctx._bound
        finally:
            self._translating = False
            self._unbound_context = None
        for traitlet in self._traitlets.values():
            traitlet._connect_seamless()        
        self._needs_translation = False

        for path, child in self._children.items():
            if isinstance(child, (Cell, Transformer, Reactor, Macro)):
                child._set_observers()
            elif isinstance(child, (InputPin, OutputPin, Link)):
                continue
            else:
                raise TypeError(type(child))

    def _connect_share(self):
        if self._shares is None:
            return
        from ..core import StructuredCell, Cell as core_cell
        sharedict = {}        
        for path in self._shares:
            key = "/".join(path) #TODO: split in subpaths by inspecting and traversing ctx._children (recursively for subcontext children)
            hcell = self._children[path]
            if not isinstance(hcell, Cell):
                raise NotImplementedError(type(hcell))
            cell = hcell._get_cell()
            if isinstance(cell, StructuredCell):
                pass #TODO: see above
            elif isinstance(cell, core_cell):
                pass #TODO: see above
            else:
                raise TypeError(cell)
            sharedict[key] = cell, hcell.mimetype

        if shareserver is not None:
            shareserver.share(self._share_namespace, sharedict)
        for key, value in sharedict.items():
            cell = value[0]
            sharefunc = partial(shareserver.send_update, self._share_namespace, key)
            cell._set_share_callback(sharefunc)
            sharefunc()

    def _destroy_path(self, path):
        nodes = self._graph.nodes
        for p in list(nodes.keys()):
            if p[:len(path)] == path:
                node = nodes[p]
                child = self._children.get(p)
                nodes.pop(p)
                self._children.pop(p, None)
                if self._shares is not None:
                    self._shares.pop(p, None)
                self._translate()

        nodes = self._graph.nodes
        l = len(nodes)
        newnodes = {k:v for k,v in nodes.items() \
                    if k[:len(path)] != path }
        if len(newnodes) < l:
            nodes.clear()
            nodes.update(newnodes)
            self._translate()

        connections = self._graph.connections
        removed = self._remove_connections(path)
        if removed:
            self._translate()

    @property
    def status(self):
        """The computation status of the context
        Returns a dictionary containing the status of all children that are not OK.
        If all children are OK, returns "Status: OK"
        """
        assert not self._dummy
        nodes, _, _, _ = self._graph
        return get_status(self, self._children, nodes, path=None)

    @property
    def lib(self):
        from .library.include import IncludedLibraryContainer
        return IncludedLibraryContainer(self, ())

    def resolve(self, checksum):
        return self._manager.resolve(checksum)

    def observe(self, path, callback, polling_interval):
        observer = PollingObserver(self, path, callback, polling_interval)
        self._observers.add(observer)

    def _get_libs(self, path):
        lib = self._graph.lib
        lp = len(path)
        result = {k[lp:]:v for k,v in lib.items() \
                  if len(k) > lp and k[:lp] == path \
                }
        return result

    def _get_lib(self, path):
        return self._graph.lib[tuple(path)]

    def _remove_connections(self, path, keep_links=False):
        # Removes all connections starting with path
        lp = len(path)
        def keep_con(con):
            if con["type"] == "link":
                if keep_links:
                    return True
                first = con["first"]
                if first[:lp] == path:
                    return False
                second = con["second"]
                if second[:lp] == path:
                    return False
                return True
            else:
                ctarget = con["target"]
                return ctarget[:lp] != path
        connections = self._graph[1]
        new_connections = list(filter(keep_con, connections))
        any_removed = (len(new_connections) < len(connections))            
        connections[:] = new_connections
        return any_removed

    def _share(self, cell):
        key = ".".join(cell._path)
        if self._shares is None:
            global shareserver
            from .. import shareserver
            shareserver.start()
            self._share_namespace = shareserver.new_namespace("ctx")
            self._shares = set()
        self._shares.add(cell._path)
        self._translate()

    def link(self, first, second):
        link = Link(self, first=first, second=second)
        connections = self._graph.connections
        connections.append(link._node)
        self._translate()

    def get_links(self):
        connections = self._graph.connections
        result = []
        for node in connections:
            if node["type"] == "link":
                result.append(Link(self, node=node))
        return result

    def __dir__(self):
        d = [p for p in type(self).__dict__ if not p.startswith("_")]
        subs = [p[0] for p in self._children]
        return sorted(d + list(set(subs)))


class SubContext(Base):
    def __init__(self, parent, path):
        super().__init__(parent, path)

    def __getattr__(self, attr):
        if attr.startswith("_"):
            raise AttributeError(attr)
        if attr in type(self).__dict__:
            raise AttributeError(attr)
        parent = self._get_top_parent()
        path = self._path + (attr,)
        return parent._get_path(path)

    def __setattr__(self, attr, value):
        if attr.startswith("_"):
            return object.__setattr__(self, attr, value)
        parent = self._get_top_parent()
        path = self._path + (attr,)
        if isinstance(value, Reactor):            
            value._init(parent, path)
            parent._translate()
        elif isinstance(value, Transformer):
            if value._parent is None:
                parent._graph[0][path] = value
                parent._children[path] = value
                value._init(parent, path )
                parent._translate()
            else:
                assign(parent, path, value)
        else:
            assign(parent, path, value)

    def _get_top_parent(self):
        parent = self._parent()
        if isinstance(parent, Context):
            return parent
        else:
            return parent._get_parent()

    def __delattr__(self, attr):
        raise NotImplementedError

    def mount(self, mountdir):
        raise NotImplementedError

    def _get_graph(self, copy):
        parent = self._parent()
        nodes, connections, params, _ = parent._graph
        path = self._path
        lp = len(path)
        newnodes = []        
        for nodepath, node in sorted(nodes.items(), key=lambda kv: kv[0]):
            if len(nodepath) > lp and nodepath[:lp] == path:
                newnode = deepcopy(node)
                newnode["path"] = nodepath[lp:]
                newnodes.append(newnode)
        new_connections = []
        for connection in connections:
            if connection["type"] == "connection":
                source, target = connection["source"], connection["target"]
                if source[:lp] == path and target[:lp] == path:
                    con = deepcopy(connection)
                    con["source"] = source[lp:]
                    con["target"] = target[lp:]
                    new_connections.append(con)
            elif connection["type"] == "link":
                first, second = connection["first"], connection["second"]
                if first[:lp] == path and second[:lp] == path:
                    con = deepcopy(connection)
                    con["first"] = first[lp:]
                    con["second"] = second[lp:]
                    new_connections.append(con)
        if copy:
            params = deepcopy(params)
        graph = {
            "nodes": newnodes, 
            "connections": new_connections, 
            "params": params
        }
        return graph

    def get_graph(self):
        return self._get_graph(copy=True)

    @property
    def status(self):
        parent = self._parent()
        nodes, _, _, _ = parent._graph
        return get_status(parent, parent._children, nodes, self._path)

    def _translate(self):
        self._parent()._translate()

    def __dir__(self):
        d = [p for p in type(self).__dict__ if not p.startswith("_")]
        l = len(self._path)
        subs = [p[l] for p in self._parent()._children if len(p) > l and p[:l] == self._path]
        return sorted(d + list(set(subs)))



from .Reactor import Reactor
from .Transformer import Transformer
from .Cell import Cell
from .Link import Link
from .Macro import Macro
from .pin import InputPin, OutputPin
from .library.libmacro import LibMacro
from .PollingObserver import PollingObserver

nodeclasses = {
    "cell": Cell,
    "transformer": Transformer,
    "reactor": Reactor,
    "context": SubContext,
    "macro": Macro,
}