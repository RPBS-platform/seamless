import traceback
from copy import deepcopy
from collections import namedtuple
import weakref
import itertools
import threading, time
import asyncio, concurrent
import inspect
import functools
from functools import partial
from zipfile import ZipFile
from io import BytesIO
import json

from .Base import Base
from ..core import macro_mode
from ..core.macro_mode import macro_mode_on, get_macro_mode
from ..core.context import context, Context as CoreContext
from ..core.cell import cell
from ..core.mount import mountmanager #for now, just a single global mountmanager
from .assign import assign
from .proxy import Proxy
from ..midlevel import copying

Graph = namedtuple("Graph", ("nodes", "connections", "params", "lib"))

shareserver = None

def run_in_mainthread(func):
    def func2(*args, **kwargs):
        ctx = args[0]
        manager = ctx._manager
        if threading.current_thread() != threading.main_thread():
            manager.taskmanager.add_synctask(func, args, kwargs, with_event=False)
        else:
            func(*args, **kwargs)    
    functools.update_wrapper(func2, func)
    return func2

Graph = namedtuple("Graph", ("nodes", "connections", "params", "lib"))

shareserver = None


def get_status(parent, children, nodes, path):
    from ..core.context import StatusReport
    result = StatusReport()
    if path is not None:
        lp = len(path)
    all_children = itertools.chain(children.items(), nodes.items())
    for childname0, child in all_children:    
        if path is not None:            
            if childname0[:lp] != path:
                continue
            childname0 = childname0[lp:]
        if len(childname0) != 1:
            continue
        childname = childname0[0]
        if isinstance(child, dict):  # node
            if child["type"] != "context":
                continue
            subpath = (childname,)
            if path is not None:
                subpath = path + subpath
            child = SubContext(parent, subpath)
        s = child.status
        if s != "Status: OK":
            result[childname] = s
    if len(result):
        return result
    else:
        return "Status: OK"

class Context(Base):
    _default_parameters = {
        "share_namespace": "ctx"
    }
    _mount = None
    _translating = False
    _translate_count = 0 
    _auto_translate = True 
    _gen_context = None
    _libmacro_graph = None
    _weak = False  # True for autogenerated contexts that have no strong reference
    _cached_graph = None
    _live_share_namespace = None
    _destroyed = False

    @classmethod
    def from_graph(cls, graph, manager, *, mounts=True, shares=True):
        self = cls(manager=manager)
        self.set_graph(graph,mounts=mounts,shares=shares)
        graph = deepcopy(graph)
        return self

    def set_graph(self, graph, *, mounts=True, shares=True):
        graph = deepcopy(graph)        
        nodes = {}        
        for node in graph["nodes"]:
            p = tuple(node["path"])
            if not mounts:
                node.pop("mount", None)
            if not shares:
                node.pop("share", None)
            node["path"] = p
            nodes[p] = node
            nodetype = node["type"]
            nodecls = nodeclasses[nodetype]
            child = nodecls(parent=self,path=p)
        connections = graph["connections"]
        for con in connections:
            if con["type"] == "connection":
                con["source"] = tuple(con["source"])
                con["target"] = tuple(con["target"])
            elif con["type"] == "link":
                con["first"] = tuple(con["first"])
                con["second"] = tuple(con["second"])
        params = deepcopy(self._default_parameters)
        params.update(graph["params"])
        self._graph = Graph(nodes, connections, params, graph.get("lib", {}))
        self._translate()
        return self

    def __init__(self, dummy=False, manager=None):
        super().__init__(None, ())
        from seamless.core.manager import Manager
        self._dummy = dummy
        if manager is not None:            
            assert isinstance(manager, Manager), type(manager)
            self._manager = manager
        else:
            self._manager = Manager()
        self._graph = Graph({},[],{},{})
        self._graph.params.update(deepcopy(self._default_parameters))
        self._children = {}
        self._needs_translation = True
        self._parent = weakref.ref(self)
        self._traitlets = {}
        self._observers = set()
        
        async def auto_trans():
            while not self._destroyed:
                if self.auto_translate:                    
                    await self.translation()
                await asyncio.sleep(1)
        self._auto_translate_coro = asyncio.ensure_future(auto_trans())

    def _get_node(self, path):
        try:
            return self._graph[0][path]
        except KeyError:
            try:
                return self._libmacro_graph.nodes[path]
            except (KeyError, AttributeError):
                raise KeyError(path) from None

    def _get_path(self, path):
        child = self._children.get(path)
        if child is not None:
            return child
        node = self._graph[0].get(path)
        if node is not None:
            if node["type"] == "libmacro":
                return LibMacro(self, path=path)
            assert node["type"] == "context", (path, node["type"]) #if not context, should be in children!
            return SubContext(self, path)
        return Proxy(self, path, "w")

    def _get_subcontext(self, path):
        child = self._children[path]

    def __getattr__(self, attr):
        if attr.startswith("_"):
            raise AttributeError(attr)
        if attr in type(self).__dict__:
            raise AttributeError(attr)
        path = (attr,)
        return self._get_path(path)

    def __setattr__(self, attr, value):
        if attr.startswith("_"):
            return object.__setattr__(self, attr, value)
        members = {k:v for k,v in inspect.getmembers(type(self))}
        if attr in members and isinstance(members[attr], property):
            return object.__setattr__(self, attr, value)
        attr2 = (attr,)
        if isinstance(value, Reactor):
            value._init(self, (attr,) )
            self._translate()
        elif isinstance(value, Transformer):
            if value._parent is None:
                self._graph[0][attr2] = value
                self._children[attr2] = value
                value._init(self, attr2 )
                self._translate()
            else:
                assign(self, attr2, value)
            """
        elif attr2 in self._children:
            child = self._children[attr2]
            if isinstance(child, Cell):
                child.set(value)
            """
        else:
            assign(self, attr2, value)

    def __delattr__(self, attr):
        self._destroy_path((attr,))

    def _add_traitlet(self, path, trigger):
        from .SeamlessTraitlet import SeamlessTraitlet
        traitlet = self._traitlets.get(path)
        if traitlet is not None:
            return traitlet
        traitlet = SeamlessTraitlet(value=None)
        traitlet.parent = weakref.ref(self)
        traitlet.path = path
        if trigger:
            traitlet._connect_seamless()
        self._traitlets[path] = traitlet
        self._translate()
        return traitlet

    def mount(self, path=None, mode="rw", authority="cell", persistent=None):
        assert not self._dummy
        if self._parent() is not self:
            raise NotImplementedError
        if path is None:
            self._mount = None
            return
        self._mount = {
            "path": path,
            "mode": mode,
            "authority": authority,
            "persistent": persistent
        }
        self._translate()
    
    def compute(self, timeout=None, report=2):     
        if self._dummy:
            return
        self.translate()
        return self._gen_context.compute(timeout, report)

    async def computation(self, timeout=None, report=2):     
        if self._dummy:
            return
        await self.translation()
        await self._gen_context.computation(timeout, report)

    def self(self):
        raise NotImplementedError

    def _translate(self):
        self._needs_translation = True
        self._cached_graph = None

    def translate(self, force=False):
        from seamless import running_in_jupyter
        if running_in_jupyter:
            raise RuntimeError("'ctx.translate()' cannot be called from within Jupyter. Use 'await ctx.translation()' instead")
        elif asyncio.get_event_loop().is_running():
            raise RuntimeError("'ctx.translate()' cannot be called from within a coroutine. Use 'await ctx.translation()' instead")
        return self._do_translate(force=force, explicit=True)

    async def translation(self, force=False):
        return await self._do_translate_async(force=force, explicit=True)

    @property 
    def auto_translate(self):
        return self._auto_translate

    @auto_translate.setter
    def auto_translate(self, value):
        if not isinstance(value, bool):
            raise TypeError(type(value))
        self._auto_translate = value

    @property
    def share_namespace(self):
        return self._graph.params["share_namespace"]

    @share_namespace.setter
    def share_namespace(self, value):
        if not isinstance(value, str):
            raise TypeError(value)
        self._graph.params["share_namespace"] = value
        self._live_share_namespace = None
    
    @property
    def live_share_namespace(self):
        return self._live_share_namespace

    def _get_graph(self, copy):
        from ..core.manager.tasks.structured_cell import StructuredCellJoinTask
        from ..core.manager.tasks import SetCellValueTask, SetCellBufferTask
        join_task_types = (
            SetCellValueTask, SetCellBufferTask, StructuredCellJoinTask
        )

        if self._gen_context is not None and not asyncio.get_event_loop().is_running():
            taskmanager = self._gen_context._get_manager().taskmanager
            def get_join_tasks(taskmanager):
                tasks = []
                for task in taskmanager.tasks:
                    if isinstance(task, join_task_types):
                        tasks.append(task)
                return tasks
            remaining, _ = taskmanager.compute(
                timeout=10, report=2, 
                get_tasks_func=get_join_tasks
            )
            assert not len(remaining), remaining
        try:
            self._translating = True
            manager = self._manager
            copying.fill_checksums(manager, self._graph.nodes)            
        finally:
            self._translating = False
        nodes, connections, params, lib = self._graph
        nodes = [v for k,v in sorted(nodes.items(), key=lambda kv: kv[0])]
        if copy:
            connections = deepcopy(connections)
            nodes = deepcopy(nodes)
            params = deepcopy(params)
            lib = deepcopy(lib)
        graph = {
            "nodes": nodes, 
            "connections": connections, 
            "params": params,
            "lib": lib,
        }
        self._cached_graph = graph
        return graph

    async def _get_graph_async(self, copy):
        from ..core.manager.tasks.structured_cell import StructuredCellJoinTask
        from ..core.manager.tasks import SetCellValueTask, SetCellBufferTask
        join_task_types = (
            SetCellValueTask, SetCellBufferTask, StructuredCellJoinTask
        )

        if self._gen_context is not None:
            taskmanager = self._gen_context._get_manager().taskmanager
            def get_join_tasks(taskmanager):
                tasks = []
                for task in taskmanager.tasks:
                    if isinstance(task, join_task_types):
                        tasks.append(task)
                return tasks
            remaining, _ = await taskmanager.computation(
                timeout=10, report=2, 
                get_tasks_func=get_join_tasks
            )
            assert not len(remaining), remaining
        try:
            self._translating = True
            manager = self._manager
            copying.fill_checksums(manager, self._graph.nodes)            
        finally:
            self._translating = False
        nodes, connections, params, lib = self._graph
        nodes = [v for k,v in sorted(nodes.items(), key=lambda kv: kv[0])]
        if copy:
            connections = deepcopy(connections)
            nodes = deepcopy(nodes)
            params = deepcopy(params)
            lib = deepcopy(lib)
        graph = {
            "nodes": nodes, 
            "connections": connections, 
            "params": params,
            "lib": lib,
        }
        self._cached_graph = graph
        return graph

    def get_graph(self, cache=True):
        if cache:
            if self._cached_graph is None:
                self._get_graph(copy=True)
            return self._cached_graph
        else:        
            return self._get_graph(copy=True)

    def save_graph(self, filename):
        graph = self.get_graph()
        with open(filename, "w") as f:
            json.dump(graph, f, sort_keys=True, indent=2)

    def get_zip(self):
        # TODO: option to follow deep cell checksums
        force = (self._gen_context is None)
        self._do_translate(force=force)
        graph = self.get_graph()
        nodes0 = graph["nodes"]
        nodes = {tuple(node["path"]):node for node in nodes0 if "scratch" not in node}
        checksums = copying.get_checksums(nodes)
        manager = self._manager
        buffer_dict = copying.get_buffer_dict_sync(manager, checksums)
        archive = BytesIO()
        with ZipFile(archive, mode="w") as zipfile:
            for checksum, buffer in buffer_dict.items():
                zipfile.writestr(checksum, buffer)
        result = archive.getvalue()
        archive.close()
        return result

    async def get_zip_async(self):
        # TODO: option to follow deep cell checksums
        force = (self._gen_context is None)
        self._do_translate(force=force)
        graph = self.get_graph()
        nodes0 = graph["nodes"]
        nodes = {tuple(node["path"]):node for node in nodes0}
        checksums = copying.get_checksums(nodes)
        manager = self._manager
        buffer_dict = await copying.get_buffer_dict(manager, checksums)
        archive = BytesIO()
        with ZipFile(archive, mode="w") as zipfile:
            for checksum, buffer in buffer_dict.items():
                zipfile.writestr(checksum, buffer)
        result = archive.getvalue()
        archive.close()
        return result

    def save_zip(self, filename):
        zip = self.get_zip()
        with open(filename, "wb") as f:
            f.write(zip)

    async def save_zip_async(self, filename):
        zip = self.get_zip_async()
        with open(filename, "wb") as f:
            f.write(zip)

    def add_zip(self, zip):
        if self._gen_context is None:
            self._do_translate(force=True)
        manager = self._manager
        if isinstance(zip, bytes):
            archive = BytesIO(zip)
            zipfile = ZipFile(archive, "r")
        elif isinstance(zip, str):
            zipfile = ZipFile(zip, "r")
        elif isinstance(zip, ZipFile):
            zipfile = zip
        else:
            raise TypeError(type(zip))        
        return copying.add_zip(manager, zipfile)

    def include(self, lib, only_zip=False, full_path=False):
        from .library import Library
        if not isinstance(lib, Library):
            raise TypeError(type(lib))
        if only_zip:
            lib.include_zip(self)
        else:
            lib.include(self, full_path=full_path)
            self._translate()

    @run_in_mainthread
    def _do_translate(self, force=False, explicit=False):        
        if self._dummy:
            return
        graph0 = self._get_graph(copy=False)
        return self._do_translate2(graph0, force=force, explicit=explicit)

    async def _do_translate_async(self, force=False, explicit=False):
        assert threading.current_thread() == threading.main_thread()
        if self._dummy:
            return
        graph0 = await self._get_graph_async(copy=False)
        return self._do_translate2(graph0, force=force, explicit=explicit)


    def _do_translate2(self, graph0, force, explicit):
        from ..midlevel.translate import translate, import_before_translate
        from ..midlevel.pretranslate import pretranslate
        #from pprint import pprint; pprint(graph0)
        if not force and not self._needs_translation:
            return
        """
        if self._translating:
            raise Exception("Nested invocation of ctx.translate")
        """
        if self._translating:
            return
        graph = pretranslate(self, graph0)
        if graph is not graph0:
            libmacro_nodes = {node["path"]: node for node in graph["nodes"]}
            self._libmacro_graph = Graph(
                libmacro_nodes,
                graph["connections"],
                graph["params"],
                graph["lib"]
            )
        self._translate_count += 1
        try:            
            self._translating = True
            ctx = None
            if self._gen_context is not None:
                self._gen_context.destroy()            
            import_before_translate(graph)
            with macro_mode_on():
                ub_ctx = context(
                    toplevel=True,
                    manager=self._manager
                )
                if self._mount is not None:
                    ub_ctx._mount = self._mount.copy()
                self._unbound_context = ub_ctx                
                translate(graph, ub_ctx)
            self._gen_context = ub_ctx._bound
            assert self._gen_context._get_manager() is self._manager
            self._connect_share()
        finally:
            self._translating = False
            self._unbound_context = None
            needs_translation = False
            for node in graph0["nodes"]:
                if isinstance(node, dict) and node.get("UNTRANSLATED"):
                    needs_translation = True
                    break
            self._needs_translation = needs_translation
        
        try:
            self._translating = True
            for traitlet in self._traitlets.values():
                traitlet._connect_seamless()        

            for path, child in self._children.items():
                if isinstance(child, (Cell, Transformer, Reactor, Macro)):
                    try:
                        child._set_observers()
                    except Exception:
                        pass
                elif isinstance(child, (InputPin, OutputPin, Link)):
                    continue
                else:
                    raise TypeError(type(child))
        finally:
            self._translating = False
    
    def _get_shares(self):
        shares = {}
        for path, node in self._graph.nodes.items():
            if node["type"] != "cell":
                continue
            share = node.get("share")
            if share is not None:
                shares[path] = share
        if not len(shares):
            return None
        return shares

    def _connect_share(self):
        shares = self._get_shares()
        if shares is None:
            return
        from ..core import StructuredCell, Cell as core_cell
        global shareserver
        from .. import shareserver
        from ..core.share import sharemanager
        shareserver.start()
        if self._live_share_namespace is None:
            self._live_share_namespace = sharemanager.new_namespace(
                self._manager,
                name=self.share_namespace, 
                share_evaluate=False
            )        
        for path, shareparams in shares.items():
            key = "/".join(path) #TODO: split in subpaths by inspecting and traversing ctx._children (recursively for subcontext children)
            hcell = self._children[path]
            if not isinstance(hcell, Cell):
                raise NotImplementedError(type(hcell))
            cell = hcell._get_cell()
            if isinstance(cell, StructuredCell):
                pass #TODO: see above
            elif isinstance(cell, core_cell):
                pass #TODO: see above
            else:
                raise TypeError(cell)
            sharepath = shareparams["path"]
            readonly = shareparams["readonly"]
            mimetype = hcell.mimetype            
            cell.share(sharepath, readonly, mimetype=mimetype)

    def _destroy_path(self, path):
        nodes = self._graph.nodes
        for p in list(nodes.keys()):
            if p[:len(path)] == path:
                node = nodes[p]
                child = self._children.get(p)
                nodes.pop(p)
                self._children.pop(p, None)
                self._traitlets.pop(p, None)
                self._translate()

        nodes = self._graph.nodes
        l = len(nodes)
        newnodes = {k:v for k,v in nodes.items() \
                    if k[:len(path)] != path }
        if len(newnodes) < l:
            nodes.clear()
            nodes.update(newnodes)
            self._translate()

        connections = self._graph.connections
        removed = self._remove_connections(path)
        if removed:
            self._translate()

    @property
    def status(self):
        """The computation status of the context
        Returns a dictionary containing the status of all children that are not OK.
        If all children are OK, returns "Status: OK"
        """
        assert not self._dummy
        nodes, _, _, _ = self._graph
        return get_status(self, self._children, nodes, path=None)

    @property
    def lib(self):
        from .library.include import IncludedLibraryContainer
        return IncludedLibraryContainer(self, ())

    def resolve(self, checksum):
        return self._manager.resolve(checksum)

    def observe(self, path, callback, polling_interval, observe_none=False):
        observer = PollingObserver(
            self, path, callback, polling_interval, observe_none
        )
        self._observers.add(observer)
        return observer

    def _get_libs(self, path):
        lib = self._graph.lib
        lp = len(path)
        result = {k[lp:]:v for k,v in lib.items() \
                  if len(k) > lp and k[:lp] == path \
                }
        return result

    def _get_lib(self, path):
        return self._graph.lib[tuple(path)]

    def _remove_connections(self, path, keep_links=False):
        # Removes all connections starting with path
        lp = len(path)
        def keep_con(con):
            if con["type"] == "link":
                if keep_links:
                    return True
                first = con["first"]
                if first[:lp] == path:
                    return False
                second = con["second"]
                if second[:lp] == path:
                    return False
                return True
            else:
                ctarget = con["target"]
                return ctarget[:lp] != path
        connections = self._graph[1]
        new_connections = list(filter(keep_con, connections))
        any_removed = (len(new_connections) < len(connections))            
        connections[:] = new_connections
        return any_removed

    def link(self, first, second):
        link = Link(self, first=first, second=second)
        connections = self._graph.connections
        connections.append(link._node)
        self._translate()

    def get_links(self):
        connections = self._graph.connections
        result = []
        for node in connections:
            if node["type"] == "link":
                result.append(Link(self, node=node))
        return result

    def children(self, type=None):
        assert type is None or type == "context" or type in nodeclasses, (type, nodeclasses.keys())
        children00 = self._children.items()
        children0 = children00
        if type is not None and type != "context":
            klass = nodeclasses[type]
            children0 = [(p,c) for p,c in children00 if isinstance(c, klass)]
        children = [p[0] for p,c in children0]
        if type == "context":
            children = [p for p in children if (p,) not in children00]
        return sorted(list(set(children)))

    def __dir__(self):
        d = [p for p in type(self).__dict__ if not p.startswith("_")]
        subs = [p[0] for p in self._children]
        return sorted(d + list(set(subs)))

    def __del__(self):
        self._destroyed = True


class SubContext(Base):
    _cached_graph = None
    def __init__(self, parent, path):
        super().__init__(parent, path)

    def __getattr__(self, attr):
        if attr.startswith("_"):
            raise AttributeError(attr)
        if attr in type(self).__dict__:
            raise AttributeError(attr)
        parent = self._get_top_parent()
        path = self._path + (attr,)
        return parent._get_path(path)

    def __setattr__(self, attr, value):
        if attr.startswith("_"):
            return object.__setattr__(self, attr, value)
        parent = self._get_top_parent()
        path = self._path + (attr,)
        if isinstance(value, Reactor):            
            value._init(parent, path)
            parent._translate()
        elif isinstance(value, Transformer):
            if value._parent is None:
                parent._graph[0][path] = value
                parent._children[path] = value
                value._init(parent, path )
                parent._translate()
            else:
                assign(parent, path, value)
        else:
            assign(parent, path, value)

    def __delattr__(self, attr):
        raise NotImplementedError

    def mount(self, mountdir):
        raise NotImplementedError

    def _get_graph(self, copy):
        parent = self._parent()
        nodes, connections, params, _ = parent._graph
        path = self._path
        lp = len(path)
        newnodes = []        
        for nodepath, node in sorted(nodes.items(), key=lambda kv: kv[0]):
            if len(nodepath) > lp and nodepath[:lp] == path:
                newnode = deepcopy(node)
                newnode["path"] = nodepath[lp:]
                newnodes.append(newnode)
        new_connections = []
        for connection in connections:
            if connection["type"] == "connection":
                source, target = connection["source"], connection["target"]
                if source[:lp] == path and target[:lp] == path:
                    con = deepcopy(connection)
                    con["source"] = source[lp:]
                    con["target"] = target[lp:]
                    new_connections.append(con)
            elif connection["type"] == "link":
                first, second = connection["first"], connection["second"]
                if first[:lp] == path and second[:lp] == path:
                    con = deepcopy(connection)
                    con["first"] = first[lp:]
                    con["second"] = second[lp:]
                    new_connections.append(con)
        if copy:
            params = deepcopy(params)
        graph = {
            "nodes": newnodes, 
            "connections": new_connections, 
            "params": params
        }
        return graph

    def get_graph(self, cache=True):
        if cache:
            if self._cached_graph is None:
                self._cached_graph = self._get_graph(copy=True)
            return self._cached_graph
        else:        
            return self._get_graph(copy=True)

    @property
    def status(self):
        parent = self._parent()
        nodes, _, _, _ = parent._graph
        return get_status(parent, parent._children, nodes, self._path)

    def _translate(self):
        self._parent()._translate()

    def children(self, type=None):
        assert type is None or type == "context" or type in nodeclasses, (type, nodeclasses.keys())
        l = len(self._path)
        children00 = [(p[l:],c) for p,c in self._parent()._children.items() if len(p) > l and p[:l] == self._path]
        children0 = children00
        if type is not None and type != "context":
            klass = nodeclasses[type]
            children0 = [(p,c) for p,c in children00 if isinstance(c, klass)]
        children = [p[0] for p,c in children0]
        if type == "context":
            children = [p for p in children if (p,) not in children00]
        return sorted(list(set(children)))

    def __dir__(self):
        d = [p for p in type(self).__dict__ if not p.startswith("_")]
        l = len(self._path)
        subs = [p[l] for p in self._parent()._children if len(p) > l and p[:l] == self._path]
        return sorted(d + list(set(subs)))



from .Reactor import Reactor
from .Transformer import Transformer
from .Cell import Cell
from .Link import Link
from .Macro import Macro
from .pin import InputPin, OutputPin
from .library.libmacro import LibMacro
from .PollingObserver import PollingObserver

nodeclasses = {
    "cell": Cell,
    "transformer": Transformer,
    "reactor": Reactor,
    "context": SubContext,
    "macro": Macro,
}