import traceback
from copy import deepcopy
from collections import namedtuple
import weakref
import itertools
import threading, time
import asyncio, concurrent
import inspect
import functools
from functools import partial
from zipfile import ZipFile
from io import BytesIO
import json

import logging
logger = logging.getLogger("seamless")

def print_info(*args):
    msg = " ".join([str(arg) for arg in args])
    logger.info(msg)

def print_warning(*args):
    msg = " ".join([str(arg) for arg in args])
    logger.warning(msg)

def print_debug(*args):
    msg = " ".join([str(arg) for arg in args])
    logger.debug(msg)

def print_error(*args):
    msg = " ".join([str(arg) for arg in args])
    logger.error(msg)


from .Base import Base
from ..core import macro_mode
from ..core.macro_mode import macro_mode_on, get_macro_mode, until_macro_mode_off
from ..core.context import context
from ..core.cell import cell
from ..core.mount import mountmanager #for now, just a single global mountmanager
from .assign import assign
from .proxy import Proxy
from ..midlevel import copying

Graph = namedtuple("Graph", ("nodes", "connections", "params", "lib"))

def run_in_mainthread(func):
    def func2(*args, **kwargs):
        ctx = args[0]
        manager = ctx._manager
        if threading.current_thread() != threading.main_thread():
            manager.taskmanager.add_synctask(func, args, kwargs, with_event=False)
        else:
            func(*args, **kwargs)
    functools.update_wrapper(func2, func)
    return func2

Graph = namedtuple("Graph", ("nodes", "connections", "params", "lib"))

shareserver = None


def get_status(parent, children, nodes, path):
    from ..core.context import StatusReport
    result = StatusReport()
    if path is not None:
        lp = len(path)
    all_children = itertools.chain(children.items(), nodes.items())
    for childname0, child in all_children:
        if path is not None:
            if childname0[:lp] != path:
                continue
            childname0 = childname0[lp:]
        if len(childname0) != 1:
            continue
        childname = childname0[0]
        if isinstance(child, dict):  # node
            if child["type"] != "context":
                continue
            subpath = (childname,)
            if path is not None:
                subpath = path + subpath
            child = SubContext(parent, subpath)
        s = child.status
        if s != "Status: OK":
            result[childname] = s
    if len(result):
        return result
    else:
        return "Status: OK"

import weakref
_contexts = weakref.WeakSet()
def _destroy_contexts():
    for context in _contexts:
        try:
            context._destroy()
        except:
            pass
import atexit
atexit.register(_destroy_contexts)


class Context(Base):
    """Context class. Organizes cells and workers hierarchically.

    See http://sjdv1982.github.io/seamless/sphinx/html/context.html for documentation
    """
    _default_parameters = {
        "share_namespace": "ctx"
    }
    _mount = None
    _translating = False
    _translate_count = 0
    _gen_context = None
    _runtime_graph = None  # the graph as synthesized by pre-translating all LibInstances, overlaying onto the main graph
    _weak = False  # True for autogenerated contexts that have no strong reference
    _live_share_namespace = None
    _destroyed = False

    @classmethod
    def from_graph(cls, graph, manager, *, mounts=True, shares=True, share_namespace=None, zip=None):
        """Constructs a Context from a graph

        "graph" can be a file name or a JSON dict
        Normally, it has been generated with Context.save_graph / Context.get_graph

        "zip" can be a file name, zip-compressed bytes or a Python ZipFile object.
        Normally, it has been generated with Context.save_zip / Context.get_zip

        "manager": re-use the manager of a previous context.
        The manager controls caching and execution.

        "mounts": mount cells and pins to the file system, as specified in the graph.

        "shares": share cells over HTTP, as specified in the graph

        "share_namespace": The namespace to use for HTTP sharing ("ctx"by default)

        """
        self = cls(manager=manager)
        if zip is not None:
            self.add_zip(zip)
        if share_namespace is not None:
            self.share_namespace = share_namespace
        self.set_graph(graph,mounts=mounts,shares=shares)
        graph = deepcopy(graph)
        return self

    def set_graph(self, graph, *, mounts=True, shares=True):
        """Sets the graph of the Context

        "graph" can be a file name or a JSON dict
        Normally, it has been generated with Context.save_graph / Context.get_graph

        "mounts": mount cells and pins to the file system, as specified in the graph.

        "shares": share cells over HTTP, as specified in the graph

        """
        graph = deepcopy(graph)
        nodes = {}
        for node in graph["nodes"]:
            p = tuple(node["path"])
            if not mounts:
                node.pop("mount", None)
            if not shares:
                node.pop("share", None)
            node["path"] = p
            nodes[p] = node
            nodetype = node["type"]
            if nodetype == "libinstance":
                continue
            nodecls = nodeclasses[nodetype]
            child = nodecls(parent=self,path=p)
        connections = graph["connections"]
        for con in connections:
            if con["type"] == "connection":
                con["source"] = tuple(con["source"])
                con["target"] = tuple(con["target"])
            elif con["type"] == "link":
                con["first"] = tuple(con["first"])
                con["second"] = tuple(con["second"])
        params = deepcopy(self._default_parameters)
        params.update(graph["params"])
        lib0 = graph.get("lib", [])
        lib = {}
        for l in lib0:
            path = tuple(l["path"])
            l["path"] = path
            lib[path] = l
        self._graph = Graph(nodes, connections, params, lib)
        self._translate()
        return self

    def __init__(self, manager=None):
        """Creates a new Seamless context

        "manager": re-use the manager of a previous context.
        The manager controls caching and execution.
        """
        super().__init__(None, ())
        from seamless.core.manager import Manager
        if manager is not None:
            assert isinstance(manager, Manager), type(manager)
            self._manager = manager
        else:
            self._manager = Manager()
        self._graph = Graph({},[],{},{})
        self._graph.params.update(deepcopy(self._default_parameters))
        self._children = {}
        self._needs_translation = True
        self._parent = weakref.ref(self)
        self._traitlets = {}
        self._observers = set()
        _contexts.add(self)

    def _get_node(self, path):
        try:
            return self._graph[0][path]
        except KeyError:
            try:
                return self._runtime_graph.nodes[path]
            except (KeyError, AttributeError):
                raise KeyError(path) from None

    def _get_path(self, path):
        child = self._children.get(path)
        if child is not None:
            return child
        node = self._graph[0].get(path)
        if node is not None:
            if node["type"] == "libinstance":
                return LibInstance(self, path=path)
            assert node["type"] == "context", (path, node["type"]) #if not context, should be in children!
            return SubContext(self, path)
        return Proxy(self, path, "w")

    def _get_subcontext(self, path):
        child = self._children[path]

    def __getitem__(self, attr):
        if not isinstance(attr, str):
            raise KeyError(attr)
        return getattr(self, attr)

    def __setitem__(self, attr, value):
        if not isinstance(attr, str):
            raise KeyError(attr)
        setattr(self, attr, value)

    def __getattribute__(self, attr):
        if attr.startswith("_"):
            return super().__getattribute__(attr)
        if attr in type(self).__dict__ or attr in self.__dict__:
            return super().__getattribute__(attr)
        path = (attr,)
        return self._get_path(path)

    def __setattr__(self, attr, value):
        if attr.startswith("_"):
            return object.__setattr__(self, attr, value)
        members = {k:v for k,v in inspect.getmembers(type(self))}
        if attr in members and isinstance(members[attr], property):
            return object.__setattr__(self, attr, value)
        attr2 = (attr,)
        if isinstance(value, Reactor):
            value._init(self, (attr,) )
            self._translate()
        elif isinstance(value, (Transformer, Macro)):
            if value._parent is None:
                self._graph[0][attr2] = value
                self._children[attr2] = value
                value._init(self, attr2 )
                self._translate()
            else:
                assign(self, attr2, value)
            """
        elif attr2 in self._children:
            child = self._children[attr2]
            if isinstance(child, Cell):
                child.set(value)
            """
        else:
            assign(self, attr2, value)

    def __delattr__(self, attr):
        self._destroy_path((attr,))

    def _add_traitlet(self, path, trigger):
        from .SeamlessTraitlet import SeamlessTraitlet
        traitlet = self._traitlets.get(path)
        if traitlet is not None:
            return traitlet
        traitlet = SeamlessTraitlet(value=None)
        traitlet.parent = weakref.ref(self)
        traitlet.path = path
        if trigger:
            traitlet._connect_seamless()
        self._traitlets[path] = traitlet
        self._translate()
        return traitlet

    def mount(self, path=None, mode="rw", authority="cell", persistent=None):
        raise NotImplementedError  # for now, not implemented; TODO: see issue 10

        if self._parent() is not self:
            raise NotImplementedError
        if path is None:
            self._mount = None
            return
        self._mount = {
            "path": path,
            "mode": mode,
            "authority": authority,
            "persistent": persistent
        }
        self._translate()

    def compute(self, timeout=None, report=2):
        """Block until no more computation is required.

        This means that all cells and transformers have either been computed,
        or they have an error, or they have unsatisfied upstream dependencies.

        The graph is first (re-)translated, if necessary.

        This function can only be invoked if no event loop is running,
        i.e. under python or ipython, but not in a Jupyter kernel.
        """
        from seamless import verify_sync_compute
        verify_sync_compute()
        self.translate()
        return self._gen_context.compute(timeout, report)

    async def computation(self, timeout=None, report=2):
        """Block until no more computation is required.

        This means that all cells and transformers have either been computed,
        or they have an error, or they have unsatisfied upstream dependencies.

        The graph is first (re-)translated, if necessary.
        """
        await self.translation()
        await self._gen_context.computation(timeout, report)

    def self(self):
        raise NotImplementedError

    def _translate(self):
        self._needs_translation = True

    def translate(self, force=False):
        """(Re-)translate the graph.
        The graph is translated to a low-level, computable form
        (seamless.core). After translation, return immediately,
        although computation will start automatically.

        If force=True, translation will happen even though no
        change in topology or celltype was detected.

        This function can only be invoked if no event loop is running,
        i.e. under python or ipython, but not in a Jupyter kernel.
        """
        from seamless import verify_sync_translate
        verify_sync_translate()
        self._wait_for_auth_tasks("the graph is re-translated")
        return self._do_translate(force=force, explicit=True)

    async def translation(self, force=False):
        """(Re-)translate the graph.
        The graph is translated to a low-level, computable form
        (seamless.core). After translation, return immediately,
        although computation will start automatically.

        If force=True, translation will happen even though no
        change in topology or celltype was detected.
        """
        await self._wait_for_auth_tasks_async("the graph is re-translated")
        return await self._do_translate_async(force=force, explicit=True)

    @property
    def share_namespace(self):
        """The preferred namespace for sharing cells by the HTTP server

        Cells are shared under:
         http://<shareserver URL>/<live_share_namespace>/<cell path>

        The live share namespace is in principle equal to the share namespace,
        but if it is already taken, a number will be added to it (ctx1, ctx2, etc.)

        Default: "ctx"
        """
        return self._graph.params["share_namespace"]

    @share_namespace.setter
    def share_namespace(self, value):
        if not isinstance(value, str):
            raise TypeError(value)
        self._graph.params["share_namespace"] = value
        self._live_share_namespace = None

    @property
    def live_share_namespace(self):
        """The actual namespace for sharing cells by the HTTP server

        Cells are shared under:
         http://<shareserver URL>/<live_share_namespace>/<cell path>

        The live share namespace is in principle equal to the share namespace,
        but if it is already taken, a number will be added to it (ctx1, ctx2, etc.)

        Default: "ctx"
        """
        return self._live_share_namespace

    def _get_graph(self, copy):
        from ..core.manager.tasks.structured_cell import StructuredCellAuthTask
        from ..core.manager.tasks import SetCellValueTask, SetCellBufferTask
        auth_task_types = (
            SetCellValueTask, SetCellBufferTask, StructuredCellAuthTask
        )

        try:
            self._translating = True
            manager = self._manager
            copying.fill_checksums(manager, self._graph.nodes)
        finally:
            self._translating = False
        nodes, connections, params, lib = self._graph
        nodes = [v for k,v in sorted(nodes.items(), key=lambda kv: kv[0])]
        lib = [v for k,v in sorted(lib.items(), key=lambda kv: kv[0])]
        if copy:
            connections = deepcopy(connections)
            nodes = deepcopy(nodes)
            params = deepcopy(params)
            lib = deepcopy(lib)
        graph = {
            "nodes": nodes,
            "connections": connections,
            "params": params,
            "lib": lib,
        }
        return graph

    async def _get_graph_async(self, copy):
        await self._wait_for_auth_tasks_async("the graph is being obtained")
        try:
            self._translating = True
            manager = self._manager
            copying.fill_checksums(manager, self._graph.nodes)
        finally:
            self._translating = False
        nodes, connections, params, lib = self._graph
        nodes = [v for k,v in sorted(nodes.items(), key=lambda kv: kv[0])]
        lib = [v for k,v in sorted(lib.items(), key=lambda kv: kv[0])]
        if copy:
            connections = deepcopy(connections)
            nodes = deepcopy(nodes)
            params = deepcopy(params)
            lib = deepcopy(lib)
        graph = {
            "nodes": nodes,
            "connections": connections,
            "params": params,
            "lib": lib,
        }
        return graph

    def get_graph(self, runtime=False):
        """Returns the graph in JSON format

        "runtime": The graph is returned after
        Library/LibInstance/Macro transformations of the graph.
        """
        if not runtime:
            return self._get_graph(copy=True)

        self._get_graph(copy=True)
        graph0 = deepcopy(self._runtime_graph)

        connections = deepcopy(graph0.connections)
        nodes = deepcopy(graph0.nodes)
        params = deepcopy(graph0.params)
        lib = deepcopy(graph0.lib)
        graph = {
            "nodes": [node for node in nodes.values()],
            "connections": connections,
            "params": params,
            "lib": lib,
        }
        return graph

        nodes = []
        for node in graph["nodes"]:
            node["path"] = tuple(node["path"])
            nodes.append(node)
        for con in graph["connections"]:
            if con["type"] == "connection":
                con["source"] = tuple(con["source"])
                con["target"] = tuple(con["target"])
            elif con["type"] == "link":
                con["first"] = tuple(con["first"])
                con["second"] = tuple(con["second"])
        return graph

    def save_graph(self, filename):
        """Saves the graph in JSON format"""
        graph = self.get_graph()
        with open(filename, "w") as f:
            json.dump(graph, f, sort_keys=True, indent=2)

    def get_zip(self):
        """Obtain the checksum-to-buffer cache for the current graph

        The cache is returned as zipped bytes
        """
        # TODO: option to follow deep cell checksums
        force = (self._gen_context is None)
        self._wait_for_auth_tasks("the graph buffers are obtained for zip")
        self._do_translate(force=force)
        graph = self.get_graph()
        nodes0 = graph["nodes"]
        nodes = [node for node in nodes0 if "scratch" not in node]
        checksums = copying.get_checksums(nodes)
        manager = self._manager
        buffer_dict = copying.get_buffer_dict_sync(manager, checksums)
        archive = BytesIO()
        with ZipFile(archive, mode="w") as zipfile:
            for checksum, buffer in buffer_dict.items():
                zipfile.writestr(checksum, buffer)
        result = archive.getvalue()
        archive.close()
        return result

    async def get_zip_async(self):
        """Obtain the checksum-to-buffer cache for the current graph

        The cache is returned as zipped bytes
        """
        # TODO: option to follow deep cell checksums
        force = (self._gen_context is None)
        await self._wait_for_auth_tasks_async("the graph buffers are obtained for zip")
        self._do_translate(force=force)
        graph = self.get_graph()
        nodes0 = graph["nodes"]
        nodes = [node for node in nodes0]
        checksums = copying.get_checksums(nodes)
        manager = self._manager
        buffer_dict = await copying.get_buffer_dict(manager, checksums)
        archive = BytesIO()
        with ZipFile(archive, mode="w") as zipfile:
            for checksum, buffer in buffer_dict.items():
                zipfile.writestr(checksum, buffer)
        result = archive.getvalue()
        archive.close()
        return result

    def save_zip(self, filename):
        """Save the checksum-to-buffer cache for the current graph

        The cache is saved to "filename", which should be a .zip file
        """
        zip = self.get_zip()
        with open(filename, "wb") as f:
            f.write(zip)

    async def save_zip_async(self, filename):
        """Save the checksum-to-buffer cache for the current graph

        The cache is saved to "filename", which should be a .zip file
        """
        zip = self.get_zip_async()
        with open(filename, "wb") as f:
            f.write(zip)

    def _set_lib(self, path, lib):
        old_lib = self._graph.lib.get(path)
        self._graph.lib[path] = lib
        if lib is not None:
            checksums = copying.get_checksums(lib["graph"]["nodes"])
            for checksum in checksums:
                buffer_cache.incref(bytes.fromhex(checksum), True)
        if old_lib is not None:
            old_checksums = copying.get_checksums(old_lib["graph"]["nodes"])
            for old_checksum in old_checksums:
                buffer_cache.decref(bytes.fromhex(old_checksum))


    def add_zip(self, zip):
        """Adds entries from "zip" to the checksum-to-buffer cache

        "zip" can be a file name, zip-compressed bytes or a Python ZipFile object.
        Normally, it has been generated with Context.save_zip / Context.get_zip
        """
        if self._gen_context is None:
            self._do_translate(force=True)
        manager = self._manager
        if isinstance(zip, bytes):
            archive = BytesIO(zip)
            zipfile = ZipFile(archive, "r")
        elif isinstance(zip, str):
            zipfile = ZipFile(zip, "r")
        elif isinstance(zip, ZipFile):
            zipfile = zip
        elif hasattr(zip, "read") and callable(zip.read):
            zipfile = ZipFile(zip, "r")
        else:
            raise TypeError(type(zip))
        return copying.add_zip(manager, zipfile)

    def include(self, lib, only_zip=False, full_path=False):
        """Include a library in the graph

        A library (seamless.highlevel.Library) must be included before
        library instances (seamless.highlevel.LibInstance) can be constructed
        using ctx.lib
        """
        from .library import Library
        if not isinstance(lib, Library):
            raise TypeError(type(lib))
        if only_zip:
            lib.include_zip(self)
        else:
            lib.include(self, full_path=full_path)
        self._translate()


    def _wait_for_auth_tasks(self, what_happens_text):
        if self._gen_context is not None and not asyncio.get_event_loop().is_running():
            taskmanager = self._gen_context._get_manager().taskmanager
            taskmanager.compute(
                timeout=10, report=2,
                get_tasks_func=get_auth_tasks
            )
            auth_lost_cells = set()
            for task in taskmanager.tasks:
                if not isinstance(task, auth_task_types):
                    continue
                if task._canceled:
                    continue
                auth_lost_cells.add(task.dependencies[0])
                task.cancel()

            if len(auth_lost_cells):
                warn = """WARNING: the following cells had their authoritative value under modification while %s
    These modifications have been CANCELED:
    %s""" % (what_happens_text, list(auth_lost_cells))
                print(warn)

    async def _wait_for_auth_tasks_async(self, what_happens_text):
        if self._gen_context is not None:
            taskmanager = self._gen_context._get_manager().taskmanager
            await taskmanager.computation(
                timeout=10, report=2,
                get_tasks_func=get_auth_tasks
            )
            auth_lost_cells = set()
            for task in taskmanager.tasks:
                if not isinstance(task, auth_task_types):
                    continue
                if task._canceled:
                    continue
                auth_lost_cells.add(task.dependencies[0])
                task.cancel()

            if len(auth_lost_cells):
                warn = """WARNING: the following cells had their authoritative value under modification while %s
    These modifications have been CANCELED:
    %s""" % (what_happens_text, list(auth_lost_cells))
                print(warn)

    @run_in_mainthread
    def _do_translate(self, force=False, explicit=False):
        graph0 = self._get_graph(copy=False)
        return self._do_translate2(graph0, force=force, explicit=explicit)

    async def _do_translate_async(self, force=False, explicit=False):
        assert threading.current_thread() == threading.main_thread()
        graph0 = await self._get_graph_async(copy=False)
        await until_macro_mode_off()
        return self._do_translate2(graph0, force=force, explicit=explicit)


    def _do_translate2(self, graph0, force, explicit):
        from ..midlevel.translate import translate, import_before_translate
        from ..midlevel.pretranslate import pretranslate
        from ..core.context import Context as CoreContext
        #from pprint import pprint; pprint(graph0)
        if not force and not self._needs_translation:
            return
        """
        if self._translating:
            raise Exception("Nested invocation of ctx.translate")
        """
        if self._translating:
            return
        graph = pretranslate(self, graph0)
        if graph is not graph0:
            libinstance_nodes = {node["path"]: node for node in graph["nodes"]}
            self._runtime_graph = Graph(
                libinstance_nodes,
                graph["connections"],
                graph["params"],
                graph["lib"]
            )
        else:
            graph0 = deepcopy(graph0)
            self._runtime_graph = Graph(
                {node["path"]: node for node in graph0["nodes"]},
                graph0["connections"],
                graph0["params"],
                graph0["lib"]
            )

        self._translate_count += 1
        livegraph = self._manager.livegraph
        try:
            ok = False
            self._translating = True
            ctx = None
            if self._gen_context is not None:
                self._gen_context.destroy()
                print_debug("*" * 30 + "DESTROYED BEFORE TRANSLATE" + "*" * 30)
                ok1 = self._manager.livegraph.check_destroyed()
                ok2 = self._manager.taskmanager.check_destroyed()
                if not ok1 or not ok2:
                    raise Exception("Cannot re-translate, since clean-up of old context was incomplete")
            import_before_translate(graph)
            """ KLUDGE
            The translation process does NOT happen in one async step; it will start launching tasks
            and those tasks will be run.
            This is a problem for the high level observers, that will miss checksum updates
             because they are connected only in the next step.
            We must hold all observations during translation, and flush them afterwards
            """
            livegraph._hold_observations = True
            with macro_mode_on():
                ub_ctx = context(
                    toplevel=True,
                    manager=self._manager
                )
                if self._mount is not None:
                    ub_ctx._mount = self._mount.copy()
                self._unbound_context = ub_ctx
                ub_ctx._root_highlevel_context = self
                translate(graph, ub_ctx)
                nodedict = {node["path"]: node for node in graph["nodes"]}
                nodedict0 = {node["path"]: node for node in graph0["nodes"]}
                for path in nodedict:
                    node = nodedict[path]
                    node0 = nodedict0.get(path)
                    if node0 is not None and node is not node0:
                        node0.pop("UNTRANSLATED", None)
            self._gen_context = ub_ctx._bound
            self._gen_context._root_highlevel_context = self
            assert self._gen_context._get_manager() is self._manager
            self._connect_share()
            ok = True
        finally:
            if not ok:
                livegraph._hold_observations = False
            self._translating = False
            self._unbound_context = None
            needs_translation = False
            for node in graph0["nodes"]:
                if isinstance(node, dict) and node.get("UNTRANSLATED"):
                    needs_translation = True
                    break
            self._needs_translation = needs_translation

        try:
            self._translating = True
            for path, child in self._children.items():
                if isinstance(child, (Cell, Transformer, Reactor, Macro)):
                    try:
                        child._set_observers()
                    except Exception:
                        pass
                elif isinstance(child, (PinWrapper, Link)):
                    continue
                else:
                    raise TypeError(type(child))

            for traitlet in self._traitlets.values():
                try:
                    traitlet._connect_seamless()
                except Exception:
                    traceback.print_exc()

        finally:
            livegraph._hold_observations = False
            self._translating = False

        livegraph._flush_observations()

    def _get_shares(self):
        shares = {}
        for path, node in self._graph.nodes.items():
            if node["type"] != "cell":
                continue
            share = node.get("share")
            if share is not None:
                shares[path] = share
        if not len(shares):
            return None
        return shares

    def _connect_share(self):
        shares = self._get_shares()
        if shares is None:
            return
        from ..core import StructuredCell, Cell as core_cell
        global shareserver
        from .. import shareserver
        from ..core.share import sharemanager
        shareserver.start()
        if self._live_share_namespace is None:
            self._live_share_namespace = sharemanager.new_namespace(
                self._manager,
                name=self.share_namespace,
                share_evaluate=False
            )
        for path, shareparams in shares.items():
            key = "/".join(path) #TODO: split in subpaths by inspecting and traversing ctx._children (recursively for subcontext children)
            hcell = self._children[path]
            if not isinstance(hcell, Cell):
                raise NotImplementedError(type(hcell))
            cell = hcell._get_cell()
            if isinstance(cell, StructuredCell):
                pass #TODO: see above
            elif isinstance(cell, core_cell):
                pass #TODO: see above
            else:
                raise TypeError(cell)
            sharepath = shareparams["path"]
            readonly = shareparams["readonly"]
            mimetype = hcell.mimetype
            cell.share(sharepath, readonly, mimetype=mimetype)

    def _destroy_path(self, path, runtime=False):
        graph = self._graph
        if runtime:
            if self._runtime_graph is None:
                return
            graph = self._runtime_graph
        nodes = graph.nodes
        for p in list(nodes.keys()):
            if p[:len(path)] == path:
                node = nodes[p]
                child = self._children.get(p)
                nodes.pop(p)
                self._children.pop(p, None)
                self._traitlets.pop(p, None)
                if not runtime:
                    self._translate()

        nodes = graph.nodes
        l = len(nodes)
        newnodes = {k:v for k,v in nodes.items() \
                    if k[:len(path)] != path }
        if len(newnodes) < l:
            nodes.clear()
            nodes.update(newnodes)
            if not runtime:
                self._translate()

        removed = self._remove_connections(path, runtime=runtime)
        if removed and not runtime:
            self._translate()

    @property
    def status(self):
        """The computation status of the context
        Returns a dictionary containing the status of all children that are not OK.
        If all children are OK, returns "Status: OK"
        """
        nodes, _, _, _ = self._graph
        return get_status(self, self._children, nodes, path=None)

    @property
    def lib(self):
        """Returns the libraries that were included in the graph"""
        from .library.include import IncludedLibraryContainer
        return IncludedLibraryContainer(self, ())

    def resolve(self, checksum):
        """Returns the data buffer that corresponds to the checksum.

        The checksum must be a SHA3-256 hash, as hex string or as bytes"""
        return self._manager.resolve(checksum)

    def observe(self, path, callback, polling_interval, observe_none=False, params=None):
        """Observes attributes of the context, analogous to Cell.observe"""

        observer = PollingObserver(
            self, path, callback, polling_interval,
            observe_none=observe_none,
            params=params
        )
        self._observers.add(observer)
        return observer

    def unobserve(self, path=()):
        """Analogous to Cell.unobserve"""
        lp = len(path)
        for obs in list(self._observers):
            if obs.path[:lp] == path:
                self._observers.remove(obs)

    def _get_libs(self, path):
        lib = self._graph.lib
        lp = len(path)
        result = {k[lp:]:v for k,v in lib.items() \
                  if len(k) > lp and k[:lp] == path \
                }
        return result

    def _get_lib(self, path):
        return self._graph.lib[tuple(path)]

    def _remove_connections(self, path, keep_links=False, runtime=False):
        """Removes all connections starting with path"""
        lp = len(path)
        def keep_con(con):
            if con["type"] == "link":
                if keep_links:
                    return True
                first = con["first"]
                if first[:lp] == path:
                    return False
                second = con["second"]
                if second[:lp] == path:
                    return False
                return True
            else:
                ctarget = con["target"]
                return ctarget[:lp] != path
        connections = self._graph[1]
        if runtime:
            connections = self._runtime_graph[1]
        new_connections = list(filter(keep_con, connections))
        any_removed = (len(new_connections) < len(connections))
        connections[:] = new_connections
        return any_removed

    def link(self, first, second):
        """Creates a bidirectional link between the first and second cell

        Both cells must be authoritative
        """
        link = Link(self, first=first, second=second)
        connections = self._graph.connections
        connections.append(link._node)
        self._translate()

    def get_links(self):
        connections = self._graph.connections
        result = []
        for node in connections:
            if node["type"] == "link":
                result.append(Link(self, node=node))
        return result

    def children(self, type=None):
        """Returns all children of the context
        The type of the children can be specified as string
        If type is None, all children and descendants are returned:
        - SubContexts are not returned, but their children and descendants are (with full path info)
        - For LibInstance, the children and descendants of the generated SynthContext is returned"""
        classless = ("context", "libinstance")
        all_types = list(classless) + list(nodeclasses.keys())
        assert type is None or type in all_types, (type, all_types)
        children00 = []
        for p,c in self._children.items():
            if isinstance(c, LibInstance) and type != "libinstance":
                for child in c.ctx.children():
                    children00.append((child.path, child))
            else:
                children00.append((p, c))
        children0 = children00
        if type is not None and type not in classless:
            klass = nodeclasses[type]
            children0 = [(p,c) for p,c in children00 if isinstance(c, klass)]
        children = [p[0] for p,c in children0]
        if type == "context":
            children = [p for p in children if (p,) not in children00]
        return sorted(list(set(children)))

    def __dir__(self):
        d = [p for p in type(self).__dict__ if not p.startswith("_")]
        subs = [p[0] for p in self._children]
        return sorted(d + list(set(subs)))

    def _destroy(self):
        if self._destroyed:
            return
        self._destroyed = True
        for lib in self._graph.lib.values():
            checksums = copying.get_checksums(lib["graph"]["nodes"])
            for checksum in checksums:
                buffer_cache.decref(bytes.fromhex(checksum))


class SubContext(Base):
    def __init__(self, parent, path):
        super().__init__(parent, path)

    def __getitem__(self, attr):
        if not isinstance(attr, str):
            raise KeyError(attr)
        return getattr(self, attr)

    def __setitem__(self, attr, value):
        if not isinstance(attr, str):
            raise KeyError(attr)
        setattr(self, attr, value)

    def __getattribute__(self, attr):
        if attr.startswith("_"):
            return super().__getattribute__(attr)
        if attr in type(self).__dict__ or attr in self.__dict__:
            return super().__getattribute__(attr)
        parent = self._get_top_parent()
        path = self._path + (attr,)
        return parent._get_path(path)

    def __setattr__(self, attr, value):
        if attr.startswith("_"):
            return object.__setattr__(self, attr, value)
        parent = self._get_top_parent()
        path = self._path + (attr,)
        if isinstance(value, Reactor):
            value._init(parent, path)
            parent._translate()
        elif isinstance(value, Transformer):
            if value._parent is None:
                parent._graph[0][path] = value
                parent._children[path] = value
                value._init(parent, path )
                parent._translate()
            else:
                assign(parent, path, value)
        else:
            assign(parent, path, value)

    def __delattr__(self, attr):
        parent = self._get_top_parent()
        path = self._path + (attr,)
        parent._destroy_path(path)

    def mount(self, path=None, mode="rw", authority="cell", persistent=None):
        raise NotImplementedError # for now, not implemented; TODO: see issue 10

    def _get_graph(self, copy, runtime=False):
        parent = self._parent()
        parent._wait_for_auth_tasks("the graph is being obtained")
        nodes, connections, params, _ = parent._graph
        path = self._path
        lp = len(path)
        newnodes = []
        for nodepath, node in sorted(nodes.items(), key=lambda kv: kv[0]):
            if len(nodepath) > lp and nodepath[:lp] == path:
                newnode = deepcopy(node)
                newnode["path"] = nodepath[lp:]
                newnodes.append(newnode)
        new_connections = []
        for connection in connections:
            if connection["type"] == "connection":
                source, target = connection["source"], connection["target"]
                if source[:lp] == path and target[:lp] == path:
                    con = deepcopy(connection)
                    con["source"] = source[lp:]
                    con["target"] = target[lp:]
                    new_connections.append(con)
            elif connection["type"] == "link":
                first, second = connection["first"], connection["second"]
                if first[:lp] == path and second[:lp] == path:
                    con = deepcopy(connection)
                    con["first"] = first[lp:]
                    con["second"] = second[lp:]
                    new_connections.append(con)
        if copy:
            params = deepcopy(params)
        graph = {
            "nodes": newnodes,
            "connections": new_connections,
            "params": params
        }
        return graph

    def get_graph(self, runtime=False):
        graph = self._get_graph(copy=True, runtime=runtime)
        return graph

    @property
    def status(self):
        parent = self._parent()
        nodes, _, _, _ = parent._graph
        return get_status(parent, parent._children, nodes, self._path)

    def _translate(self):
        self._parent()._translate()

    def children(self, type=None):
        classless = ("context", "libinstance")
        assert type is None or type in classless or type in nodeclasses, (type, nodeclasses.keys())
        l = len(self._path)
        children00 = [(p[l:],c) for p,c in self._parent()._children.items() if len(p) > l and p[:l] == self._path]
        children0 = children00
        if type is not None and type not in classless:
            klass = nodeclasses[type]
            children0 = [(p,c) for p,c in children00 if isinstance(c, klass)]
        children = [p[0] for p,c in children0]
        if type == "context":
            children = [p for p in children if (p,) not in children00]
        return sorted(list(set(children)))

    def __dir__(self):
        d = [p for p in type(self).__dict__ if not p.startswith("_")]
        l = len(self._path)
        subs = [p[l] for p in self._parent()._children if len(p) > l and p[:l] == self._path]
        return sorted(d + list(set(subs)))



from .Reactor import Reactor
from .Transformer import Transformer
from .Cell import Cell
from .Link import Link
from .Macro import Macro
from .pin import PinWrapper
from .library.libinstance import LibInstance
from .PollingObserver import PollingObserver

nodeclasses = {
    "cell": Cell,
    "transformer": Transformer,
    "reactor": Reactor,
    "context": SubContext,
    "macro": Macro,
}

from ..core.manager.tasks.structured_cell import StructuredCellAuthTask
from ..core.manager.tasks import SetCellValueTask, SetCellBufferTask
auth_task_types = (
    SetCellValueTask, SetCellBufferTask, StructuredCellAuthTask
)

def get_auth_tasks(taskmanager):
    tasks = []
    for task in taskmanager.tasks:
        if isinstance(task, auth_task_types):
            tasks.append(task)
    return tasks

from ..core.cache.buffer_cache import buffer_cache