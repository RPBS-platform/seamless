
from . import compilers, languages
from .. import subprocess

import numpy as np
import os
from copy import deepcopy
from ..get_hash import get_hash
import shutil

from threading import RLock
from .locks import locks, locklock

cache = {}

def compile(binary_objects, build_dir, compiler_verbose=False):
    """Takes a completed definition of a compiled module
     and generates a dict-of-binary-objects (.o / .obj)
    If possible, binary objects are read from cache.
     If not, they are generated by executing compilation commands
    """
    all_done = True
    result = {}
    
    curr_dir = os.path.abspath(os.getcwd())
    build_dir = os.path.abspath(build_dir)
    all_headers = {}
    source_files = {}
    for objectname, object_ in binary_objects.items():
        for headername, header in object_["headers"].items():
            if headername in all_headers:
                old_header = all_headers[headername]
                if old_header != header:
                    raise Exception("Two different header versions for '%s'" % headername)
                assert header["language"] in ("c", "cpp") # for now, only C/C++ headers; don't know file extensions otherwise
                all_headers[headername] = header["code"]
    try:
        if build_dir in locks:
            lock = locks[build_dir]
            lock.acquire()
            lock.release()
            return compile(binary_objects, build_dir, compiler_verbose)
        with locklock:        
            lock = RLock()        
            locks[build_dir] = lock
            lock.acquire()
        try:
            os.makedirs(build_dir) #must be non-existing
        except FileExistsError:
            print("WARNING: compiler build dir %s already exists... this could be trouble!" % build_dir)
        os.chdir(build_dir)
        for headername, headercode in all_headers:
            header_file = headername + ".h" # hard-code C/C++ for now
            with open(header_file, "w") as f:
                f.write(headercode)
            source_files[header_file] = header_code
        for objectname, object_ in binary_objects.items():
            code_file = objectname + "." + object_["extension"]
            obj_file = objectname + ".o" #TODO: Windows
            if os.path.exists(obj_file):
                os.remove(obj_file)
            cmd = [
              object_["compiler_binary"], 
              object_["compile_flag"], 
              code_file,
            ]
            cmd += object_["options"]
            cmd += [
              object_["output_flag"], 
              obj_file
            ]
            with open(code_file, "w") as f:
                f.write(object_["code"])
            source_files[code_file] = object_["code"]
            cmd2 = " ".join(cmd)
            if compiler_verbose:
                print(cmd2)
            process = subprocess.run(cmd2,shell=True, capture_output=True)
            #TODO: compilation in parallel
            print(process.stderr.decode())
            assert process.returncode == 0
            with open(obj_file, "rb") as f:
                obj = f.read()
            result[objectname] = obj
    finally:
        os.chdir(curr_dir)
        try:
            shutil.rmtree(build_dir) #TODO: sometimes skip, for GDB
        except:
            pass
        locks.pop(build_dir)
        lock.release()
    return result, source_files

def complete(module_definition):
    assert module_definition["type"] == "compiled"
    assert "public_header" in module_definition
    m = deepcopy(module_definition)
    overall_target = module_definition.get("target", "profile")
    m["target"] = overall_target
    m["link_options"] = module_definition.get("link_options", [])
    project_headers = m.pop("headers", {})
    for objectname, object_ in module_definition["objects"].items():
        if "code" not in object_:
            raise Exception("Binary Module %s: no code in object" % objectname)

        o = m["objects"][objectname]
        lang = object_["language"]
        extension = object_.get("extension")
        _, language, extension2 = find_language(lang)
        if extension is None and extension2 is not None:
            extension = extension2
        if extension is None:
            extension = language["extension"]
        if isinstance(extension, list):
            extension = extension[0]
        o["extension"] = extension

        compiler_name = object_.get("compiler", language.get("compiler"))
        assert compiler_name is not None, lang
        o["compiler"] = compiler_name
        compiler = compilers[compiler_name]
        target = object_.get("target", overall_target)
        assert target in ("release", "debug", "profile"), target
        o["target"] = target
        std_options = object_.get("options", compiler["options"])
        profile_options = object_.get("profile_options", compiler["profile_options"])
        debug_options = object_.get("debug_options", compiler["debug_options"])
        if target in ("release", "profile"):
            options = list(std_options)
            if target == "profile":
                profile_options = list(profile_options) if isinstance(profile_options, str) else profile_options
                options += profile_options
        else:
            options = list(debug_options)
        o.pop("profile_options", None)
        o.pop("debug_options", None)
        o["options"] = options
        compiler_binary = compiler.get("location", compiler_name)
        o["compiler_binary"] = compiler_binary
        o["compile_flag"] = compiler["compile_flag"]
        o["output_flag"] = compiler["output_flag"]

        headers = o.pop("headers", [])
        o["headers"] = {}
        for header in headers:
            assert header in project_headers, (header, project_headers.keys())
            project_header = deepcopy(project_headers[header])
            o["headers"][header] = project_header
    return m

from . import find_language
