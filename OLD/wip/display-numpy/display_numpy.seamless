{
  "lib": {
    "/cell-filelink-start.py": {
      "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n",
      "links": []
    },
    "/gui/cell-basic_display_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_display_float.py": {
      "data": "from seamless.qt.QtWidgets import QDoubleSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QDoubleSpinBox()\nb.setReadOnly(True)\nb.setSingleStep(0.1)\nb.setMaximum(1000000)\nb.setValue(PINS.value.get())\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_html.py": {
      "data": "from seamless.qt.QtWidgets import QPlainTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nw.show()\nb = QPlainTextEdit()\nb.setReadOnly(True)\n#b.setFontPointSize(15)\nb.setPlainText(PINS.value.get())\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_html_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setPlainText(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_display_int.py": {
      "data": "from seamless.qt.QtWidgets import QSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QSpinBox()\nb.setReadOnly(True)\nb.setMaximum(1000000)\nb.setValue(PINS.value.get())\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_json.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\nimport json\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nw.show()\nb = QTextEdit()\nb.setReadOnly(True)\nb.setFontPointSize(15)\nb.setText(json.dumps(PINS.value.get(), indent=2))\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_json_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(json.dumps(PINS.value.get(), indent=2))\nif PINS.title.updated:\n    b.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_display_text.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nw.show()\nb = QTextEdit()\nb.setReadOnly(True)\nb.setFontPointSize(15)\nb.setText(PINS.value.get())\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_text_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_editor_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_editor_float.py": {
      "data": "from seamless.qt.QtWidgets import QDoubleSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QDoubleSpinBox()\nb.setSingleStep(0.01)\nb.setDecimals(3)\nb.setMaximum(1000000)\nif PINS.value.defined:\n    b.setValue(PINS.value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(PINS.value.set)\n",
      "links": []
    },
    "/gui/cell-basic_editor_int.py": {
      "data": "from seamless.qt.QtWidgets import QSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QSpinBox()\nb.setMaximum(1000000)\nif PINS.value.defined:\n    b.setValue(PINS.value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(PINS.value.set)\n",
      "links": []
    },
    "/gui/cell-basic_editor_int_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\nif PINS.maximum.updated:\n    b.setMaximum(PINS.maximum.get())\n",
      "links": []
    },
    "/gui/cell-basic_editor_json.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\nimport json\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nclass MyTextEdit(QTextEdit):\n    def focusOutEvent(self, event):\n        PINS.value.set(self.toPlainText())\n        QTextEdit.focusOutEvent(self, event)\n\nw.show()\nb = MyTextEdit()\nb.setFontPointSize(15)\nif PINS.value.defined:\n    b.setText(json.dumps(PINS.value.get(), indent=2))\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_editor_json_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(json.dumps(PINS.value.get(), indent=2))\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_editor_text.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QMainWindow, QAction\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\n\nw = QMainWindow()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nw.resize(600,600)\nw.setWindowTitle(PINS.title.get())\n\nclass MyTextEdit(QTextEdit):\n    def focusOutEvent(self, event):\n        PINS.value.set(self.toPlainText())\n        QTextEdit.focusOutEvent(self, event)\n\nw.show()\nb = MyTextEdit()\nb.setFontPointSize(15)\nw.setCentralWidget(b)\n\nsaveAction = QAction('&Save', w)\nsaveAction.setShortcut('Ctrl+S')\nsaveAction.setStatusTip('Save')\nsaveAction.triggered.connect(lambda: PINS.value.set(b.toPlainText()))\nw.menuBar().addAction(saveAction)\n\nif PINS.value.defined:\n    b.setText(PINS.value.get())\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\n",
      "links": []
    },
    "/gui/cell-basic_editor_text_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    }
  },
  "macro": [
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": [
        "json",
        "seamless",
        "reactor_params"
      ],
      "module_name": "seamless.core.reactor",
      "func_name": "reactor",
      "code": "@macro(type=(\"json\", \"seamless\", \"reactor_params\"),with_context=False)\ndef reactor(params):\n    \"\"\"Defines a reactor worker.\n\nReactors react upon changes in their input cells.\nReactors are connected to their input cells via inputpins. In addition, reactors\nmay manipulate output cells via outputpins. Finally, a cell may be both an\ninput and an output of the reactor, by connecting it via an editpin.\nThe pins are declared in the `params` parameter (see below).\n\nIn addition, all reactors have three implicit inputpins named `code_start`,\n`code_update` and `code_stop`. Each pin must be connected to a Python cell\n( `dtype=(\"text\", \"code\", \"python\")` ), containing a code block.\n\nThe reactor will start as soon as all input cells (including the three code cells)\nhave been defined. The startup of the reactor will trigger the execution of the\ncode in the `code_start` cell.\n\nAny change in the inputpins (including at startup)\nwill trigger the execution of the `code_update` cell. The `code_stop` cell is\ninvoked when the reactor is destroyed.\n\nAs of seamless 0.1, macro re-evaluation destroys and re-creates all reactors\ncreated by the macro, unless the macro has caching enabled.\n\nAll three code cells are executed in the same namespace. The namespace contains\nan object called `PINS`. This object can be queried for pin objects: a pin\ncalled `spam` is accessible as pin object ``PINS.spam``. The namespace also\ncontains IDENTIFIER, which is guaranteed to be unique for each reactor\ninstance.\n\nEvery inputpin and editpin object contains a ``get()`` method that\nreturns the value.\nAs of seamless 0.1, the `value` property is identical to ``pin.get()``.\n\nEvery inputpin and editpin object has a property `updated`, which is True if\nthe pin has been updated since the last time `code_update` was executed.\n\nEvery outputpin and editpin has a ``set(value)`` method.\nIn case of a signal outputpin, ``set()`` is to be invoked without argument.\nInvoking ``set()`` on a signal outputpin will propagate the signal as fast as possible:\n    - If set from the main thread: immediately. Downstream workers are\n      notified and activated (if synchronous) before set() returns\n    - If set from another thread: as soon as ``seamless.run_work`` is called.\n      Then, downstream workers are notified and activated before any other\n      non-signal notification.\n\nAs of seamless 0.1, all reactors are synchronous (blocking): their code is\nexecuted in the main thread. Therefore, seamless and IPython are non-responsive\nwhile reactor code is executing, and reactor code should return as soon as\npossible. Therefore, if they perform long computations, reactors should spawn\ntheir own threads or processes from within their code.\n\nInvoke ``reactor.status()`` to get the current status of the reactor\n\nInvoke ``shell(reactor)`` to create an IPython shell of the reactor namespace\n\n``pin.connect(cell)`` connects an outputpin to a cell\n\n``cell.connect(pin)`` connects a cell to an inputpin\n\n``pin.cell()`` returns or creates a cell that is connected to that pin\n\nParameters\n----------\n\n    params: dict\n        A dictionary containing the reactor parameters.\n        As of seamless 0.1, each (name,value) item represents a reactor pin:\n\n        -  name: string\n            name of the pin\n\n        -  value: dict\n            with the following items:\n\n            - pin: string\n                must be \"input\", \"output\" or \"edit\"\n            - dtype: string or tuple of strings\n                Describes the dtype of the cell(s) connected to the pin.\n                As of seamless 0.1, the following data types are understood:\n\n                -   \"int\", \"float\", \"bool\", \"str\", \"json\", \"cson\", \"array\", \"signal\"\n                -   \"text\", (\"text\", \"code\", \"python\"), (\"text\", \"code\", \"ipython\")\n                -   (\"text\", \"code\", \"silk\"), (\"text\", \"code\", \"slash-0\")\n                -   (\"text\", \"code\", \"vertexshader\"), (\"text\", \"code\", \"fragmentshader\"),\n                -   (\"text\", \"html\"),\n                -   (\"json\", \"seamless\", \"transformer_params\"),\n                    (\"cson\", \"seamless\", \"transformer_params\"),\n                -   (\"json\", \"seamless\", \"reactor_params\"),\n                    (\"cson\", \"seamless\", \"reactor_params\")\n\n            - must_be_defined: bool\n               default = True\n\n               In case of edit pins, if `must_be_defined` is False, the reactor\n               will start up  even if the connected cell does not yet have a\n               defined value.\n\n        Since \"reactor\" is a macro, the dictionary can also be provided\n        in the form of a cell of dtype (\"json\", \"seamless\", \"reactor_params\")\n\"\"\"\n    from seamless.core.reactor import Reactor #code must be standalone\n    return Reactor(params)\n"
    },
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": [
        "json",
        "seamless",
        "transformer_params"
      ],
      "module_name": "seamless.core.transformer",
      "func_name": "transformer",
      "code": "@macro(type=(\"json\", \"seamless\", \"transformer_params\"), with_context=False)\ndef transformer(params):\n    \"\"\"Defines a transformer worker.\n\nTransformers transform their input cells into an output result.\nTransformers are connected to their input cells via input pins, and their\nresult is connected to an output cell via an output pin. There can be only one\noutput pin. The pins are declared in the `params` parameter (see below).\n\nIn addition, all transformers have an implicit input pin named \"code\",\nwhich must be connected to a Python cell ( `dtype=(\"text\", \"code\", \"python\")` ).\nThe code must be a Python block that returns the result using a \"return\" statement.\nAll input values are injected directly into the code's namespace. The variable\nname of the input is the same as its pin name.\n\nAs of seamless 0.1, all transformers are asynchronous (non-blocking),\nand they carry out their computation in a separate process\n(using ``multiprocessing``).\n\nAs of seamless 0.1, transformers start their computation as soon as all inputs\n(including the code) has been defined, even if no output cell has been connected.\nWhenever the input data or code changes, a new computation is performed. If the\nprevious computation is still in progress, it is canceled.\n\nInside the transformer code, preliminary values can be returned using\n``return_preliminary(value)``.\nAs of seamless 0.1, this does not require any special pin declaration.\n\nInvoke ``transformer.status()`` to get the current status of the transformer.\n\nInvoke ``shell(transformer)`` to create an IPython shell\nof the transformer namespace.\n\n``pin.connect(cell)`` connects an outputpin to a cell.\n\n``cell.connect(pin)`` connects a cell to an inputpin.\n\n``pin.cell()`` returns or creates a cell that is connected to that pin.\n\nParameters\n----------\n\n    params: dict\n        A dictionary containing the transformer parameters.\n\n        As of seamless 0.1, each (name,value) item represents a transformer pin:\n\n        -  name: string\n            name of the pin\n\n        -  value: dict\n            with the following items:\n\n            - pin: string\n                must be \"input\" or \"output\". Only one output pin is allowed.\n            - dtype: string or tuple of strings\n                Describes the dtype of the cell(s) connected to the pin.\n                As of seamless 0.1, the following data types are understood:\n\n                -   \"int\", \"float\", \"bool\", \"str\", \"json\", \"cson\", \"array\", \"signal\"\n                -   \"text\", (\"text\", \"code\", \"python\"), (\"text\", \"code\", \"ipython\")\n                -   (\"text\", \"code\", \"silk\"), (\"text\", \"code\", \"slash-0\")\n                -   (\"text\", \"code\", \"vertexshader\"), (\"text\", \"code\", \"fragmentshader\"),\n                -   (\"text\", \"html\"),\n                -   (\"json\", \"seamless\", \"transformer_params\"),\n                    (\"cson\", \"seamless\", \"transformer_params\"),\n                -   (\"json\", \"seamless\", \"reactor_params\"),\n                    (\"cson\", \"seamless\", \"reactor_params\")\n\n        Since \"transformer\" is a macro, the dictionary can also be provided\n        in the form of a cell of dtype (\"json\", \"seamless\", \"transformer_params\")\n\"\"\"\n    from seamless.core.transformer import Transformer #code must be standalone\n    return Transformer(params)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": "json",
      "module_name": "seamless.lib.dynamic_html",
      "func_name": "dynamic_html",
      "code": "@macro(\"json\")\ndef dynamic_html(ctx, params):\n    from seamless import reactor\n    from collections import OrderedDict\n    params2 = { \"vars\": OrderedDict(),\n                \"html\": OrderedDict(),\n                \"evals\": OrderedDict()\n              }\n    ed_params = {\n        \"DYNAMIC_HTML_PARAMS\": {\n            \"pin\": \"input\",\n            \"dtype\": \"json\"\n        },\n        \"DYNAMIC_HTML_TEMPLATE\": {\n            \"pin\": \"input\",\n            \"dtype\": \"text\"\n        },\n        \"dynamic_html\": {\n            \"pin\": \"output\",\n            \"dtype\": (\"text\", \"html\")\n        }\n    }\n    assert \"dynamic_html\" not in params\n    for k,v in params.items():\n        assert isinstance(v,dict), k\n        ed_param = {\"pin\": \"input\"}\n        type_ = v[\"type\"]\n        assert type_ in (\"var\", \"html\", \"eval\"), type_\n        if type_ == \"var\":\n            dtype = v.get(\"dtype\")\n            evals = v.get(\"evals\", [])\n            var = v.get(\"var\", k)\n            params2[\"vars\"][k] = (var, evals)\n            ed_param[\"dtype\"] = dtype\n        elif type_ == \"html\":\n            id_ = v.get(\"id\", k)\n            params2[\"html\"][k] = id_\n            ed_param[\"dtype\"] = (\"text\", \"html\")\n        else: #type_ = \"eval\"\n            on_start = v.get(\"on_start\", None)\n            params2[\"evals\"][k] = on_start\n            ed_param[\"dtype\"] = \"text\"\n        ed_params[k] = ed_param\n    for k,v in params2[\"vars\"].items():\n        var, evals = v\n        for e in evals:\n            assert e in params2[\"evals\"], (k, e, list(params2[\"evals\"].keys()))\n    rc = ctx.rc = reactor(ed_params)\n    rc.code_start.cell().fromfile(\"cell-dynamic-html-start.py\")\n    rc.code_update.cell().set(\"update(on_start=False)\")\n    rc.code_stop.cell().set(\"\")\n    rc.DYNAMIC_HTML_PARAMS.cell().set(params2)\n    rc.DYNAMIC_HTML_TEMPLATE.cell().fromfile(\"dynamic-html.jinja\")\n    ctx.export(rc)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": "str",
      "module_name": "seamless.lib.filelink",
      "func_name": "filelink",
      "code": "@macro(\"str\")\ndef filelink(ctx, cell_type):\n    cell_filelink_start = \"cell-filelink-start.py\" #repeat for inline\n    from seamless import reactor\n    pinparams = {\n       \"value\": {\n         \"pin\": \"edit\",\n         \"dtype\": cell_type,\n         \"must_be_defined\": False\n       },\n       \"filepath\" : {\n         \"pin\": \"input\",\n         \"dtype\": \"str\"\n       },\n       \"latency\" : {\n         \"pin\": \"input\",\n         \"dtype\": \"float\"\n       },\n    }\n    rc = ctx.rc = reactor(pinparams)\n    rc.code_start.cell().fromfile(cell_filelink_start)\n    rc.code_update.cell().set(\"write_file(PINS.filepath.get())\")\n    rc.code_stop.cell().set('terminate.set(); t.join()')\n    ctx.export(rc)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "display_type": "str",
        "title": {
          "default": "Basic display",
          "type": "str"
        },
        "_order": [
          "display_type",
          "title"
        ]
      },
      "module_name": "seamless.lib.gui.basic_display",
      "func_name": "basic_display",
      "code": "@macro(OrderedDict((\n    (\"display_type\",\"str\"),\n    (\"title\",{\"type\": \"str\", \"default\": \"Basic display\"})\n)))\ndef basic_display(ctx, display_type, title):\n    from seamless import reactor\n\n    _displays = {\n      \"int\": {\n        \"code\": \"cell-basic_display_int.py\",\n        \"update\": \"cell-basic_display_UPDATE.py\",\n      },\n      \"float\": {\n        \"code\": \"cell-basic_display_float.py\",\n        \"update\": \"cell-basic_display_UPDATE.py\",\n      },\n      \"text\": {\n        \"code\": \"cell-basic_display_text.py\",\n        \"update\": \"cell-basic_display_text_UPDATE.py\",\n      },\n      \"str\": {\n        \"code\": \"cell-basic_display_text.py\",\n        \"update\": \"cell-basic_display_text_UPDATE.py\",\n      },\n      (\"text\", \"html\"): {\n        \"code\": \"cell-basic_display_html.py\",\n        \"update\": \"cell-basic_display_html_UPDATE.py\",\n      },\n      \"json\": {\n        \"code\": \"cell-basic_display_json.py\",\n        \"update\": \"cell-basic_display_json_UPDATE.py\",\n      },\n    }\n\n    def _match_type(type, typelist):\n        typelist = list(typelist)\n        type2 = type\n        if isinstance(type, str):\n            type2 = (type,)\n        typelist2 = []\n        for t in typelist:\n            if isinstance(t, str):\n                typelist2.append((t,))\n            else:\n                typelist2.append(t)\n        matches = []\n        for n in range(len(typelist)):\n            ltype = typelist2[n]\n            k = min(len(type2), len(ltype))\n            if type2[:k] == ltype[:k]:\n                matches.append((n, k))\n        if not len(matches):\n            raise TypeError(\"Cannot find display for cell type '{0}'\".format(type))\n        matches.sort(key=lambda v: -v[1])\n        bestmatch = matches[0][0]\n        return typelist[bestmatch]\n\n    display_type = _match_type(display_type, _displays.keys())\n    pinparams = {\n      \"value\": {\n        \"pin\": \"input\",\n        \"dtype\": display_type\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    d = ctx.display = reactor(pinparams)\n    d.title.cell().set(title)\n    d.code_start.cell().fromfile(_displays[display_type][\"code\"])\n    d.code_stop.cell().set('w.destroy()')\n    upfile = _displays[display_type][\"update\"]\n    c_up = d.code_update.cell()\n    if upfile is not None:\n        c_up.fromfile(upfile)\n    else:\n        c_up.set(\"\")\n    ctx.export(d, forced=[\"title\"])\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "editor_type": "str",
        "title": {
          "default": "Basic editor",
          "type": "str"
        },
        "_order": [
          "editor_type",
          "title"
        ]
      },
      "module_name": "seamless.lib.gui.basic_editor",
      "func_name": "basic_editor",
      "code": "@macro(OrderedDict((\n    (\"editor_type\",\"str\"),\n    (\"title\",{\"type\": \"str\", \"default\": \"Basic editor\"})\n)))\ndef basic_editor(ctx, editor_type, title):\n    from seamless import reactor\n\n    _editors = {\n      \"int\": {\n        \"code\": \"cell-basic_editor_int.py\",\n        \"update\": \"cell-basic_editor_int_UPDATE.py\",\n      },\n      \"float\": {\n        \"code\": \"cell-basic_editor_float.py\",\n        \"update\": \"cell-basic_editor_UPDATE.py\",\n      },\n      \"text\": {\n        \"code\": \"cell-basic_editor_text.py\",\n        \"update\": \"cell-basic_editor_text_UPDATE.py\",\n      },\n      \"json\": {\n        \"code\": \"cell-basic_editor_json.py\",\n        \"update\": \"cell-basic_editor_json_UPDATE.py\",\n      },\n    }\n\n    def _match_type(type, typelist):\n        typelist = list(typelist)\n        type2 = type\n        if isinstance(type, str):\n            type2 = (type,)\n        typelist2 = []\n        for t in typelist:\n            if isinstance(t, str):\n                typelist2.append((t,))\n            else:\n                typelist2.append(t)\n        matches = []\n        for n in range(len(typelist)):\n            ltype = typelist2[n]\n            k = min(len(type2), len(ltype))\n            if type2[:k] == ltype[:k]:\n                matches.append((n, k))\n        if not len(matches):\n            raise TypeError(\"Cannot find editor for cell type '{0}'\".format(type))\n        matches.sort(key=lambda v: -v[1])\n        bestmatch = matches[0][0]\n        return typelist[bestmatch]\n\n    editor_type = _match_type(editor_type, _editors.keys())\n    pinparams = {\n      \"value\": {\n        \"pin\": \"edit\",\n        \"dtype\": editor_type,\n        \"must_be_defined\": False\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    if editor_type == \"int\":\n        pinparams[\"maximum\"] = {\"pin\": \"input\", \"dtype\": \"int\"}\n    rc = ctx.rc = reactor(pinparams)\n    rc.title.cell().set(title)\n    forced = [\"title\"]\n    if editor_type == \"int\":\n        rc.maximum.set(9999999)\n        forced.append(\"maximum\")\n    rc.code_start.cell().fromfile(_editors[editor_type][\"code\"])\n    rc.code_stop.cell().set('w.destroy()')\n    upfile = _editors[editor_type][\"update\"]\n    c_up = rc.code_update.cell(True)\n    if upfile is not None:\n        c_up.fromfile(upfile)\n    else:\n        c_up.set(\"\")\n    ctx.export(rc, forced=forced)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "dtype": {
          "default": [
            "text",
            "html"
          ],
          "type": "dtype"
        },
        "title": {
          "default": "Browser",
          "type": "str"
        },
        "_order": [
          "dtype",
          "title"
        ]
      },
      "module_name": "seamless.lib.gui.browser",
      "func_name": "browser",
      "code": "@macro(OrderedDict((\n    (\"dtype\",{\"type\": \"dtype\", \"default\": (\"text\", \"html\")}),\n    (\"title\",{\"type\": \"str\", \"default\": \"Browser\"})\n)))\ndef browser(ctx, dtype, title):\n    from seamless import reactor\n    assert dtype[:2] == (\"text\", \"html\") #for now...\n    pinparams = {\n      \"value\": {\n        \"pin\": \"edit\",\n        \"dtype\": dtype\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    rc = ctx.rc = reactor(pinparams)\n    rc.title.cell().set(title)\n    rc.code_start.cell().fromfile(\"cell-browser.py\")\n    rc.code_stop.cell().set('widget.destroy()')\n    c_up = rc.code_update.cell(True)\n    c_up.fromfile(\"cell-browser_UPDATE.py\")\n    ctx.export(rc, forced=[\"title\"])\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "template_definition": "json",
        "output_type": {
          "default": [
            "text",
            "html"
          ],
          "type": "dtype"
        },
        "_order": [
          "template_definition",
          "output_type"
        ]
      },
      "module_name": "seamless.lib.templateer",
      "func_name": "templateer",
      "code": "@macro(OrderedDict((\n  (\"template_definition\", \"json\"),\n  (\"output_type\", {\"type\": \"dtype\", \"default\": (\"text\", \"html\")}),\n)))\ndef templateer(ctx, template_definition, output_type):\n    from seamless import cell, reactor\n    templates = template_definition[\"templates\"]\n    assert isinstance(templates, list)\n    environment = template_definition[\"environment\"]\n    ed_params = {}\n    for t in templates:\n        assert t not in ed_params, t\n        ed_params[t] = {\"pin\": \"input\", \"dtype\": \"text\"}\n    for k,v in environment.items():\n        assert k not in ed_params, k\n        ed_params[k] = {\"pin\": \"input\", \"dtype\": v}\n    ed_params[\"TEMPLATE_DEFINITION\"] = {\"pin\": \"input\", \"dtype\": \"json\"}\n    ed_params[\"RESULT\"] = {\"pin\": \"output\", \"dtype\": output_type}\n    ctx.rc = reactor(ed_params)\n    ctx.rc.TEMPLATE_DEFINITION.cell().set(template_definition)\n    ctx.rc.code_start.cell().fromfile(\"cell-templateer.py\")\n    ctx.rc.code_update.cell().set(\"make_template()\")\n    ctx.rc.code_stop.cell().set(\"\")\n    ctx.export(ctx.rc)\n"
    },
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "period": {
          "default": 0,
          "type": "float"
        },
        "_order": [
          "period"
        ]
      },
      "module_name": "seamless.lib.timer",
      "func_name": "timer",
      "code": "@macro(OrderedDict((\n    (\"period\", {\"type\": \"float\", \"default\": 0}),\n)), with_context=False)\ndef timer(period):\n    from seamless import reactor\n    timer = reactor({\n        \"period\": {\"pin\": \"input\", \"dtype\": \"float\"},\n        \"trigger\": {\"pin\": \"output\", \"dtype\": \"signal\"}\n    })\n    timer.code_start.cell().fromfile(\"cell-timer.py\")\n    timer.code_update.cell().set(\"\")\n    timer.code_stop.cell().set(\"t.cancel(); dead = True\")\n    if period > 0:\n        timer.period.cell().set(period)\n    return timer\n"
    }
  ],
  "main": {
    "type": "context",
    "like_worker": false,
    "like_cell": false,
    "pins": {},
    "auto": [
      "cell1",
      "cell2",
      "registrar_object1"
    ],
    "children": {
      "array": {
        "dtype": "array",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        }
      },
      "aspect_layout": {
        "dtype": [
          "text",
          "code",
          "python"
        ],
        "resource": {
          "filepath": "AspectLayout.py",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "data": "# Sjoerd de Vries, 2017\n# partially based on code ported from https://gist.github.com/pavel-perina/1324ff064aedede0e01311aab315f83d, copyright (c) 2017 Pavel Perina\n\n\"\"\"\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\n\nfrom PyQt5.QtWidgets import QLayout\nfrom PyQt5.QtCore import Qt, QSize\n\nclass AspectLayout(QLayout):\n    def __init__(self, aspect):\n        self.aspect = aspect\n        self.item = None\n        super().__init__()\n        self.setContentsMargins(0,0,0,0)\n\n    def addItem(self, item):\n        assert self.item is None, \"AspectLayout can contain only 1 widget\"\n        self.item = item\n\n    def itemAt(self, index):\n        if index != 0:\n            return None\n        if self.item is None:\n            return None\n        return self.item\n\n    def takeAt(self, index):\n        if index != 0:\n            return None\n        if self.item is None:\n            return None\n        result = self.item\n        self.item = None\n        return result\n\n    def setGeometry(self, rect):\n        super().setGeometry(rect)\n        margins = self.getContentsMargins()\n        if self.item is not None:\n            availW = rect.width() - margins[1] - margins[3]\n            availH = rect.height() - margins[0] - margins[2]\n            h = availH\n            w = h * self.aspect\n            if w > availW:\n                x = margins[1]\n                w = availW\n                h = w/self.aspect\n                if self.item.alignment() &  Qt.AlignTop:\n                    y = margins[0]\n                elif self.item.alignment() &  Qt.AlignBottom:\n                    y = rect.height() - margins[2] - h\n                else:\n                    y = margins[0] + (availH-h) / 2\n            else:\n                y = margins[0]\n                if self.item.alignment() &  Qt.AlignLeft:\n                    x = margins[1]\n                elif self.item.alignment() &  Qt.AlignRight:\n                    x = rect.width() - margins[3] - w\n                else:\n                    x = margins[1] + (availW-w) / 2\n            self.item.widget().setGeometry(\n                rect.x() + x,\n                rect.y() + y,\n                w, h)\n\n    def sizeHint(self):\n        margins = self.getContentsMargins()\n        if self.item is None:\n            return QSize(margins[0]+margins[2],margins[1]+margins[3])\n        s = self.item.sizeHint()\n        w, h = s.width(), s.height()\n        return QSize(margins[0]+margins[2] + w, margins[1]+margins[3] + h)\n\n    def minimumSize(self):\n        margins = self.getContentsMargins()\n        if self.item is None:\n            return QSize(margins[0]+margins[2],margins[1]+margins[3])\n        s = self.item.minimumSize()\n        w, h = s.width(), s.height()\n        return QSize(margins[0]+margins[2] + w, margins[1]+margins[3] + h)\n\n    def expandingDirections(self):\n       return Qt.Horizontal | Qt.Vertical\n\n    def hasHeightForWidth(self):\n        return True\n\n    def count(self):\n        if self.item is None:\n            return 0\n        else:\n            return 1\n\n    def heightForWidth(self, width):\n        margins = self.getContentsMargins()\n        height = (width - margins[1] - margins[3]) / self.aspect\n        height += margins[0] + margins[2]\n        return int(height)\n"
      },
      "cell1": {
        "dtype": [
          "text",
          "code",
          "python"
        ],
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "data": "update()"
      },
      "cell2": {
        "dtype": [
          "text",
          "code",
          "python"
        ],
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "data": "destroy()"
      },
      "code": {
        "dtype": [
          "text",
          "code",
          "python"
        ],
        "resource": {
          "filepath": "cell-display-numpy.py",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "data": "from PyQt5.QtWidgets import QMainWindow, QLabel, QWidget, QFrame, QSizePolicy\nfrom PyQt5.QtGui import QImage, QPixmap\nfrom PyQt5.QtCore import Qt, QSize\nimport numpy as np\n\nw = QMainWindow(size=QSize(400, 400))\nww = QWidget()\nw.setCentralWidget(ww)\nasp = AspectLayout(1.0)\nww.setLayout(asp)\nw.setWindowFlags(Qt.WindowStaysOnTopHint)\n\nl = QLabel()\nl.setScaledContents(True)\nl.setSizePolicy(QSizePolicy(QSizePolicy.Maximum, QSizePolicy.Maximum))\nasp.addWidget(l)\nl.setParent(ww)\nl.setFrameStyle(QFrame.NoFrame)\nw.show()\n\ndef update():\n    if PINS.title.updated:\n        w.setWindowTitle(PINS.title.get())\n    global arr\n    arr = PINS.array.get()\n    assert arr.dtype in (float, np.float32, np.uint8), arr.dtype\n    arr = np.ascontiguousarray(arr)\n    if arr.ndim == 1:\n        arr = arr.reshape((len(arr), 1))\n    if arr.ndim == 3:\n        assert arr.shape[-1] == 3\n        if arr.dtype == np.uint8:\n            arr_norm_255 = arr\n        else:\n            amin = arr.min(axis=0).min(axis=0)\n            amax = arr.max(axis=0).max(axis=0)\n            arange = np.maximum(amax-amin, 1e-12)\n            arr_norm = (arr - amin) / arange\n            arr_norm_255 = ((arr_norm- 1e-6)*256).astype(np.uint8)\n        width, height = arr.shape[1], arr.shape[0]\n        im = QImage(arr_norm_255, width, height, width*3, QImage.Format_RGB888)\n    elif arr.ndim == 2:\n        if arr.dtype == np.uint8:\n            arr_norm_255 = arr\n        else:\n            amin = arr.min()\n            amax = arr.max()\n            arange = np.maximum(amax-amin, 1e-12)\n            arr_norm = (arr - amin) / arange\n            arr_norm_255 = ((arr_norm- 1e-6)*256).astype(np.uint8)\n        arr_color = np.zeros((arr.shape) + (3,), dtype=np.uint8)\n        arr_color[:,:,0] = arr_norm_255\n        arr_color[:,:,1] = 128 - np.abs(arr_norm_255.astype(int)-128)\n        arr_color[:,:,2] = 255 - arr_norm_255\n        width, height = arr_color.shape[1], arr_color.shape[0]\n        im = QImage(arr_color, width, height, width*3, QImage.Format_RGB888)\n\n    pm = QPixmap.fromImage(im)\n    aspect = width / height\n    asp.aspect = aspect\n    cwidth, cheight = w.size().width(), w.size().height()\n    l.setPixmap(pm)\n    l.setMinimumSize(1,1)\n    scalex = width/cwidth\n    scaley = height/cheight\n    scale = max(scalex, scaley)\n    if scale > 1:\n        w.resize(width/scale, height/scale)\n    w.updateGeometry()\ndef destroy():\n    global w, l\n    del l\n    del w\n\n#update()\n"
      },
      "display_numpy": {
        "type": "reactor",
        "mode": "sync",
        "params": {
          "array": {
            "dtype": "array",
            "pin": "input"
          },
          "title": {
            "dtype": "str",
            "pin": "input"
          }
        }
      },
      "registrar_object1": {
        "registrar": "python",
        "registered": [
          "QLayout",
          "Qt",
          "QSize",
          "AspectLayout"
        ],
        "data": "# Sjoerd de Vries, 2017\n# partially based on code ported from https://gist.github.com/pavel-perina/1324ff064aedede0e01311aab315f83d, copyright (c) 2017 Pavel Perina\n\n\"\"\"\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\n\nfrom PyQt5.QtWidgets import QLayout\nfrom PyQt5.QtCore import Qt, QSize\n\nclass AspectLayout(QLayout):\n    def __init__(self, aspect):\n        self.aspect = aspect\n        self.item = None\n        super().__init__()\n        self.setContentsMargins(0,0,0,0)\n\n    def addItem(self, item):\n        assert self.item is None, \"AspectLayout can contain only 1 widget\"\n        self.item = item\n\n    def itemAt(self, index):\n        if index != 0:\n            return None\n        if self.item is None:\n            return None\n        return self.item\n\n    def takeAt(self, index):\n        if index != 0:\n            return None\n        if self.item is None:\n            return None\n        result = self.item\n        self.item = None\n        return result\n\n    def setGeometry(self, rect):\n        super().setGeometry(rect)\n        margins = self.getContentsMargins()\n        if self.item is not None:\n            availW = rect.width() - margins[1] - margins[3]\n            availH = rect.height() - margins[0] - margins[2]\n            h = availH\n            w = h * self.aspect\n            if w > availW:\n                x = margins[1]\n                w = availW\n                h = w/self.aspect\n                if self.item.alignment() &  Qt.AlignTop:\n                    y = margins[0]\n                elif self.item.alignment() &  Qt.AlignBottom:\n                    y = rect.height() - margins[2] - h\n                else:\n                    y = margins[0] + (availH-h) / 2\n            else:\n                y = margins[0]\n                if self.item.alignment() &  Qt.AlignLeft:\n                    x = margins[1]\n                elif self.item.alignment() &  Qt.AlignRight:\n                    x = rect.width() - margins[3] - w\n                else:\n                    x = margins[1] + (availW-w) / 2\n            self.item.widget().setGeometry(\n                rect.x() + x,\n                rect.y() + y,\n                w, h)\n\n    def sizeHint(self):\n        margins = self.getContentsMargins()\n        if self.item is None:\n            return QSize(margins[0]+margins[2],margins[1]+margins[3])\n        s = self.item.sizeHint()\n        w, h = s.width(), s.height()\n        return QSize(margins[0]+margins[2] + w, margins[1]+margins[3] + h)\n\n    def minimumSize(self):\n        margins = self.getContentsMargins()\n        if self.item is None:\n            return QSize(margins[0]+margins[2],margins[1]+margins[3])\n        s = self.item.minimumSize()\n        w, h = s.width(), s.height()\n        return QSize(margins[0]+margins[2] + w, margins[1]+margins[3] + h)\n\n    def expandingDirections(self):\n       return Qt.Horizontal | Qt.Vertical\n\n    def hasHeightForWidth(self):\n        return True\n\n    def count(self):\n        if self.item is None:\n            return 0\n        else:\n            return 1\n\n    def heightForWidth(self, width):\n        margins = self.getContentsMargins()\n        height = (width - margins[1] - margins[3]) / self.aspect\n        height += margins[0] + margins[2]\n        return int(height)\n",
        "data_name": null
      },
      "title": {
        "dtype": "str",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "data": "Numpy array"
      }
    },
    "macro_objects": [],
    "macro_listeners": [],
    "registrar_items": [
      {
        "registrar_name": "python",
        "dtype": [
          "text",
          "code",
          "python"
        ],
        "data": "# Sjoerd de Vries, 2017\n# partially based on code ported from https://gist.github.com/pavel-perina/1324ff064aedede0e01311aab315f83d, copyright (c) 2017 Pavel Perina\n\n\"\"\"\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\"\"\"\n\nfrom PyQt5.QtWidgets import QLayout\nfrom PyQt5.QtCore import Qt, QSize\n\nclass AspectLayout(QLayout):\n    def __init__(self, aspect):\n        self.aspect = aspect\n        self.item = None\n        super().__init__()\n        self.setContentsMargins(0,0,0,0)\n\n    def addItem(self, item):\n        assert self.item is None, \"AspectLayout can contain only 1 widget\"\n        self.item = item\n\n    def itemAt(self, index):\n        if index != 0:\n            return None\n        if self.item is None:\n            return None\n        return self.item\n\n    def takeAt(self, index):\n        if index != 0:\n            return None\n        if self.item is None:\n            return None\n        result = self.item\n        self.item = None\n        return result\n\n    def setGeometry(self, rect):\n        super().setGeometry(rect)\n        margins = self.getContentsMargins()\n        if self.item is not None:\n            availW = rect.width() - margins[1] - margins[3]\n            availH = rect.height() - margins[0] - margins[2]\n            h = availH\n            w = h * self.aspect\n            if w > availW:\n                x = margins[1]\n                w = availW\n                h = w/self.aspect\n                if self.item.alignment() &  Qt.AlignTop:\n                    y = margins[0]\n                elif self.item.alignment() &  Qt.AlignBottom:\n                    y = rect.height() - margins[2] - h\n                else:\n                    y = margins[0] + (availH-h) / 2\n            else:\n                y = margins[0]\n                if self.item.alignment() &  Qt.AlignLeft:\n                    x = margins[1]\n                elif self.item.alignment() &  Qt.AlignRight:\n                    x = rect.width() - margins[3] - w\n                else:\n                    x = margins[1] + (availW-w) / 2\n            self.item.widget().setGeometry(\n                rect.x() + x,\n                rect.y() + y,\n                w, h)\n\n    def sizeHint(self):\n        margins = self.getContentsMargins()\n        if self.item is None:\n            return QSize(margins[0]+margins[2],margins[1]+margins[3])\n        s = self.item.sizeHint()\n        w, h = s.width(), s.height()\n        return QSize(margins[0]+margins[2] + w, margins[1]+margins[3] + h)\n\n    def minimumSize(self):\n        margins = self.getContentsMargins()\n        if self.item is None:\n            return QSize(margins[0]+margins[2],margins[1]+margins[3])\n        s = self.item.minimumSize()\n        w, h = s.width(), s.height()\n        return QSize(margins[0]+margins[2] + w, margins[1]+margins[3] + h)\n\n    def expandingDirections(self):\n       return Qt.Horizontal | Qt.Vertical\n\n    def hasHeightForWidth(self):\n        return True\n\n    def count(self):\n        if self.item is None:\n            return 0\n        else:\n            return 1\n\n    def heightForWidth(self, width):\n        margins = self.getContentsMargins()\n        height = (width - margins[1] - margins[3]) / self.aspect\n        height += margins[0] + margins[2]\n        return int(height)\n",
        "data_name": null
      }
    ],
    "registrar_listeners": [
      {
        "registrar": "python",
        "key": "AspectLayout",
        "target_type": "worker",
        "target_worker": "display_numpy",
        "namespace_name": "AspectLayout"
      }
    ],
    "registrar_cells": [
      {
        "cell": "aspect_layout",
        "macro_target": "registrar_object1",
        "registrar": "python"
      }
    ],
    "pin_cell_connections": [],
    "cell_pin_connections": [
      [
        "array",
        "display_numpy.array"
      ],
      [
        "cell1",
        "display_numpy.code_update"
      ],
      [
        "cell2",
        "display_numpy.code_stop"
      ],
      [
        "code",
        "display_numpy.code_start"
      ],
      [
        "title",
        "display_numpy.title"
      ]
    ],
    "cell_cell_connections": []
  }
}