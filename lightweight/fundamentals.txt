UP TO DATE

A1 Vertex
Read-only
A vertex has one or more vertex attributes (at least one: its Cartesian coordinate). The number and nature of the vertex attributes define the vertex format.

A2 Vertex buffer
Contains an array of vertices in the same vertex format.

B1 Primitive (indexed)
Draw command: glDrawElements
  Draws a number of elements, using an vertex index buffer that points into a vertex buffer
  alternative draw commands: glDraw[Range]Elements[BaseVertex]
    [Range] provides an offset into the vertex index buffer
    [BaseVertex] provides an offset into the vertex buffer
    Or inverse?
A primitive consists of:
- A draw primitive (triangles, points, lines, ...)
- The number of primitives to draw
- A shader
- One or more texture bindings
- A binding to a vertex buffer 
- A vertex index buffer
- Per-vertex attributes
  The vertex shader does not see the vertex buffer nor the vertex index buffer directly. It sees only the attribute values of the current vertex. These attribute values have already been retrieved from the vertex buffer by OpenGL, using the vertex index of the current vertex.
- Per-primitive attributes
  
  
*Per-vertex attributes*
A per-vertex attribute can be implemented as "just" a vertex attribute on the VAO. Attributes on the VAO can be implemented as one-VBO-per-attribute, leading to a flat data layout. Alternatively, they can be implemented as one-VBO-for-all, leading to an interleaved data layout, or as a hybrid of the two. Elements inside the buffer may need padding for good performance. 
(speculation)
A per-vertex attribute can also be defined outside the VAO, in a "secondary vertex buffer". Is glVertexIndex implemented? If not, it can be trivially implemented by defining a "glVertexIndex" attribute with its own VBO bound to the vertex index buffer. The attribute can than be retrieved from the "secondary vertex buffer", which is implemented as an UBO, using glVertexIndex.
The use of a secondary vertex buffer gets around the limitation of one VAO (i.e. one vertex format) per draw command. Suppose that some primitives have per-vertex normals, some per-vertex colors, some both, and some neither. With secondary vertex buffers, you could render all of those primitives in the same draw command, without defining an "uber vertex format" that would be an union of all attributes, wasting a lot of space.


*Per-primitive attributes*
A per-primitive attribute can be implemented as a uniform if it is small and constant (= read-only, one read per primitive). 
If it is large (and, optionally, non-constant), it can be implemented as an index into a texture image buffer.
If it is non-constant (and, optionally, large), it can be implemented as (an index into) an SSBO.
The user should indicate the preferred storage method, and only violations should be checked.

B2 Batch 
Draw command: glDrawElementsInstanced
  Draws a number of primitive instances, using an instance buffer that 
  alternative draw commands: glDrawElementsInstanced[BaseVertex][BaseInstance]
  [BaseVertex] provides an offset into the vertex buffer ??
  [BaseInstance] provides an offset into ??
A batch consists of:
- A primitive
- Per-batch attributes
To draw the primitive, it will bind its VBA (vertex buffer, vertex index buffer and the vertex attributes) and retrieve the number of primitives to draw


*Per-instance attributes* 
In the context of batches, per-primitive attributes become per-instance attributes. 
The same implementation strategies as above apply. At the batch level, a per-primitive uniform becomes a UBO that is read using glInstanceID.
Likewise, indices into texture images or SSBOs are just uniforms, they become UBOs too.
Alternatively, per-instance attributes can be implemented as vertex attributes, in combination with a vertex attribute divisor of 1. This should be indicated by the user.

*Per-batch attributes*
They can be implemented simply, the same as per-primitive attributes


B3 Bucket
Draw command: glMultiDrawElementsIndirect 
Batch draw, essentially repeated invocations of glDrawElementsInstanced, where the parameters (essentially the number of vertices (divided by two or three), and the number of instances; the rest is offsets) are stored in a GPU buffer.

*Bucket per-instance attributes
Per-instance attributes configured as divisor vertex attributes will work automatically
Other per-instance attributes are trickier. We will concatenate all their arrays into a single one-dimensional array in a UBO. In principle, we would retrieve them as glDrawID * COUNT + glInstanceID, where COUNT is the number of instances per batch draw. However, COUNT is not constant among draws. Therefore, we have to construct a cumsum array (with length=number of draws) that contains the total number of instances that have been drawn so far. Adding glInstanceID to cumsum[glDrawID] should work.
Primitive external vertex attributes inside a bucket work more or less the same. They are constant per instance, but not per batch draw. So in principle, you would retrieve them as glDrawID * COUNT + glVertexID, where COUNT is the number of vertices of the primitive. Likewise, every batch has its own primitive, so again a cumsum array is needed that accumulates the number of vertices of each batch's primitive. Adding glVertexID to cumsum[glDrawID] should work.

*Bucket per-batch attributes
Per-batch attributes are generalized in similar ways as batch per-instance attributes.
A per-batch uniform becomes a UBO that is read using glDrawID. Likewise for indices into texture images and SSBOs.


*Per-bucket attributes
Should not exist. The engine should arrange batches into buckets, they should not be defined in the scene graph.

Note: Apparently, for best performance, very small buckets should be split and rendered at the batch level and/or very small batches should be split into prim renderings. Some config parameter should control this.


C Textures
Textures are global. Not per-vertex, per-primitive, per-batch or per-bucket, just global. Unlike attributes, and like shaders, they cannot change during the draw command. However, unlike shaders, more than one can be bound, and they can be arranged into texture groups (texture arrays). Within a texture group, each texture must have the same size (effectively, the size of the largest texture; all other ones can be padded). This leads to an interesting optimization problem. Given TMax textures (GL_MAX_TEXTURES_BOUND or something) that can be bound simultaneously (8? Dozens?), and T different textures (up to thousands), and primitives using typically 1 texture, but up to TMax textures, what is the best way to arrange them into texture arrays? Every bucket can select up to TMax texture arrays, primitives that need other ones need to go into another bucket. Formulated differently: you can define texture group access lists (TGALs; a TGAL is just a list of the texture groups that the primitive needs) and primitives with different TGALs must go into different buckets. To organize the texture groups, you want to minimize padding, and duplication (a texture being in multiple texture arrays), to save memory. A fast and simple solution is to create a single texture group containing all textures, but this may violate some GL_MAX_TEXTURE_ARRAY_SIZE parameter, and lead to enormous padding if one texture is much larger than the rest.
Also, does TMax include image textures (which are essentially ndarrays, and do not use linear interpolation)?

Lightweight will not deal with this optimization problem. It is up to the user to assign a texture to one or more texture groups, and to assign a TGAL to each primitive (in addition to the names of the textures it needs). Lightweight will verify that the TGAL contains all textures needed by the primitive, and, at shader runtime, will fetch the correct textures.

However, there are now also sparse textures, maybe this provides an alternative?
