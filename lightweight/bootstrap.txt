MOSTLY UP-TO-DATE, HOWEVER:
- Incomplete: stuff needs to be added, and some stuff needs to be ported over from design.txt
- There will be a split: lightweight => lightweight + raedae
  Lightweight = opengl
  Raedae = transformation, also useful e.g. for plotting
  Much of documentation here actually belongs in raedae

*****


Textures will be delegated for later

name is a fundamental attribute for all schemas, partials and prototypes!

***
Builtin types:
(signed/unsigned) int/short/byte, float, double, str, bool, enum, prototype, and python

float is float32
double is Python float
bool uses one byte (as in numpy)
python is a Python object (usually a callable one)
prototype means essentially a dict, but prototype instances can be constructed by (extended) name, see "construction".

Data access expressions (DAEs):
They are strings starting with a @, to define an attribute of a construct (node, schema, etc.) . The expression after the @ is evaluated in Python using as its globals() the DAE execution context. The execution context contains two other variables, "self" referring to the current node and "parent"

Conditionals:
Conditionals are special syntactic node constructs. They have an attribute "name", which must be unique. They have an attribute "expression", which must be a DAE of any type returning a string. There must be other attributes with names representing all possible values of "expression". Upon node collapse, a conditional is replaced with the value of the attribute whose name corresponds to the value of the expression. The "default" attribution describes the value if none of the other attributes correspond.
The expression may also return a bool, in case there should be two attributes, 'True'/'true' and 'False'/'false'. Lightweight does not check if the expression returns a bool or a string, but you cannot define 'True'/'true' without 'False'/'false' and vice versa. "default" is also allowed.
If the conditional returns a prototype, all of the prototype's attributes depend on all attributes in the expression. Therefore, if any of these attributes are dynamic, none of the prototype's attributes can be dynamic.
Conditionals are defined inside a DAE as "@conditional(name)"


Pipeline:

0) Booting stage
    - DAE execution context
    - Namespace enumeration
    - Type schema definitions
Before booting, Lightweight just consists of:
- an API to fill the DAE execution context
- an API for conditionals
- DAE evaluation
- APIs to register dynamicity and topologicality
- A boot API i.e. API for setting up namespaces and type schemas.
Lightweight starts with two namespaces, "type" (containing type schemas) and "python" (containing Python objects), and one type schema "empty".
All type schemas (other than "empty") have two attributes:
- "base", indicating from which type schema they derive
- "constructor", indicating the name of the python object that can construct a hard-coded value, once the DAEs have been evaluated.
The constructor must invoke the internal lightweight APIs to evaluate DAE's (possibly returning an RAE), to register dynamicity and to register topologicality (i.e. to say if modifying a parameter leads to a topology regeneration or not)

All other attributes of a type schema are interpreted as attribute specifiers.
They should be a dictionary containing {"type": str/float/int/bool/array, "optional":"true"/"false", "default" (optional) }
"value" is a special attribute specifier. It cannot be defined during type schema definition. However, it can be assigned to using schema definition. In other words,
defining_a_schema:
  attribute:
    value: "spam"

is a more verbose way of:

defining_an_attribute:
  attribute: "spam"

*Lightweight default booting*

Lightweight default booting sets up the rest of the Lightweight pipeline, and it is assumed that you run all stages of default booting. If you know what you are doing, change them.

Stage 1 (lw.boot.setup_type)
Stage 1 of lightweight default booting sets up a single type schema, called "type", with a corresponding constructor.
Its attribute specifiers are as follows:
dtype
  Can be any builtin type or a prototype
shape (shape, optional)
  Can contain an int or a tuple/list of ints, which are interpreted as the array shape (as in numpy). If shape is not specified,
  shape definitions are as in numpy, but dimension can be zero to indicate a dynamic size
namespace (string, optional)
  Only if dtype is a prototype. Defines the namespace where it is to be found
minschema (string, optional)
  Only if dtype is a prototype. After node collapse, the prototype's schema must be a superset of minschema.
  I.e., all attributes in minschema (with the same dtype, shape, etc.) must be defined in the prototype's schema.
maxschema (string, optional)
  Only if dtype is a prototype. After node collapse, the prototype's schema must be a subset of maxschema. I.e., all attributes in the prototype's schema (with the same dtype, shape, etc.) must be defined in maxschema.
inline (string, optional)
  Upon construction, the construction value must be a dict (or, if "shape" is defined, the construction valie of the current element must be a dict), or else this attribute is ignored
  There are two possibilities.
  1) The value of "inline" is "conditional":
     An ad-hoc conditional is constructed from the contents of the dict ("name" does not need to be defined, but "expression" and attributes for expression values do).
  2)The value of "inline" is the name or extended name of a schema or partial
    In this case, dtype must be a prototype
    The construction value dict is combined with the schema or partial to construct an ad-hoc prototype. As usual, minschema and maxschema rules are applied.
dynamic (bool, optional, default False)
  Indicates that the attribute is dynamic. A dynamic attribute may have client attributes: attributes that depend, through a DAE, upon it. Client attributes cannot be dynamic themselves.
  Dynamic attributes may be topological or non-topological. Topological dynamic property can only be updated by the message system, and any update causes a topology regeneration.
  Non-topological dynamic updates can be updated through the buffer context interface (and sometimes, the instant buffer interface). If they have topological client attributes, their update causes a topology regeneration.
  Client attributes don't have their DAE fully collapsed. Instead, the DAE gets converted to an RAE: a syntax tree of which the leaves are access references to dynamic attributes. Transformers that wish to inspect attribute values should be prepared to encounter RAEs (as do renderers that inspect the topology attributes). For the rest, after transformation, it is the responsibility of the OpenGL binder to deal with them.
allowed_values (array, optional)
  If a list of allowed_values is defined, the attribute's value must be among them
topological (bool, optional)
  By default, floats, ints and bools are considered non-topological attributes, meaning that they can be changed dynamically without triggering a topology update. All other attributes are considered topological. With this attribute, this can be controlled manually. This is especially useful for implementing enums that are controlled through integers, or to set up attributes that are just read by the renderer, not sent to the GPU.
Attribute specifiers are specified within schema definitions (not *declared*, that happens within type schema definitions). DAEs for attribute specifiers are allowed. However, attribute specifiers cannot be dynamic, nor can they be dynamic client attributes. However, for all dynamic arrays, a messaging system is in place (append, delete, insert, etc.), which can change its dtype at runtime. This always leads to a topology regeneration.


Stage 2 (lw.boot.setup_namespaces)
Stage 2 of lightweight default booting sets up the following namespaces:
...

Stage 3 (lw.boot.setup_gpu_types)
Stage 3 of lightweight default booting

After default boot loading, the type schema "gpu_type" is created, adding the following attribute specifiers on top of "type":
- gpu_dtype: enum referring to the GPU storage (half float, normalized integer, short, byte, rgb, etc...). The constructor checks that this is compatible with the shape.
- (buffer mapping parameters, i.e. "persistent"; to be determined)
The constructor interfaces with lw.gpu.buffer_mediator to set up a mapping (persistent or non-persistent). If the mapping is non-persistent (or requires some explicit sync command), only the buffer context interface (not the direct buffer interface) will be supported

Another type schema "vertex_type" is created, adding the following attribute specifiers:
- "per_instance": bool, optional (default=False). If True, refers to per-instance attribute that is made accessible via vertex divisors.

Vertex descriptors are vertex type schemas.
Note that a primitive must have a primary vertex descriptor (containing at least "coordinates" or "indices"), it could have many secondary ones that are stored in different vertex buffers (bound as SSBOs).


1) Schema definitions
    - Globals schema definition
    - Pipeline schema definition
    - Scene schema definition
    - Topology schema definition
This stage happens statically, although incremental definitions are possible. It must be explicitly declared complete, after which it is validated. It can be reset, which completely resets all subsequent stages.

2) Scene definition
    - Definition of topology renderers
    - Prototype definition
    - Scene graph description
    - Definition of globals
The first time, this stage leads to a topology generation. The scene definition can be dynamically updated, which may or may not trigger a regeneration of the topology.
Prototypes must specify if the modification of an attribute's value or shape leads to a topology regeneration. Any update of a prototype definition automatically leads to a topology regeneration. A new topology is generated at most once per frame. Topology regeneration may fail, leading to an exception. If this exception is caught, the old topology will still be used, but changes will still be made to the new scene, and every change will trigger a new attempt to regenerate the topology from the new scene.

3) Topology generation
     - Attribute validation
Validates that for every node, every attribute in its schema has been defined, either by a hard-coded value or a DAE.
     - Node collapse

     - Transformation
Transforms a scene graphs into a topology graph. Topology graphs, after allocation and binding, will be traversed by renderers.
     - Allocator
Allocates all hard values as (CPU) buffers. Inside the rendergraphs, all hard values are replaced by offsets into these buffers. There will be one buffer per datatype/vertextype. The same for dynamic attributes, they go in separate buffers though. In addition, appropriate binderstructs are created, that describe the buffer names.
In case of topology regeneration, a full re-allocation may not be necessary, existing buffers may be reused.
There is only one allocator. It must know how to deal with all elements in the rendergraph.
The allocator is the last stage that generates a human-readable / debuggable node tree.
    - Shader compilation
The OpenGL shader compiler must be a Python class with the right interface. It will be notified when the topology generation (re-)starts, when it ends, it will receive requests to compile shaders. It has to set an attribute that all shaders are ready. Best to implement the class with a daemon running in a different thread, with a different OpenGL context, for async compilation.
Shadercode is a string describing the source code of the shader. This code must be headless, i.e. not contain any declaration of main variables (declaration of extra uniforms that will be set manually in the render function is OK). To make it compatible with any kind of RAE, lwInit() must be called.
TODO: either the shader compiler or the binder will have to deal with RAEs

    - Binder
The binder copies all buffers to OpenGL. Dynamic buffers will be marked as such in OpenGL. In addition, the binderstructs will be augmented with the appropriate OpenGL information. These binderstructs will be fed every frame by the renderers to the bind() function, that will take appropriate action (e.g. loading the appropriate VAO).
Finally, the binder (or the shader compiler!) writes boilerplate shader code for attribute access (including RAEs!).
There is only one binder. It must know how to deal with all elements in the topology graph.

4) Rendering
There is one renderer per pipeline stage (i.e. per topology graph). Renderers receive the globals, the bind function and the entire topology graph.

****
- Attribute validation
- Node elision
Writes a reduced scenegraph

- Attribute binding
 Evaluates all attributes that are not marked as dynamic, collapsing the DAE accordingly
- Pipeline specialization

Prototype expansion

Construction proceeds in the following way:
1) If the value is a string starting with "@", the value is a DAE, to be evaluated later
2) If shape is non-existing, the value is a scalar. For builtin types,
...
Construction in the case of DAEs!



5) Dynamic updates
Dynamic updates can happen in one of three ways:
- The messaging interface
- The direct buffer interface
- The buffer context interface

...

Attribute trees may offer attribute-access-like wrappers around the other interfaces.

Globals can be updated through the messaging interface. During topology generation, it is determined which globals have scene attributes that depend on them. Updates of these globals lead to a topology regeneration. Other globals are used by the renderfuncs. Updating these globals does not lead to a topology regeneration.

Attribute dynamicity (i.e. whether or not an attribute is dynamic) is by itself dynamic. The dynamicity tree can be manipulated through a messaging interface; an attribute tree that wraps it is also built. Changing the dynamicity leads to a topology regeneration.

New renderers can be dynamically registered (but not unregistered) through a messaging interface. The pipeline order and the renderer bindings can be changed dynamically through a messaging interface; an attribute tree that wraps it is also built. This never leads to a topology regeneration.


Fundamental attributes of nodes:
All fundamental attributes are optional. Other attributes of the form __XXX___ are not allowed.

Scene nodes
__passthrough__
  Can have the values "none" (default), "public" or "all"
  If __passthrough__ is not "none", __children__ ...
__children__
  "__children__ = self.children" is the standard way to define this
__handler__
  If a handler is defined, ...
__elide__
  If the  ...

Topology nodes
... (not needed?)



Special attributes
self
parent
_attributes
_passthrough

Schemas, partials and prototypes
A schema is essentially a data struct. There is only one globals schema and one pipeline schema, but any number of schemas can be used in the topology. A topology is a dictionary of arrays. Each array consists of dictionaries that correspond to a scene schema (the same schema for a particular array).
A partial is a curried schema, where some (but not all) of its attributes have been bound. Attributes can be bound statically (with a value), or dynamically (with a DAE). If all attributes have been bound, the partial becomes a prototype. A prototype is essentially an implementation of a schema's constructor.
Partials can only be used to define prototypes and other partials. As a special case, partials can be used to define "children" attributes that support "inline_partial".
Prototypes can only be used inside the scene.





Schemas, partials, prototypes and conditionals cannot be called with reserved keywords.
These are:
conditional
empty
name
parent
partial
prototype
python
schema
self
shadercode
and everything that starts with an underscore

define_type("triangle", {...})
redefine_type("triangle", {"dynamic":True}) #or:
redefine_type("triangle", dict(dynamic=True)) #or:
redefine_type("triangle", dynamic=True)
