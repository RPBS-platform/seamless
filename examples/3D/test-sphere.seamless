{
  "lib": {
    "/cell-filelink-start.py": {
      "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n",
      "links": [
        "links.params_gen_sphere.cell1",
        "links.code_gen_sphere.cell1",
        "links.lines.cell1",
        "links.lines_vertexshader.cell1",
        "links.lines_fragmentshader.cell1",
        "links.tri_vertexshader.cell1",
        "links.tri_fragmentshader.cell1",
        "links.tri.cell1",
        "links.ftri.cell1",
        "links.params_selector.cell1",
        "links.code_selector.cell1"
      ]
    },
    "/gui/cell-basic_display_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_display_float.py": {
      "data": "from seamless.qt.QtWidgets import QDoubleSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QDoubleSpinBox()\nb.setSingleStep(0.1)\nb.setMaximum(1000000)\nb.setValue(PINS.value.get())\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_html.py": {
      "data": "from seamless.qt.QtWidgets import QPlainTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nw.show()\nb = QPlainTextEdit()\nb.setReadOnly(True)\n#b.setFontPointSize(15)\nb.setPlainText(PINS.value.get())\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_html_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setPlainText(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_display_int.py": {
      "data": "from seamless.qt.QtWidgets import QSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QSpinBox()\nb.setMaximum(1000000)\nb.setValue(PINS.value.get())\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_json.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\nimport json\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nw.show()\nb = QTextEdit()\nb.setReadOnly(True)\nb.setFontPointSize(15)\nb.setText(json.dumps(PINS.value.get(), indent=2))\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_json_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(json.dumps(PINS.value.get(), indent=2))\nif PINS.title.updated:\n    b.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_display_text.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nw.show()\nb = QTextEdit()\nb.setReadOnly(True)\nb.setFontPointSize(15)\nb.setText(PINS.value.get())\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_display_text_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_editor_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": [
        "edit.scale.cell4"
      ]
    },
    "/gui/cell-basic_editor_float.py": {
      "data": "from seamless.qt.QtWidgets import QDoubleSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QDoubleSpinBox()\nb.setSingleStep(0.01)\nb.setDecimals(3)\nb.setMaximum(1000000)\nif PINS.value.defined:\n    b.setValue(PINS.value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(PINS.value.set)\n",
      "links": [
        "edit.scale.cell2"
      ]
    },
    "/gui/cell-basic_editor_int.py": {
      "data": "from seamless.qt.QtWidgets import QSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QSpinBox()\nb.setMaximum(1000000)\nif PINS.value.defined:\n    b.setValue(PINS.value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(PINS.value.set)\n",
      "links": [
        "edit.subdivisions.cell3",
        "edit.minimizations.cell3"
      ]
    },
    "/gui/cell-basic_editor_int_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\nif PINS.maximum.updated:\n    b.setMaximum(PINS.maximum.get())\n",
      "links": [
        "edit.subdivisions.cell5",
        "edit.minimizations.cell5"
      ]
    },
    "/gui/cell-basic_editor_json.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\nimport json\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nclass MyTextEdit(QTextEdit):\n    def focusOutEvent(self, event):\n        PINS.value.set(self.toPlainText())\n        QTextEdit.focusOutEvent(self, event)\n\nw.show()\nb = MyTextEdit()\nb.setFontPointSize(15)\nif PINS.value.defined:\n    b.setText(json.dumps(PINS.value.get(), indent=2))\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_editor_json_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(json.dumps(PINS.value.get(), indent=2))\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/cell-basic_editor_text.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(PINS.title.get())\n\nclass MyTextEdit(QTextEdit):\n    def focusOutEvent(self, event):\n        PINS.value.set(self.toPlainText())\n        QTextEdit.focusOutEvent(self, event)\n\nw.show()\nb = MyTextEdit()\nb.setFontPointSize(15)\nif PINS.value.defined:\n    b.setText(PINS.value.get())\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": []
    },
    "/gui/cell-basic_editor_text_UPDATE.py": {
      "data": "if PINS.value.updated:\n    b.setText(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
      "links": []
    },
    "/gui/gl/cell-glprogram.py": {
      "data": "from collections import OrderedDict\nimport numpy as np\nfrom OpenGL.arrays import vbo\nfrom OpenGL.GL import shaders\nfrom OpenGL.GL import *\nfrom OpenGL import GL as gl\n\nfrom seamless import opengl\nfrom seamless.lib.gui.gl.set_uniform import set_uniform\n\nfrom seamless.lib.gui.gl.Renderer import Renderer, VertexAttribute\nfrom seamless.lib.gui.gl import glstate as glstate_module\n\ninitialized = False\nshader_program = None\nrenderer = False\nuniform_types = {}\nuniform_locations = {}\nuniform_values = {}\nuniform_dirty = set()\ntexture_locations = OrderedDict()\nwarnings = []\n\ndef init():\n    global initialized, shader_program, renderer, uniform_types, \\\n     glstate, glclear, texdict\n    from seamless.dtypes.gl import GLStore, GLTexStore\n\n    if initialized:\n        return\n\n    # Compile shaders\n    vertex_code = PINS.vertex_shader.get()\n    fragment_code = PINS.fragment_shader.get()\n    vertex_shader = shaders.compileShader(vertex_code, GL_VERTEX_SHADER)\n    fragment_shader = shaders.compileShader(fragment_code, GL_FRAGMENT_SHADER)\n    shader_program = shaders.compileProgram(vertex_shader, fragment_shader)\n\n    program = PINS.program.get()\n\n    # Bind vertex attributes\n    storedict = {}\n    for ar in program[\"arrays\"]:\n        attr = \"array_\" + ar\n        store = getattr( getattr(PINS, attr), \"store\", None)\n        assert isinstance(store, GLStore), ar #TODO: nicer error message\n        #store.bind() #superfluous\n        storedict[ar] = store\n\n    # Bind textures\n    texdict = {}\n    texture_locations.clear()\n    for ar in program.get(\"textures\",[]):\n        attr = \"array_\" + ar\n        store = getattr( getattr(PINS, attr), \"store\", None)\n        assert isinstance(store, GLTexStore), ar #TODO: nicer error message\n        #store.bind() #superfluous\n        texdict[ar] = store\n        loc = gl.glGetUniformLocation(shader_program, ar)\n        if loc == -1:\n            print(\"WARNING: unknown texture '%s'\" % ar)\n            continue\n        texture_locations[ar] = loc\n\n    # Create renderer and set glstate\n    render = program[\"render\"]\n    glstate = render[\"glstate\"]\n    glclear = glstate.pop(\"clear\", True)\n    renderer = Renderer(render, shader_program, storedict)\n    renderer.bind()\n\n    # Get uniform bindings\n    shaders.glUseProgram(shader_program)\n    uniform_locations.clear()\n    uniform_dirty.clear()\n    uniform_types = program.get(\"uniforms\", {})\n    for uniform in uniform_types:\n        loc = gl.glGetUniformLocation(shader_program, uniform)\n        if loc == -1:\n            print(\"WARNING: unknown uniform '%s'\" % uniform)\n            continue\n        uniform_locations[uniform] = loc\n        uniform_dirty.add(uniform)\n\n    initialized = True\n\ndef paint():\n            #print(\"DRAW\")\n    if not initialized:\n        init()\n    shaders.glUseProgram(shader_program)\n\n    old_warnings = warnings[:]\n    warnings.clear()\n\n    #re-bind the textures every draw, to be safe\n    for texnr, tex in enumerate(texture_locations):\n        gl.glActiveTexture(gl.GL_TEXTURE0+texnr)\n        loc = texture_locations[tex]\n        gl.glUniform1i(loc, texnr)\n        store = texdict[tex]\n        store.bind()\n\n    for uniform in list(uniform_dirty):\n        if uniform not in uniform_locations:\n            continue\n        if uniform not in uniform_types:\n            continue\n        utype = uniform_types[uniform]\n        value = uniform_values.get(uniform, None)\n        if value is None:\n            warnings.append(\"WARNING: unset uniform '%s'\" % uniform)\n            continue\n        loc = uniform_locations[uniform]\n        set_uniform(value, utype, loc)\n        uniform_dirty.remove(uniform)\n\n    glstate_module.set_state(**glstate)\n    if glclear not in (None, False):\n        if glclear == True:\n            glstate_module.clear()\n        else:\n            glstate_module.clear(*glclear)\n    renderer.draw()\n\n    # Heisenbug!!! see below. Seems to be solved now\n    try:\n        warnings\n    except NameError:\n        return\n\n    if warnings != old_warnings:\n        for warning in warnings:\n            print(warning)\n    #print(\"/DRAW\")\n\ndef do_update():\n    global initialized\n\n    \"\"\"\n    Outside of \"init\" and \"paint\", we have to use \"dirty\" flags,\n     rather than direct GL commands!\n    \"\"\"\n\n    updated = set()\n    for attr in PINS.__dict__:\n        pin = getattr(PINS, attr)\n        if hasattr(pin, \"updated\") and pin.updated:\n            updated.add(attr)\n\n\n    arrays = PINS.program.get()[\"arrays\"]\n    textures = PINS.program.get().get(\"textures\", [])\n\n    gl_context = opengl()\n\n    dirty_renderer = False\n    repaint = False\n    for ar in arrays + textures:\n        attr = \"array_\" + ar\n        pin = getattr(PINS, attr)\n        if pin.updated:\n            dirty_renderer = True\n\n    if PINS.init.updated:\n        initialized = False\n        if gl_context:\n            init()\n        else:\n            PINS.init.unclear()\n\n    if PINS.uniforms.updated:\n        new_uniform_values = PINS.uniforms.get()\n        for uniform in new_uniform_values:\n            v_old = uniform_values.get(uniform, None)\n            v_new = new_uniform_values.get(uniform, None)\n            if v_old != v_new:\n                uniform_values[uniform] = v_new\n                uniform_dirty.add(uniform)\n                repaint = True\n\n    if PINS.paint.updated:\n        if gl_context:\n            paint()\n            repaint = False\n        else:\n            repaint = True\n\n    # Heisenbug!!! see test-gl-BUG.py\n    # As of now, seems to be solved, see cell-glwindow.py\n    try:\n        initialized\n    except NameError:\n        import sys\n        msg = \"\"\"seamless/lib/gui/cell-glprogram.py\nSomething has gone wrong, PyQt has corrupted Python's memory\nA crash will now happen... no idea why, sorry\n\"\"\"\n        print(msg, file=sys.stderr)\n        return\n    # /heisenbug\n\n    if PINS.program.updated or \\\n      PINS.vertex_shader.updated or PINS.fragment_shader.updated:\n        initialized = False\n        repaint = True\n\n    if initialized and dirty_renderer:\n        renderer.set_dirty()\n        repaint = True\n\n    if repaint:\n        PINS.repaint.set()\n",
      "links": [
        "lines_program.cell1",
        "tri_program.cell1",
        "ftri_program.cell1"
      ]
    },
    "/gui/gl/cell-glwindow.py": {
      "data": "from seamless.qt.QtWidgets import QOpenGLWidget, QApplication\nfrom seamless.qt.QtCore import Qt\nfrom seamless.qt import QtGui\n\nfrom seamless import add_opengl_context, remove_opengl_context, \\\n activate_opengl, deactivate_opengl\nfrom OpenGL import GL\nimport numpy as np\nfrom math import *\n\ndef length(vec):\n    return sqrt(np.sum(vec*vec))\n\ndef normalize(vec):\n    return vec / length(vec\n    )\n# Camera class, uses code from the camera routines in pyqtgraph's GLViewWidget\nclass Camera:\n    center = np.zeros(3,dtype=\"float\")     ## will always appear at the center of the widget\n    distance = 10.0          ## distance of camera from center\n    fov =  60                ## horizontal field of view in degrees\n    elevation =  30          ## camera's angle of elevation in degrees\n    azimuth = 45             ## camera's azimuthal angle in degrees\n    width = None\n    height = None\n    _loading = False\n\n    #authoritative attributes\n    _attrs1 = ( \"center\", \"distance\", \"fov\",\n              \"elevation\", \"azimuth\", \"width\", \"height\")\n\n    #derived attributes\n    _attrs2 = (\"projection_matrix\", \"modelview_matrix\",\n        \"mvp_matrix\", \"normal_matrix\", \"position\")\n\n    @property\n    def projection_matrix(self):\n        # Xw = (Xnd + 1) * width/2 + X\n        region = (0, 0, self.width, self.height)\n\n        viewport = region #for now\n        x0, y0, w, h = viewport\n        dist = self.distance\n        fov = self.fov\n        nearClip = dist * 0.001\n        farClip = dist * 1000.\n\n        r = nearClip * np.tan(fov * 0.5 * np.pi / 180.)\n        t = r * h / w\n\n        # convert screen coordinates (region) to normalized device coordinates\n        # Xnd = (Xw - X0) * 2/width - 1\n        ## Note that X0 and width in these equations must be the values used in viewport\n        left  = r * ((region[0]-x0) * (2.0/w) - 1)\n        right = r * ((region[0]+region[2]-x0) * (2.0/w) - 1)\n        bottom = t * ((region[1]-y0) * (2.0/h) - 1)\n        top    = t * ((region[1]+region[3]-y0) * (2.0/h) - 1)\n\n        tr = QtGui.QMatrix4x4()\n        tr.frustum(left, right, bottom, top, nearClip, farClip)\n        return np.array(tr.data()).reshape((4,4))\n\n    @property\n    def _modelview_matrix(self):\n        tr = QtGui.QMatrix4x4()\n        tr.translate( 0.0, 0.0, -self.distance)\n        tr.rotate(self.elevation-90, 1, 0, 0)\n        tr.rotate(self.azimuth+90, 0, 0, -1)\n        center = self.center\n        tr.translate(-center[0], -center[1], -center[2])\n        return tr\n\n    @property\n    def modelview_matrix(self):\n        tr = self._modelview_matrix\n        return np.array(tr.data()).reshape((4,4))\n\n    @property\n    def normal_matrix(self):\n        tr = self._modelview_matrix\n        return np.array(tr.normalMatrix().data()).reshape((3,3))\n\n    @property\n    def mvp_matrix(self):\n        mv = self.modelview_matrix\n        p = self.projection_matrix\n        return mv.dot(p)\n\n    @property\n    def position(self):\n        \"\"\"Return current position of camera based on center, dist, elevation, and azimuth\"\"\"\n        center = self.center\n        dist = self.distance\n        elev = self.elevation * pi/180.\n        azim = self.azimuth * pi/180.\n\n        pos = np.array((\n            center[0] + dist * cos(elev) * cos(azim),\n            center[1] + dist * cos(elev) * sin(azim),\n            center[2]  + dist * sin(elev)\n        ))\n        return pos\n\n\n    def __init__(self):\n        self.center = np.zeros(3)\n\n    def _write(self):\n        if self._loading:\n            return\n        data = {}\n        for attr in self._attrs1 + self._attrs2:\n            v = getattr(self, attr)\n            if isinstance(v, np.ndarray):\n                v = v.tolist()\n            data[attr] = v\n        self._data = data\n        PINS.camera.set(data)\n\n    def orbit(self, azim, elev):\n        \"\"\"Orbits the camera around the center position. *azim* and *elev* are given in degrees.\"\"\"\n        self.azimuth += azim\n        self.elevation = float(np.clip(self.elevation + elev, -90, 90))\n        self._write()\n\n    def pan(self, dx, dy, dz, relative=False):\n        \"\"\"\n        Moves the center (look-at) position while holding the camera in place.\n\n        If relative=True, then the coordinates are interpreted such that x\n        if in the global xy plane and points to the right side of the view, y is\n        in the global xy plane and orthogonal to x, and z points in the global z\n        direction. Distances are scaled roughly such that a value of 1.0 moves\n        by one pixel on screen.\n\n        \"\"\"\n        if not relative:\n            self.center += dx, dy, dz\n        else:\n            cPos = self.position\n            cVec = self.center - cPos\n            dist = length(cVec)  ## distance from camera to center\n            xDist = dist * 2. * tan(0.5 * self.fov * pi / 180.)  ## approx. width of view at distance of center point\n            xScale = xDist / self.width\n            zVec = np.array((0,0,1.))\n            xVec = normalize(np.cross(zVec, cVec))\n            yVec = normalize(np.cross(xVec, zVec))\n            self.center += xScale * (xVec * dx + yVec * dy + zVec * dz)\n        self._write()\n\n    def resize(self, width, height):\n        self.width, self.height = width, height\n        self._write()\n\n    def load(self, data):\n        dif = {}\n        try:\n            self._loading = True\n            for at in self._attrs1:\n                curr = getattr(self, at)\n                new = data.get(at, None)\n                if new is not None:\n                    if isinstance(curr, np.ndarray):\n                        curr = curr.tolist()\n                    if curr != new:\n                        dif[at] = new\n        finally:\n            self._loading = False\n        if len(dif):\n            for at in dif:\n                v = dif[at]\n                curr = getattr(self,at)\n                if isinstance(curr, np.ndarray):\n                    curr[:] = np.array(v)\n                else:\n                    setattr(self, at, float(v))\n            self._write()\n\nclass GLWidget(QOpenGLWidget):\n    _initialized = False\n    _destroyed = False\n    _painting = False\n    _updating = False\n    _mousePos = None\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.camera = Camera()\n\n    def initializeGL(self):\n        super().initializeGL()\n        self.camera.width = self.width()\n        self.camera.height = self.height()\n        self.camera._write()\n        activate_opengl()\n        if self._destroyed:\n            return\n        from PyQt5.QtGui import QOpenGLContext\n        #print(\"INIT\")\n        ctx = self.context()\n        assert ctx is QOpenGLContext.currentContext()\n        #print(\"start initializeGL\")\n        if not self._initialized:\n            add_opengl_context(ctx)\n            self._initialized = True\n        PINS.init.set()\n        #print(\"end initializeGL\")\n        deactivate_opengl()\n\n    def resizeGL(self, width, height):\n        super().resizeGL(width, height)\n        if self._destroyed:\n            return\n        GL.glViewport(0, 0, width, height)\n        self.camera.width = width\n        self.camera.height = height\n        self.camera._write()\n        self.update()\n\n    def paintGL(self):\n        activate_opengl()\n        self._painting = True\n        super().paintGL()\n        if self._destroyed:\n            return\n        PINS.paint.set()\n        PINS.painted.set()\n        self._painting = False\n        deactivate_opengl()\n\n    def mousePressEvent(self, ev):\n        self._mousePos = ev.pos()\n\n    def mouseMoveEvent(self, ev):\n        if self._mousePos is None:\n            self._mousePos = ev.pos()\n            return\n        diff = ev.pos() - self._mousePos\n        self._mousePos = ev.pos()\n\n        if ev.buttons() == Qt.LeftButton:\n            self.camera.orbit(-diff.x(), diff.y())\n        elif ev.buttons() == Qt.MidButton:\n            if (ev.modifiers() & Qt.ControlModifier):\n                self.camera.pan(diff.x(), 0, diff.y(), relative=True)\n            else:\n                self.camera.pan(diff.x(), diff.y(), 0, relative=True)\n\n    def keyPressEvent(self, event):\n        key = int(event.key())\n        k = None\n\n        if key >= 32 and key <= 127:\n            k = chr(key)\n        else:\n            for attr in dir(Qt):\n                if not attr.startswith(\"Key_\"):\n                    continue\n                code = getattr(Qt, attr)\n                if code == key:\n                    k = attr[4:]\n                    break\n        if k is None:\n            return\n        PINS.last_key.set(k)\n\n    def destroy(self, *args, **kwargs):\n        self._destroyed = True\n        ctx = self.context()\n        remove_opengl_context(ctx)\n        super().destroy(*args, **kwargs)\n\n    def update(self):\n        #print(\"UPDATE\")\n        super().update()\n\nwidget = GLWidget()\n\ndef do_update():\n    import threading\n    assert threading.current_thread() is threading.main_thread()\n    if widget._destroyed:\n        return\n    if PINS.camera.updated:\n        widget.camera.load(PINS.camera.get())\n    if PINS.update.updated:\n        widget.update()\n    if PINS.title.updated:\n        widget.setWindowTitle(PINS.title.get())\n    if PINS.geometry.updated:\n        widget.setGeometry(*PINS.geometry.get())\n\ndo_update()\nwidget.setMouseTracking(True)\nwidget.show()\n",
      "links": [
        "code.cell18"
      ]
    }
  },
  "macro": [
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": [
        "json",
        "seamless",
        "reactor_params"
      ],
      "module_name": "seamless.core.reactor",
      "func_name": "reactor",
      "code": "@macro(type=(\"json\", \"seamless\", \"reactor_params\"),with_context=False)\ndef reactor(kwargs):\n    from seamless.core.reactor import Reactor #code must be standalone\n    #TODO: remapping, e.g. output_finish, destroy, ...\n    return Reactor(kwargs)\n"
    },
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": [
        "json",
        "seamless",
        "transformer_params"
      ],
      "module_name": "seamless.core.transformer",
      "func_name": "transformer",
      "code": "@macro(type=(\"json\", \"seamless\", \"transformer_params\"), with_context=False)\ndef transformer(kwargs):\n    from seamless.core.transformer import Transformer #code must be standalone\n    #TODO: remapping, e.g. output_finish, destroy, ...\n    return Transformer(kwargs)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": "json",
      "module_name": "seamless.lib.dynamic_html",
      "func_name": "dynamic_html",
      "code": "@macro(\"json\")\ndef dynamic_html(ctx, params):\n    from seamless import reactor\n    from collections import OrderedDict\n    params2 = { \"vars\": OrderedDict(),\n                \"html\": OrderedDict(),\n                \"evals\": OrderedDict()\n              }\n    ed_params = {\n        \"DYNAMIC_HTML_PARAMS\": {\n            \"pin\": \"input\",\n            \"dtype\": \"json\"\n        },\n        \"DYNAMIC_HTML_TEMPLATE\": {\n            \"pin\": \"input\",\n            \"dtype\": \"text\"\n        },\n        \"dynamic_html\": {\n            \"pin\": \"output\",\n            \"dtype\": (\"text\", \"html\")\n        }\n    }\n    assert \"dynamic_html\" not in params\n    for k,v in params.items():\n        assert isinstance(v,dict), k\n        ed_param = {\"pin\": \"input\"}\n        type_ = v[\"type\"]\n        assert type_ in (\"var\", \"html\", \"eval\"), type_\n        if type_ == \"var\":\n            dtype = v.get(\"dtype\")\n            evals = v.get(\"evals\", [])\n            var = v.get(\"var\", k)\n            params2[\"vars\"][k] = (var, evals)\n            ed_param[\"dtype\"] = dtype\n        elif type_ == \"html\":\n            id_ = v.get(\"id\", k)\n            params2[\"html\"][k] = id_\n            ed_param[\"dtype\"] = (\"text\", \"html\")\n        else: #type_ = \"eval\"\n            on_start = v.get(\"on_start\", None)\n            params2[\"evals\"][k] = on_start\n            ed_param[\"dtype\"] = \"text\"\n        ed_params[k] = ed_param\n    for k,v in params2[\"vars\"].items():\n        var, evals = v\n        for e in evals:\n            assert e in params2[\"evals\"], (k, e, list(params2[\"evals\"].keys()))\n    rc = ctx.rc = reactor(ed_params)\n    rc.code_start.cell().fromfile(\"cell-dynamic-html-start.py\")\n    rc.code_update.cell().set(\"update(on_start=False)\")\n    rc.code_stop.cell().set(\"\")\n    rc.DYNAMIC_HTML_PARAMS.cell().set(params2)\n    rc.DYNAMIC_HTML_TEMPLATE.cell().fromfile(\"dynamic-html.jinja\")\n    ctx.export(rc)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": "str",
      "module_name": "seamless.lib.filelink",
      "func_name": "filelink",
      "code": "@macro(\"str\")\ndef filelink(ctx, cell_type):\n    cell_filelink_start = \"cell-filelink-start.py\" #repeat for inline\n    from seamless import reactor\n    pinparams = {\n       \"value\": {\n         \"pin\": \"edit\",\n         \"dtype\": cell_type,\n         \"must_be_defined\": False\n       },\n       \"filepath\" : {\n         \"pin\": \"input\",\n         \"dtype\": \"str\"\n       },\n       \"latency\" : {\n         \"pin\": \"input\",\n         \"dtype\": \"float\"\n       },\n    }\n    rc = ctx.rc = reactor(pinparams)\n    rc.code_start.cell().fromfile(cell_filelink_start)\n    rc.code_update.cell().set(\"write_file(PINS.filepath.get())\")\n    rc.code_stop.cell().set('terminate.set(); t.join()')\n    ctx.export(rc)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "display_type": "str",
        "title": {
          "default": "Basic display",
          "type": "str"
        },
        "_order": [
          "display_type",
          "title"
        ]
      },
      "module_name": "seamless.lib.gui.basic_display",
      "func_name": "basic_display",
      "code": "@macro(OrderedDict((\n    (\"display_type\",\"str\"),\n    (\"title\",{\"type\": \"str\", \"default\": \"Basic display\"})\n)))\ndef basic_display(ctx, display_type, title):\n    from seamless import reactor\n\n    _displays = {\n      \"int\": {\n        \"code\": \"cell-basic_display_int.py\",\n        \"update\": \"cell-basic_display_UPDATE.py\",\n      },\n      \"float\": {\n        \"code\": \"cell-basic_display_float.py\",\n        \"update\": \"cell-basic_display_UPDATE.py\",\n      },\n      \"text\": {\n        \"code\": \"cell-basic_display_text.py\",\n        \"update\": \"cell-basic_display_text_UPDATE.py\",\n      },\n      \"str\": {\n        \"code\": \"cell-basic_display_text.py\",\n        \"update\": \"cell-basic_display_text_UPDATE.py\",\n      },\n      (\"text\", \"html\"): {\n        \"code\": \"cell-basic_display_html.py\",\n        \"update\": \"cell-basic_display_html_UPDATE.py\",\n      },\n      \"json\": {\n        \"code\": \"cell-basic_display_json.py\",\n        \"update\": \"cell-basic_display_json_UPDATE.py\",\n      },\n    }\n\n    def _match_type(type, typelist):\n        typelist = list(typelist)\n        type2 = type\n        if isinstance(type, str):\n            type2 = (type,)\n        typelist2 = []\n        for t in typelist:\n            if isinstance(t, str):\n                typelist2.append((t,))\n            else:\n                typelist2.append(t)\n        matches = []\n        for n in range(len(typelist)):\n            ltype = typelist2[n]\n            k = min(len(type2), len(ltype))\n            if type2[:k] == ltype[:k]:\n                matches.append((n, k))\n        if not len(matches):\n            raise TypeError(\"Cannot find display for cell type '{0}'\".format(type))\n        matches.sort(key=lambda v: -v[1])\n        bestmatch = matches[0][0]\n        return typelist[bestmatch]\n\n    display_type = _match_type(display_type, _displays.keys())\n    pinparams = {\n      \"value\": {\n        \"pin\": \"input\",\n        \"dtype\": display_type\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    d = ctx.display = reactor(pinparams)\n    d.title.cell().set(title)\n    d.code_start.cell().fromfile(_displays[display_type][\"code\"])\n    d.code_stop.cell().set('w.destroy()')\n    upfile = _displays[display_type][\"update\"]\n    c_up = d.code_update.cell()\n    if upfile is not None:\n        c_up.fromfile(upfile)\n    else:\n        c_up.set(\"\")\n    ctx.export(d, forced=[\"title\"])\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "editor_type": "str",
        "title": {
          "default": "Basic editor",
          "type": "str"
        },
        "_order": [
          "editor_type",
          "title"
        ]
      },
      "module_name": "seamless.lib.gui.basic_editor",
      "func_name": "basic_editor",
      "code": "@macro(OrderedDict((\n    (\"editor_type\",\"str\"),\n    (\"title\",{\"type\": \"str\", \"default\": \"Basic editor\"})\n)))\ndef basic_editor(ctx, editor_type, title):\n    from seamless import reactor\n\n    _editors = {\n      \"int\": {\n        \"code\": \"cell-basic_editor_int.py\",\n        \"update\": \"cell-basic_editor_int_UPDATE.py\",\n      },\n      \"float\": {\n        \"code\": \"cell-basic_editor_float.py\",\n        \"update\": \"cell-basic_editor_UPDATE.py\",\n      },\n      \"text\": {\n        \"code\": \"cell-basic_editor_text.py\",\n        \"update\": \"cell-basic_editor_text_UPDATE.py\",\n      },\n      \"json\": {\n        \"code\": \"cell-basic_editor_json.py\",\n        \"update\": \"cell-basic_editor_json_UPDATE.py\",\n      },\n    }\n\n    def _match_type(type, typelist):\n        typelist = list(typelist)\n        type2 = type\n        if isinstance(type, str):\n            type2 = (type,)\n        typelist2 = []\n        for t in typelist:\n            if isinstance(t, str):\n                typelist2.append((t,))\n            else:\n                typelist2.append(t)\n        matches = []\n        for n in range(len(typelist)):\n            ltype = typelist2[n]\n            k = min(len(type2), len(ltype))\n            if type2[:k] == ltype[:k]:\n                matches.append((n, k))\n        if not len(matches):\n            raise TypeError(\"Cannot find editor for cell type '{0}'\".format(type))\n        matches.sort(key=lambda v: -v[1])\n        bestmatch = matches[0][0]\n        return typelist[bestmatch]\n\n    editor_type = _match_type(editor_type, _editors.keys())\n    pinparams = {\n      \"value\": {\n        \"pin\": \"edit\",\n        \"dtype\": editor_type,\n        \"must_be_defined\": False\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    if editor_type == \"int\":\n        pinparams[\"maximum\"] = {\"pin\": \"input\", \"dtype\": \"int\"}\n    rc = ctx.rc = reactor(pinparams)\n    rc.title.cell().set(title)\n    forced = [\"title\"]\n    if editor_type == \"int\":\n        rc.maximum.set(9999999)\n        forced.append(\"maximum\")\n    rc.code_start.cell().fromfile(_editors[editor_type][\"code\"])\n    rc.code_stop.cell().set('w.destroy()')\n    upfile = _editors[editor_type][\"update\"]\n    c_up = rc.code_update.cell(True)\n    if upfile is not None:\n        c_up.fromfile(upfile)\n    else:\n        c_up.set(\"\")\n    ctx.export(rc, forced=forced)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "dtype": {
          "default": [
            "text",
            "html"
          ],
          "type": "dtype"
        },
        "title": {
          "default": "Browser",
          "type": "str"
        },
        "_order": [
          "dtype",
          "title"
        ]
      },
      "module_name": "seamless.lib.gui.browser",
      "func_name": "browser",
      "code": "@macro(OrderedDict((\n    (\"dtype\",{\"type\": \"dtype\", \"default\": (\"text\", \"html\")}),\n    (\"title\",{\"type\": \"str\", \"default\": \"Browser\"})\n)))\ndef browser(ctx, dtype, title):\n    from seamless import reactor\n    assert dtype[:2] == (\"text\", \"html\") #for now...\n    pinparams = {\n      \"value\": {\n        \"pin\": \"edit\",\n        \"dtype\": dtype\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    rc = ctx.rc = reactor(pinparams)\n    rc.title.cell().set(title)\n    rc.code_start.cell().fromfile(\"cell-browser.py\")\n    rc.code_stop.cell().set('widget.destroy()')\n    c_up = rc.code_update.cell(True)\n    c_up.fromfile(\"cell-browser_UPDATE.py\")\n    ctx.export(rc, forced=[\"title\"])\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "program": {
          "type": "json"
        },
        "with_window": {
          "default": true,
          "type": "bool"
        },
        "window_title": {
          "default": "GLProgram",
          "type": "string"
        },
        "_order": [
          "program",
          "with_window",
          "window_title"
        ]
      },
      "module_name": "seamless.lib.gui.gl.glprogram",
      "func_name": "glprogram",
      "code": "@macro(OrderedDict((\n    (\"program\",{\"type\": \"json\"}),\n    (\"with_window\", {\"type\": \"bool\", \"default\": True}),\n    (\"window_title\", {\"type\": \"string\", \"default\": \"GLProgram\"}),\n)))\ndef glprogram(ctx, program, with_window, window_title):\n    from seamless import cell, reactor, macro\n    from seamless.core.worker import ExportedInputPin, ExportedOutputPin, \\\n      ExportedEditPin\n    from seamless.lib.gui.gl.glwindow import glwindow\n\n    arrays = program[\"arrays\"]\n    textures = program.get(\"textures\", [])\n\n    rcparams = {\n\n      #signals\n      \"init\": {\n        \"pin\": \"input\",\n        \"dtype\": \"signal\",\n      },\n      \"paint\": {\n        \"pin\": \"input\",\n        \"dtype\": \"signal\",\n      },\n      \"repaint\": {\n        \"pin\": \"output\",\n        \"dtype\": \"signal\",\n      },\n\n      #shaders\n      \"vertex_shader\": {\n        \"pin\": \"input\",\n        \"dtype\": (\"text\", \"code\", \"vertexshader\"),\n      },\n      \"fragment_shader\": {\n        \"pin\": \"input\",\n        \"dtype\": (\"text\", \"code\", \"fragmentshader\"),\n      },\n\n      #program\n      \"program\": {\n        \"pin\": \"input\",\n        \"dtype\": \"json\",\n      },\n\n      #uniforms\n      \"uniforms\" : {\n        \"pin\": \"input\",\n        \"dtype\": \"json\"\n      }\n    }\n    for ar in arrays:\n        rcparams[\"array_\" + ar] = {\"pin\": \"input\",\"dtype\": \"array\"}\n\n    for ar in textures:\n        assert ar not in program[\"arrays\"], ar\n        rcparams[\"array_\" + ar] = {\"pin\": \"input\",\"dtype\": \"array\"}\n\n    ctx.rcparams = cell(\"json\").set(rcparams)\n    ctx.rc = reactor(ctx.rcparams)\n    ctx.rc.code_start.cell().fromfile(\"cell-glprogram.py\")\n    ctx.rc.code_update.cell().set(\"do_update()\")\n    ctx.rc.code_stop.cell().set(\"\")\n    ctx.rc.program.cell().set(program)\n\n    if with_window:\n        ctx.glwindow = glwindow(window_title)\n        ctx.glwindow.init.cell().connect(ctx.rc.init)\n        ctx.glwindow.paint.cell().connect(ctx.rc.paint)\n        ctx.rc.repaint.cell().connect(ctx.glwindow.update)\n        ctx.update = ExportedInputPin(ctx.glwindow.update)\n        ctx.painted = ExportedOutputPin(ctx.glwindow.painted)\n        ctx.camera = ExportedEditPin(ctx.glwindow.camera)\n        ctx.last_key = ExportedOutputPin(ctx.glwindow.last_key)\n    ctx.export(ctx.rc)\n"
    },
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "title": {
          "default": "OpenGL window",
          "type": "str"
        },
        "size": {
          "default": [
            640,
            480
          ],
          "type": "json"
        },
        "position": {
          "default": [
            0,
            0
          ],
          "type": "json"
        },
        "_order": [
          "title",
          "size",
          "position"
        ]
      },
      "module_name": "seamless.lib.gui.gl.glwindow",
      "func_name": "glwindow",
      "code": "@macro(OrderedDict((\n    (\"title\",{\"type\": \"str\", \"default\": \"OpenGL window\"}),\n    (\"size\", {\"type\": \"json\", \"default\": (640, 480)}),\n    (\"position\", {\"type\": \"json\", \"default\": (0, 0)}),\n)), with_context=False)\ndef glwindow(title, size, position):\n    from seamless import reactor\n    pinparams = {\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\"\n      },\n      \"geometry\": {\n        \"pin\": \"input\",\n        \"dtype\": \"json\"\n      },\n      \"update\": {\n        \"pin\": \"input\",\n        \"dtype\": \"signal\"\n      },\n      \"camera\": {\n        \"pin\": \"edit\",\n        \"dtype\": \"json\",\n        \"must_be_defined\": False\n      },\n      \"init\": {\n        \"pin\": \"output\",\n        \"dtype\": \"signal\",\n      },\n      \"paint\": {\n        \"pin\": \"output\",\n        \"dtype\": \"signal\",\n      },\n      \"painted\": {\n        \"pin\": \"output\",\n        \"dtype\": \"signal\"\n      },\n      \"last_key\": {\n        \"pin\": \"output\",\n        \"dtype\": \"str\"\n      }\n    }\n    rc = reactor(pinparams)\n    rc.title.cell().set(title)\n    geometry = list(position) + list(size)\n    assert len(geometry) == 4, geometry\n    rc.geometry.cell().set(geometry)\n    rc.code_start.cell().fromfile(\"cell-glwindow.py\")\n    rc.code_update.cell().set('do_update()')\n    rc.code_stop.cell().set('widget.destroy()')\n    return rc\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": [
        "json",
        "seamless",
        "transformer_params"
      ],
      "module_name": "seamless.lib.itransformer",
      "func_name": "itransformer",
      "code": "@macro(type=(\"json\", \"seamless\", \"transformer_params\"))\ndef itransformer(ctx, params):\n    from seamless import reactor\n    from seamless.core.worker import ExportedInputPin\n    params2 = params.copy()\n    params2[\"code\"] = {\"pin\": \"input\",\n                        \"dtype\": (\"text\", \"code\", \"ipython\")}\n    params2[\"transformer_params\"] = {\"pin\": \"input\", \"dtype\": \"json\"}\n    params2[\"@shell\"] =  \".namespace\"\n    rc = ctx.rc = reactor(params2)\n    rc.transformer_params.cell().set(params)\n    rc.code_start.cell().fromfile(\"cell-itransformer.py\")\n    rc.code_update.cell().set(\"do_update()\")\n    rc.code_stop.cell().set(\"\")\n    ctx.export(ctx.rc)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "template_definition": "json",
        "output_type": {
          "default": [
            "text",
            "html"
          ],
          "type": "dtype"
        },
        "_order": [
          "template_definition",
          "output_type"
        ]
      },
      "module_name": "seamless.lib.templateer",
      "func_name": "templateer",
      "code": "@macro(OrderedDict((\n  (\"template_definition\", \"json\"),\n  (\"output_type\", {\"type\": \"dtype\", \"default\": (\"text\", \"html\")}),\n)))\ndef templateer(ctx, template_definition, output_type):\n    from seamless import cell, reactor\n    templates = template_definition[\"templates\"]\n    assert isinstance(templates, list)\n    environment = template_definition[\"environment\"]\n    ed_params = {}\n    for t in templates:\n        assert t not in ed_params, t\n        ed_params[t] = {\"pin\": \"input\", \"dtype\": \"text\"}\n    for k,v in environment.items():\n        assert k not in ed_params, k\n        ed_params[k] = {\"pin\": \"input\", \"dtype\": v}\n    ed_params[\"TEMPLATE_DEFINITION\"] = {\"pin\": \"input\", \"dtype\": \"json\"}\n    ed_params[\"RESULT\"] = {\"pin\": \"output\", \"dtype\": output_type}\n    ctx.rc = reactor(ed_params)\n    ctx.rc.TEMPLATE_DEFINITION.cell().set(template_definition)\n    ctx.rc.code_start.cell().fromfile(\"cell-templateer.py\")\n    ctx.rc.code_update.cell().set(\"make_template()\")\n    ctx.rc.code_stop.cell().set(\"\")\n    ctx.export(ctx.rc)\n"
    },
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "period": {
          "default": 0,
          "type": "float"
        },
        "_order": [
          "period"
        ]
      },
      "module_name": "seamless.lib.timer",
      "func_name": "timer",
      "code": "@macro(OrderedDict((\n    (\"period\", {\"type\": \"float\", \"default\": 0}),\n)), with_context=False)\ndef timer(period):\n    from seamless import reactor\n    timer = reactor({\n        \"period\": {\"pin\": \"input\", \"dtype\": \"float\"},\n        \"trigger\": {\"pin\": \"output\", \"dtype\": \"signal\"}\n    })\n    timer.code_start.cell().fromfile(\"cell-timer.py\")\n    timer.code_update.cell().set(\"\")\n    timer.code_stop.cell().set(\"t.cancel(); dead = True\")\n    if period > 0:\n        timer.period.cell().set(period)\n    return timer\n"
    }
  ],
  "main": {
    "type": "context",
    "like_worker": false,
    "like_cell": false,
    "pins": {},
    "auto": [],
    "children": {
      "code": {
        "type": "context",
        "like_worker": false,
        "like_cell": false,
        "pins": {},
        "auto": [
          "cell1",
          "cell10",
          "cell11",
          "cell12",
          "cell13",
          "cell14",
          "cell15",
          "cell16",
          "cell17",
          "cell18",
          "cell19",
          "cell2",
          "cell20",
          "cell21",
          "cell22",
          "cell23",
          "cell24",
          "cell25",
          "cell26",
          "cell27",
          "cell28",
          "cell29",
          "cell3",
          "cell30",
          "cell31",
          "cell32",
          "cell33",
          "cell34",
          "cell35",
          "cell36",
          "cell37",
          "cell38",
          "cell39",
          "cell4",
          "cell40",
          "cell41",
          "cell42",
          "cell5",
          "cell6",
          "cell7",
          "cell8",
          "cell9",
          "signal1",
          "signal2",
          "signal3",
          "signal4",
          "signal5",
          "signal6",
          "signal7"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./params-gen-sphere.cson"
          },
          "cell10": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell11": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": ""
          },
          "cell12": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": ""
          },
          "cell13": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "return scale * input"
          },
          "cell14": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "return scale * input"
          },
          "cell15": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 4
            },
            "data": " ",
            "owner": "window"
          },
          "cell16": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "Seamless OpenGL 3D Example",
            "owner": "window"
          },
          "cell17": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "[\n  0,\n  0,\n  640,\n  480\n]",
            "owner": "window"
          },
          "cell18": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "/gui/gl/cell-glwindow.py",
              "lib": true,
              "mode": 2,
              "save_policy": 1
            },
            "data": "from seamless.qt.QtWidgets import QOpenGLWidget, QApplication\nfrom seamless.qt.QtCore import Qt\nfrom seamless.qt import QtGui\n\nfrom seamless import add_opengl_context, remove_opengl_context, \\\n activate_opengl, deactivate_opengl\nfrom OpenGL import GL\nimport numpy as np\nfrom math import *\n\ndef length(vec):\n    return sqrt(np.sum(vec*vec))\n\ndef normalize(vec):\n    return vec / length(vec\n    )\n# Camera class, uses code from the camera routines in pyqtgraph's GLViewWidget\nclass Camera:\n    center = np.zeros(3,dtype=\"float\")     ## will always appear at the center of the widget\n    distance = 10.0          ## distance of camera from center\n    fov =  60                ## horizontal field of view in degrees\n    elevation =  30          ## camera's angle of elevation in degrees\n    azimuth = 45             ## camera's azimuthal angle in degrees\n    width = None\n    height = None\n    _loading = False\n\n    #authoritative attributes\n    _attrs1 = ( \"center\", \"distance\", \"fov\",\n              \"elevation\", \"azimuth\", \"width\", \"height\")\n\n    #derived attributes\n    _attrs2 = (\"projection_matrix\", \"modelview_matrix\",\n        \"mvp_matrix\", \"normal_matrix\", \"position\")\n\n    @property\n    def projection_matrix(self):\n        # Xw = (Xnd + 1) * width/2 + X\n        region = (0, 0, self.width, self.height)\n\n        viewport = region #for now\n        x0, y0, w, h = viewport\n        dist = self.distance\n        fov = self.fov\n        nearClip = dist * 0.001\n        farClip = dist * 1000.\n\n        r = nearClip * np.tan(fov * 0.5 * np.pi / 180.)\n        t = r * h / w\n\n        # convert screen coordinates (region) to normalized device coordinates\n        # Xnd = (Xw - X0) * 2/width - 1\n        ## Note that X0 and width in these equations must be the values used in viewport\n        left  = r * ((region[0]-x0) * (2.0/w) - 1)\n        right = r * ((region[0]+region[2]-x0) * (2.0/w) - 1)\n        bottom = t * ((region[1]-y0) * (2.0/h) - 1)\n        top    = t * ((region[1]+region[3]-y0) * (2.0/h) - 1)\n\n        tr = QtGui.QMatrix4x4()\n        tr.frustum(left, right, bottom, top, nearClip, farClip)\n        return np.array(tr.data()).reshape((4,4))\n\n    @property\n    def _modelview_matrix(self):\n        tr = QtGui.QMatrix4x4()\n        tr.translate( 0.0, 0.0, -self.distance)\n        tr.rotate(self.elevation-90, 1, 0, 0)\n        tr.rotate(self.azimuth+90, 0, 0, -1)\n        center = self.center\n        tr.translate(-center[0], -center[1], -center[2])\n        return tr\n\n    @property\n    def modelview_matrix(self):\n        tr = self._modelview_matrix\n        return np.array(tr.data()).reshape((4,4))\n\n    @property\n    def normal_matrix(self):\n        tr = self._modelview_matrix\n        return np.array(tr.normalMatrix().data()).reshape((3,3))\n\n    @property\n    def mvp_matrix(self):\n        mv = self.modelview_matrix\n        p = self.projection_matrix\n        return mv.dot(p)\n\n    @property\n    def position(self):\n        \"\"\"Return current position of camera based on center, dist, elevation, and azimuth\"\"\"\n        center = self.center\n        dist = self.distance\n        elev = self.elevation * pi/180.\n        azim = self.azimuth * pi/180.\n\n        pos = np.array((\n            center[0] + dist * cos(elev) * cos(azim),\n            center[1] + dist * cos(elev) * sin(azim),\n            center[2]  + dist * sin(elev)\n        ))\n        return pos\n\n\n    def __init__(self):\n        self.center = np.zeros(3)\n\n    def _write(self):\n        if self._loading:\n            return\n        data = {}\n        for attr in self._attrs1 + self._attrs2:\n            v = getattr(self, attr)\n            if isinstance(v, np.ndarray):\n                v = v.tolist()\n            data[attr] = v\n        self._data = data\n        PINS.camera.set(data)\n\n    def orbit(self, azim, elev):\n        \"\"\"Orbits the camera around the center position. *azim* and *elev* are given in degrees.\"\"\"\n        self.azimuth += azim\n        self.elevation = float(np.clip(self.elevation + elev, -90, 90))\n        self._write()\n\n    def pan(self, dx, dy, dz, relative=False):\n        \"\"\"\n        Moves the center (look-at) position while holding the camera in place.\n\n        If relative=True, then the coordinates are interpreted such that x\n        if in the global xy plane and points to the right side of the view, y is\n        in the global xy plane and orthogonal to x, and z points in the global z\n        direction. Distances are scaled roughly such that a value of 1.0 moves\n        by one pixel on screen.\n\n        \"\"\"\n        if not relative:\n            self.center += dx, dy, dz\n        else:\n            cPos = self.position\n            cVec = self.center - cPos\n            dist = length(cVec)  ## distance from camera to center\n            xDist = dist * 2. * tan(0.5 * self.fov * pi / 180.)  ## approx. width of view at distance of center point\n            xScale = xDist / self.width\n            zVec = np.array((0,0,1.))\n            xVec = normalize(np.cross(zVec, cVec))\n            yVec = normalize(np.cross(xVec, zVec))\n            self.center += xScale * (xVec * dx + yVec * dy + zVec * dz)\n        self._write()\n\n    def resize(self, width, height):\n        self.width, self.height = width, height\n        self._write()\n\n    def load(self, data):\n        dif = {}\n        try:\n            self._loading = True\n            for at in self._attrs1:\n                curr = getattr(self, at)\n                new = data.get(at, None)\n                if new is not None:\n                    if isinstance(curr, np.ndarray):\n                        curr = curr.tolist()\n                    if curr != new:\n                        dif[at] = new\n        finally:\n            self._loading = False\n        if len(dif):\n            for at in dif:\n                v = dif[at]\n                curr = getattr(self,at)\n                if isinstance(curr, np.ndarray):\n                    curr[:] = np.array(v)\n                else:\n                    setattr(self, at, float(v))\n            self._write()\n\nclass GLWidget(QOpenGLWidget):\n    _initialized = False\n    _destroyed = False\n    _painting = False\n    _updating = False\n    _mousePos = None\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.camera = Camera()\n\n    def initializeGL(self):\n        super().initializeGL()\n        self.camera.width = self.width()\n        self.camera.height = self.height()\n        self.camera._write()\n        activate_opengl()\n        if self._destroyed:\n            return\n        from PyQt5.QtGui import QOpenGLContext\n        #print(\"INIT\")\n        ctx = self.context()\n        assert ctx is QOpenGLContext.currentContext()\n        #print(\"start initializeGL\")\n        if not self._initialized:\n            add_opengl_context(ctx)\n            self._initialized = True\n        PINS.init.set()\n        #print(\"end initializeGL\")\n        deactivate_opengl()\n\n    def resizeGL(self, width, height):\n        super().resizeGL(width, height)\n        if self._destroyed:\n            return\n        GL.glViewport(0, 0, width, height)\n        self.camera.width = width\n        self.camera.height = height\n        self.camera._write()\n        self.update()\n\n    def paintGL(self):\n        activate_opengl()\n        self._painting = True\n        super().paintGL()\n        if self._destroyed:\n            return\n        PINS.paint.set()\n        PINS.painted.set()\n        self._painting = False\n        deactivate_opengl()\n\n    def mousePressEvent(self, ev):\n        self._mousePos = ev.pos()\n\n    def mouseMoveEvent(self, ev):\n        if self._mousePos is None:\n            self._mousePos = ev.pos()\n            return\n        diff = ev.pos() - self._mousePos\n        self._mousePos = ev.pos()\n\n        if ev.buttons() == Qt.LeftButton:\n            self.camera.orbit(-diff.x(), diff.y())\n        elif ev.buttons() == Qt.MidButton:\n            if (ev.modifiers() & Qt.ControlModifier):\n                self.camera.pan(diff.x(), 0, diff.y(), relative=True)\n            else:\n                self.camera.pan(diff.x(), diff.y(), 0, relative=True)\n\n    def keyPressEvent(self, event):\n        key = int(event.key())\n        k = None\n\n        if key >= 32 and key <= 127:\n            k = chr(key)\n        else:\n            for attr in dir(Qt):\n                if not attr.startswith(\"Key_\"):\n                    continue\n                code = getattr(Qt, attr)\n                if code == key:\n                    k = attr[4:]\n                    break\n        if k is None:\n            return\n        PINS.last_key.set(k)\n\n    def destroy(self, *args, **kwargs):\n        self._destroyed = True\n        ctx = self.context()\n        remove_opengl_context(ctx)\n        super().destroy(*args, **kwargs)\n\n    def update(self):\n        #print(\"UPDATE\")\n        super().update()\n\nwidget = GLWidget()\n\ndef do_update():\n    import threading\n    assert threading.current_thread() is threading.main_thread()\n    if widget._destroyed:\n        return\n    if PINS.camera.updated:\n        widget.camera.load(PINS.camera.get())\n    if PINS.update.updated:\n        widget.update()\n    if PINS.title.updated:\n        widget.setWindowTitle(PINS.title.get())\n    if PINS.geometry.updated:\n        widget.setGeometry(*PINS.geometry.get())\n\ndo_update()\nwidget.setMouseTracking(True)\nwidget.show()\n",
            "owner": "window"
          },
          "cell19": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "do_update()",
            "owner": "window"
          },
          "cell2": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell20": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "widget.destroy()",
            "owner": "window"
          },
          "cell21": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "\nresult = {\n    \"u_modelview_matrix\": input[\"modelview_matrix\"],\n    \"u_projection_matrix\": input[\"projection_matrix\"],\n    \"u_normal_matrix\": input[\"normal_matrix\"],\n    \"u_mvp_matrix\": input[\"mvp_matrix\"],\n}\nreturn result\n"
          },
          "cell22": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./lines.cson"
          },
          "cell23": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell24": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "hash": "f0c37cdc328ce878b74858a2916903dd"
          },
          "cell25": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./lines.vert"
          },
          "cell26": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell27": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./lines.frag"
          },
          "cell28": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell29": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./triangles.vert"
          },
          "cell3": {
            "dtype": "array",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "hash": "1f7694137181e6d29e0e220494c5659d",
            "owner": "gen_sphere"
          },
          "cell30": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell31": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./triangles.frag"
          },
          "cell32": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell33": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./triangles-smooth.cson"
          },
          "cell34": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell35": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./triangles-flat.cson"
          },
          "cell36": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell37": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./params-selector.cson"
          },
          "cell38": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell39": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "state = 4"
          },
          "cell4": {
            "dtype": "array",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "hash": "0286f070b51224719b7e62909ee34f5b",
            "owner": "gen_sphere"
          },
          "cell40": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": ""
          },
          "cell41": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./cell-selector.py"
          },
          "cell42": {
            "dtype": "float",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "0.2"
          },
          "cell5": {
            "dtype": "array",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "hash": "85c0b7a8d5c26bc01d795c4fa7432abc",
            "owner": "gen_sphere"
          },
          "cell6": {
            "dtype": "array",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "hash": "85c0b7a8d5c26bc01d795c4fa7432abc",
            "owner": "gen_sphere"
          },
          "cell7": {
            "dtype": "array",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "hash": "e28a616dda5bba39cb87f6d465f02b41",
            "owner": "gen_sphere"
          },
          "cell8": {
            "dtype": "array",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "hash": "f850912625e636287ca1443017938ebb",
            "owner": "gen_sphere"
          },
          "cell9": {
            "dtype": "str",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "./cell-gen-sphere.py"
          },
          "gen_sphere": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "./cell-gen-sphere.py",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "import numpy as np\nfrom numpy.linalg import norm\n\nsubdivisions = PINS.subdivisions.get()\nminimizations = PINS.minimizations.get()\n\n# Initialize a tetrahedron\np = 2**-0.5\nf = p\nfp=p*f\ncoordinates = np.array((\n    (f, 0, -fp),\n    (-f, 0, -fp),\n    (0, f, fp),\n    (0, -f, fp)\n), dtype=\"float32\")\nedges = np.array( [(i,j) for i in range(4) for j in range(i+1,4)],\n                    dtype=np.uint16)\nindices = np.array( [[0,1,2], [0,2,3], [0,3,1], [1,3,2] ],\n                    dtype=np.uint16)\n\nfor n in range(subdivisions):\n    offset = len(coordinates)\n\n    # Calculate vertexpair-to-edgeindex mapping\n    edge_map = {(e[0],e[1]): enr for enr,e in enumerate(edges)}\n    edge_map.update( {(e[1],e[0]): enr for enr,e in enumerate(edges)} )\n    # Calculate edge centers\n    edge_coordinates = coordinates[edges.flatten()] \\\n        .reshape((len(edges), 2, 3))\n    edge_centers = np.sum(edge_coordinates,axis=1)/2\n    # Cut all edges in two\n    coordinates = np.concatenate( (coordinates, edge_centers) )\n    edges = np.concatenate((edges, edges))\n    e = np.arange(len(edge_centers)) + offset\n    edges[:len(edge_centers), 1] = e\n    edges[len(edge_centers):, 0] = e\n    #Using the cut edges, replace every triangle by four new ones\n    new_indices = []\n    new_edges = []\n    for triangle_nr, triangle_indices in enumerate(indices):\n        i = triangle_indices\n        e1 = edge_map[i[0], i[1]]\n        e2 = edge_map[i[1], i[2]]\n        e3 = edge_map[i[0], i[2]]\n        ee1 = e1 + offset\n        ee2 = e2 + offset\n        ee3 = e3 + offset\n        new_indices += [\n            [i[0], ee1, ee3],\n            [i[1], ee2, ee1],\n            [i[2], ee3, ee2],\n            [ee1, ee2, ee3],\n        ]\n        new_edges += [\n            [ee1, ee2],\n            [ee2, ee3],\n            [ee3, ee1],\n        ]\n    # Replace the triangle indices, append the edges\n    indices = np.array(new_indices, dtype=np.uint16)\n    new_edges = np.array(new_edges, dtype=np.uint16)\n    edges = np.concatenate( (new_edges, edges) )\n    # After the second subdivision, remove the first 4 vertices,\n    #  and all edges and triangles of which they are a part\n    if n == 1:\n        coordinates = coordinates[4:]\n        edges = edges[np.min(edges,axis=1) >= 4] - 4\n        indices = indices[np.min(indices,axis=1) >= 4] - 4\n        # Seal the 4 gaps\n        new_indices = np.array([\n                [22,23,24],\n                [25,28,26],\n                [27,29,31],\n                [30,33,32],\n            ],dtype=np.uint16) - 4\n        indices = np.concatenate([indices, new_indices ])\n\n# Normalize coordinates\ncoordinates /= norm(coordinates,axis=1)[:,None]\n\n# Minimizations\nfor n in range(minimizations):\n    deltas = np.zeros(coordinates.shape,dtype=\"float32\")\n    edge_coordinates = coordinates[edges.flatten()] \\\n        .reshape((len(edges), 2, 3))\n    edge_diffs = edge_coordinates[:,1,:] - edge_coordinates[:,0,:]\n    edge_lengths = norm(edge_diffs, axis=1)\n    mean_edge = np.mean(edge_lengths)\n    edge_delta = (edge_lengths - mean_edge)/mean_edge\n    for n in range(len(edges)):\n        e1, e2 = edges[n]\n        c1, c2 = coordinates[e1], coordinates[e2]\n        d = c2 - c1\n        edelta = edge_delta[n]\n        offset = 0.2 * edelta * d\n        deltas[e1] += offset\n        deltas[e2] -= offset\n    coordinates += deltas\n    coordinates /= norm(coordinates,axis=1)[:,None]\n\n# Normals\nnormals = coordinates #identical in a sphere\n\n# Beyond here, the code is no longer specific to spheres\n\n# Calculate triangle coordinates and normals\ntriangle_indices = indices.flatten()\nc = triangle_coordinates = coordinates[triangle_indices] \\\n    .reshape(indices.shape+(3,))\nv1 = c[:,1] - c[:,0]\nv1 /= norm(v1,axis=1)[:,None]\nv2 = c[:,2] - c[:,0]\nv2 /= norm(v2,axis=1)[:,None]\ntriangle_normals = np.cross(v1, v2)\n#FIX: sphere subdivision+minimization ometimes leads to strange triangles with wrong normals\n#The following sets the correct normal for a sphere\ntriangle_normals = np.sum(c, axis=1)/3\n#/FIX\ntriangle_normals /= norm(triangle_normals, axis=1)[:, None]\ntriangle_normals = np.repeat(triangle_normals, 3, axis=0)\ntriangle_coordinates = triangle_coordinates.reshape(\n    (len(triangle_indices), 3) )\n\n# Write out arrays\nPINS.coordinates.set(coordinates)\nPINS.normals.set(normals)\nPINS.edges.set(edges.flatten())\nPINS.triangle_indices.set(triangle_indices)\nPINS.triangle_coordinates.set(triangle_coordinates)\nPINS.triangle_normals.set(triangle_normals)\n"
          },
          "selector": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "./cell-selector.py",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "if PINS.key.updated:\n    k = PINS.key.get()\n    try:\n        v = int(k)\n    except ValueError:\n        pass\n    else:\n        if v in (1,2,3,4):\n            state = v\n    PINS.repaint.set()\n\nif PINS.paint.updated:\n    if state == 1:\n        PINS.paint_lines.set()\n    elif state == 2:\n        PINS.paint_triangles_flat.set()\n    elif state == 3:\n        PINS.paint_lines.set()\n        PINS.paint_triangles_flat.set()\n    elif state == 4:\n        PINS.paint_triangles_smooth.set()\n"
          },
          "signal1": {
            "dtype": "signal",
            "owner": "window"
          },
          "signal2": {
            "dtype": "signal",
            "owner": "window"
          },
          "signal3": {
            "dtype": "signal",
            "owner": "window"
          },
          "signal4": {
            "dtype": "signal",
            "owner": "selector"
          },
          "signal5": {
            "dtype": "signal",
            "owner": "selector"
          },
          "signal6": {
            "dtype": "signal",
            "owner": "selector"
          },
          "signal7": {
            "dtype": "signal",
            "owner": "selector"
          }
        }
      },
      "coordinates": {
        "dtype": "array",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "hash": "fb5e3ab232d7fd35e67e78ee7f515657",
        "store": {
          "mode": "GL",
          "params": {}
        }
      },
      "coordinates_prescale": {
        "dtype": "array",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "hash": "85c0b7a8d5c26bc01d795c4fa7432abc"
      },
      "do_scale": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "input": {
            "dtype": "array",
            "pin": "input"
          },
          "output": {
            "dtype": "array",
            "pin": "output"
          },
          "scale": {
            "dtype": "float",
            "pin": "input"
          }
        }
      },
      "do_scale2": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "input": {
            "dtype": "array",
            "pin": "input"
          },
          "output": {
            "dtype": "array",
            "pin": "output"
          },
          "scale": {
            "dtype": "float",
            "pin": "input"
          }
        }
      },
      "edges": {
        "dtype": "array",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "hash": "1f7694137181e6d29e0e220494c5659d",
        "store": {
          "mode": "GL",
          "params": {}
        }
      },
      "edit": {
        "type": "context",
        "like_worker": false,
        "like_cell": false,
        "pins": {},
        "auto": [],
        "children": {
          "minimizations": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "maximum": [
                "ExportedInputPin",
                "edit.minimizations.rc.maximum"
              ],
              "title": [
                "ExportedInputPin",
                "edit.minimizations.rc.title"
              ],
              "value": [
                "ExportedEditPin",
                "edit.minimizations.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3",
              "cell4",
              "cell5"
            ],
            "children": {
              "cell1": {
                "dtype": "str",
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "Minimizations"
              },
              "cell2": {
                "dtype": "int",
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "100"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/gui/cell-basic_editor_int.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "from seamless.qt.QtWidgets import QSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QSpinBox()\nb.setMaximum(1000000)\nif PINS.value.defined:\n    b.setValue(PINS.value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(PINS.value.set)\n"
              },
              "cell4": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "w.destroy()"
              },
              "cell5": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/gui/cell-basic_editor_int_UPDATE.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\nif PINS.maximum.updated:\n    b.setMaximum(PINS.maximum.get())\n",
                "owner": "edit.minimizations.rc.code_update"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "maximum": {
                    "dtype": "int",
                    "pin": "input"
                  },
                  "title": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "int",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "scale": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "title": [
                "ExportedInputPin",
                "edit.scale.rc.title"
              ],
              "value": [
                "ExportedEditPin",
                "edit.scale.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3",
              "cell4"
            ],
            "children": {
              "cell1": {
                "dtype": "str",
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "Scale"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/gui/cell-basic_editor_float.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "from seamless.qt.QtWidgets import QDoubleSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QDoubleSpinBox()\nb.setSingleStep(0.01)\nb.setDecimals(3)\nb.setMaximum(1000000)\nif PINS.value.defined:\n    b.setValue(PINS.value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(PINS.value.set)\n"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "w.destroy()"
              },
              "cell4": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/gui/cell-basic_editor_UPDATE.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\n",
                "owner": "edit.scale.rc.code_update"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "title": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "float",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "subdivisions": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "maximum": [
                "ExportedInputPin",
                "edit.subdivisions.rc.maximum"
              ],
              "title": [
                "ExportedInputPin",
                "edit.subdivisions.rc.title"
              ],
              "value": [
                "ExportedEditPin",
                "edit.subdivisions.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3",
              "cell4",
              "cell5"
            ],
            "children": {
              "cell1": {
                "dtype": "str",
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "Subdivisions"
              },
              "cell2": {
                "dtype": "int",
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "7"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/gui/cell-basic_editor_int.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "from seamless.qt.QtWidgets import QSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(PINS.title.get())\nw.show()\nb = QSpinBox()\nb.setMaximum(1000000)\nif PINS.value.defined:\n    b.setValue(PINS.value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(PINS.value.set)\n"
              },
              "cell4": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "w.destroy()"
              },
              "cell5": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/gui/cell-basic_editor_int_UPDATE.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if PINS.value.updated:\n    b.setValue(PINS.value.get())\nif PINS.title.updated:\n    w.setWindowTitle(PINS.title.get())\nif PINS.maximum.updated:\n    b.setMaximum(PINS.maximum.get())\n",
                "owner": "edit.subdivisions.rc.code_update"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "maximum": {
                    "dtype": "int",
                    "pin": "input"
                  },
                  "title": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "int",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          }
        }
      },
      "ftri_program": {
        "type": "context",
        "like_worker": true,
        "like_cell": false,
        "pins": {
          "array_coordinates": [
            "ExportedInputPin",
            "ftri_program.rc.array_coordinates"
          ],
          "array_normals": [
            "ExportedInputPin",
            "ftri_program.rc.array_normals"
          ],
          "fragment_shader": [
            "ExportedInputPin",
            "ftri_program.rc.fragment_shader"
          ],
          "init": [
            "ExportedInputPin",
            "ftri_program.rc.init"
          ],
          "paint": [
            "ExportedInputPin",
            "ftri_program.rc.paint"
          ],
          "repaint": [
            "ExportedOutputPin",
            "ftri_program.rc.repaint"
          ],
          "uniforms": [
            "ExportedInputPin",
            "ftri_program.rc.uniforms"
          ],
          "vertex_shader": [
            "ExportedInputPin",
            "ftri_program.rc.vertex_shader"
          ]
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4",
          "signal1"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "/gui/gl/cell-glprogram.py",
              "lib": true,
              "mode": 2,
              "save_policy": 1
            },
            "data": "from collections import OrderedDict\nimport numpy as np\nfrom OpenGL.arrays import vbo\nfrom OpenGL.GL import shaders\nfrom OpenGL.GL import *\nfrom OpenGL import GL as gl\n\nfrom seamless import opengl\nfrom seamless.lib.gui.gl.set_uniform import set_uniform\n\nfrom seamless.lib.gui.gl.Renderer import Renderer, VertexAttribute\nfrom seamless.lib.gui.gl import glstate as glstate_module\n\ninitialized = False\nshader_program = None\nrenderer = False\nuniform_types = {}\nuniform_locations = {}\nuniform_values = {}\nuniform_dirty = set()\ntexture_locations = OrderedDict()\nwarnings = []\n\ndef init():\n    global initialized, shader_program, renderer, uniform_types, \\\n     glstate, glclear, texdict\n    from seamless.dtypes.gl import GLStore, GLTexStore\n\n    if initialized:\n        return\n\n    # Compile shaders\n    vertex_code = PINS.vertex_shader.get()\n    fragment_code = PINS.fragment_shader.get()\n    vertex_shader = shaders.compileShader(vertex_code, GL_VERTEX_SHADER)\n    fragment_shader = shaders.compileShader(fragment_code, GL_FRAGMENT_SHADER)\n    shader_program = shaders.compileProgram(vertex_shader, fragment_shader)\n\n    program = PINS.program.get()\n\n    # Bind vertex attributes\n    storedict = {}\n    for ar in program[\"arrays\"]:\n        attr = \"array_\" + ar\n        store = getattr( getattr(PINS, attr), \"store\", None)\n        assert isinstance(store, GLStore), ar #TODO: nicer error message\n        #store.bind() #superfluous\n        storedict[ar] = store\n\n    # Bind textures\n    texdict = {}\n    texture_locations.clear()\n    for ar in program.get(\"textures\",[]):\n        attr = \"array_\" + ar\n        store = getattr( getattr(PINS, attr), \"store\", None)\n        assert isinstance(store, GLTexStore), ar #TODO: nicer error message\n        #store.bind() #superfluous\n        texdict[ar] = store\n        loc = gl.glGetUniformLocation(shader_program, ar)\n        if loc == -1:\n            print(\"WARNING: unknown texture '%s'\" % ar)\n            continue\n        texture_locations[ar] = loc\n\n    # Create renderer and set glstate\n    render = program[\"render\"]\n    glstate = render[\"glstate\"]\n    glclear = glstate.pop(\"clear\", True)\n    renderer = Renderer(render, shader_program, storedict)\n    renderer.bind()\n\n    # Get uniform bindings\n    shaders.glUseProgram(shader_program)\n    uniform_locations.clear()\n    uniform_dirty.clear()\n    uniform_types = program.get(\"uniforms\", {})\n    for uniform in uniform_types:\n        loc = gl.glGetUniformLocation(shader_program, uniform)\n        if loc == -1:\n            print(\"WARNING: unknown uniform '%s'\" % uniform)\n            continue\n        uniform_locations[uniform] = loc\n        uniform_dirty.add(uniform)\n\n    initialized = True\n\ndef paint():\n            #print(\"DRAW\")\n    if not initialized:\n        init()\n    shaders.glUseProgram(shader_program)\n\n    old_warnings = warnings[:]\n    warnings.clear()\n\n    #re-bind the textures every draw, to be safe\n    for texnr, tex in enumerate(texture_locations):\n        gl.glActiveTexture(gl.GL_TEXTURE0+texnr)\n        loc = texture_locations[tex]\n        gl.glUniform1i(loc, texnr)\n        store = texdict[tex]\n        store.bind()\n\n    for uniform in list(uniform_dirty):\n        if uniform not in uniform_locations:\n            continue\n        if uniform not in uniform_types:\n            continue\n        utype = uniform_types[uniform]\n        value = uniform_values.get(uniform, None)\n        if value is None:\n            warnings.append(\"WARNING: unset uniform '%s'\" % uniform)\n            continue\n        loc = uniform_locations[uniform]\n        set_uniform(value, utype, loc)\n        uniform_dirty.remove(uniform)\n\n    glstate_module.set_state(**glstate)\n    if glclear not in (None, False):\n        if glclear == True:\n            glstate_module.clear()\n        else:\n            glstate_module.clear(*glclear)\n    renderer.draw()\n\n    # Heisenbug!!! see below. Seems to be solved now\n    try:\n        warnings\n    except NameError:\n        return\n\n    if warnings != old_warnings:\n        for warning in warnings:\n            print(warning)\n    #print(\"/DRAW\")\n\ndef do_update():\n    global initialized\n\n    \"\"\"\n    Outside of \"init\" and \"paint\", we have to use \"dirty\" flags,\n     rather than direct GL commands!\n    \"\"\"\n\n    updated = set()\n    for attr in PINS.__dict__:\n        pin = getattr(PINS, attr)\n        if hasattr(pin, \"updated\") and pin.updated:\n            updated.add(attr)\n\n\n    arrays = PINS.program.get()[\"arrays\"]\n    textures = PINS.program.get().get(\"textures\", [])\n\n    gl_context = opengl()\n\n    dirty_renderer = False\n    repaint = False\n    for ar in arrays + textures:\n        attr = \"array_\" + ar\n        pin = getattr(PINS, attr)\n        if pin.updated:\n            dirty_renderer = True\n\n    if PINS.init.updated:\n        initialized = False\n        if gl_context:\n            init()\n        else:\n            PINS.init.unclear()\n\n    if PINS.uniforms.updated:\n        new_uniform_values = PINS.uniforms.get()\n        for uniform in new_uniform_values:\n            v_old = uniform_values.get(uniform, None)\n            v_new = new_uniform_values.get(uniform, None)\n            if v_old != v_new:\n                uniform_values[uniform] = v_new\n                uniform_dirty.add(uniform)\n                repaint = True\n\n    if PINS.paint.updated:\n        if gl_context:\n            paint()\n            repaint = False\n        else:\n            repaint = True\n\n    # Heisenbug!!! see test-gl-BUG.py\n    # As of now, seems to be solved, see cell-glwindow.py\n    try:\n        initialized\n    except NameError:\n        import sys\n        msg = \"\"\"seamless/lib/gui/cell-glprogram.py\nSomething has gone wrong, PyQt has corrupted Python's memory\nA crash will now happen... no idea why, sorry\n\"\"\"\n        print(msg, file=sys.stderr)\n        return\n    # /heisenbug\n\n    if PINS.program.updated or \\\n      PINS.vertex_shader.updated or PINS.fragment_shader.updated:\n        initialized = False\n        repaint = True\n\n    if initialized and dirty_renderer:\n        renderer.set_dirty()\n        repaint = True\n\n    if repaint:\n        PINS.repaint.set()\n"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "do_update()"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": ""
          },
          "cell4": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "{\n  \"arrays\": [\n    \"coordinates\",\n    \"normals\"\n  ],\n  \"render\": {\n    \"attributes\": {\n      \"a_normal\": {\n        \"dtype\": \"vec3\",\n        \"array\": \"normals\"\n      },\n      \"a_position\": {\n        \"dtype\": \"vec3\",\n        \"array\": \"coordinates\"\n      }\n    },\n    \"command\": \"triangles\",\n    \"glstate\": {\n      \"blend\": true,\n      \"depth_test\": true,\n      \"cull_face\": true,\n      \"clear_color\": \"black\",\n      \"clear\": false\n    }\n  },\n  \"uniforms\": {\n    \"u_normal_matrix\": \"mat3\",\n    \"u_mvp_matrix\": \"mat4\",\n    \"u_modelview_matrix\": \"mat4\"\n  }\n}"
          },
          "rc": {
            "type": "reactor",
            "mode": "sync",
            "params": {
              "array_coordinates": {
                "dtype": "array",
                "pin": "input"
              },
              "array_normals": {
                "dtype": "array",
                "pin": "input"
              },
              "fragment_shader": {
                "dtype": [
                  "text",
                  "code",
                  "fragmentshader"
                ],
                "pin": "input"
              },
              "init": {
                "dtype": "signal",
                "pin": "input"
              },
              "paint": {
                "dtype": "signal",
                "pin": "input"
              },
              "program": {
                "dtype": "json",
                "pin": "input"
              },
              "repaint": {
                "dtype": "signal",
                "pin": "output"
              },
              "uniforms": {
                "dtype": "json",
                "pin": "input"
              },
              "vertex_shader": {
                "dtype": [
                  "text",
                  "code",
                  "vertexshader"
                ],
                "pin": "input"
              }
            }
          },
          "rcparams": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "{\n  \"repaint\": {\n    \"dtype\": \"signal\",\n    \"pin\": \"output\"\n  },\n  \"array_coordinates\": {\n    \"dtype\": \"array\",\n    \"pin\": \"input\"\n  },\n  \"paint\": {\n    \"dtype\": \"signal\",\n    \"pin\": \"input\"\n  },\n  \"init\": {\n    \"dtype\": \"signal\",\n    \"pin\": \"input\"\n  },\n  \"vertex_shader\": {\n    \"dtype\": [\n      \"text\",\n      \"code\",\n      \"vertexshader\"\n    ],\n    \"pin\": \"input\"\n  },\n  \"uniforms\": {\n    \"dtype\": \"json\",\n    \"pin\": \"input\"\n  },\n  \"array_normals\": {\n    \"dtype\": \"array\",\n    \"pin\": \"input\"\n  },\n  \"program\": {\n    \"dtype\": \"json\",\n    \"pin\": \"input\"\n  },\n  \"fragment_shader\": {\n    \"dtype\": [\n      \"text\",\n      \"code\",\n      \"fragmentshader\"\n    ],\n    \"pin\": \"input\"\n  }\n}"
          },
          "signal1": {
            "dtype": "signal",
            "owner": "ftri_program.rc"
          }
        }
      },
      "gen_sphere": {
        "type": "reactor",
        "mode": "sync",
        "params": {
          "coordinates": {
            "dtype": "array",
            "pin": "output"
          },
          "edges": {
            "dtype": "array",
            "pin": "output"
          },
          "minimizations": {
            "dtype": "int",
            "pin": "input"
          },
          "normals": {
            "dtype": "array",
            "pin": "output"
          },
          "subdivisions": {
            "dtype": "int",
            "pin": "input"
          },
          "triangle_coordinates": {
            "dtype": "array",
            "pin": "output"
          },
          "triangle_indices": {
            "dtype": "array",
            "pin": "output"
          },
          "triangle_normals": {
            "dtype": "array",
            "pin": "output"
          }
        }
      },
      "gen_uniforms": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "input": {
            "dtype": "json",
            "pin": "input"
          },
          "output": {
            "dtype": "json",
            "pin": "output"
          }
        }
      },
      "lines_fragmentshader": {
        "dtype": [
          "text",
          "code",
          "fragmentshader"
        ],
        "resource": {
          "filepath": "./lines.frag",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "data": "varying float fade_factor;\nvoid main() {\n  gl_FragColor = vec4(1.0,1.0,1.0,1.0) * fade_factor;\n\n}\n"
      },
      "lines_program": {
        "type": "context",
        "like_worker": true,
        "like_cell": false,
        "pins": {
          "array_coordinates": [
            "ExportedInputPin",
            "lines_program.rc.array_coordinates"
          ],
          "array_edges": [
            "ExportedInputPin",
            "lines_program.rc.array_edges"
          ],
          "fragment_shader": [
            "ExportedInputPin",
            "lines_program.rc.fragment_shader"
          ],
          "init": [
            "ExportedInputPin",
            "lines_program.rc.init"
          ],
          "paint": [
            "ExportedInputPin",
            "lines_program.rc.paint"
          ],
          "repaint": [
            "ExportedOutputPin",
            "lines_program.rc.repaint"
          ],
          "uniforms": [
            "ExportedInputPin",
            "lines_program.rc.uniforms"
          ],
          "vertex_shader": [
            "ExportedInputPin",
            "lines_program.rc.vertex_shader"
          ]
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4",
          "signal1"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "/gui/gl/cell-glprogram.py",
              "lib": true,
              "mode": 2,
              "save_policy": 1
            },
            "data": "from collections import OrderedDict\nimport numpy as np\nfrom OpenGL.arrays import vbo\nfrom OpenGL.GL import shaders\nfrom OpenGL.GL import *\nfrom OpenGL import GL as gl\n\nfrom seamless import opengl\nfrom seamless.lib.gui.gl.set_uniform import set_uniform\n\nfrom seamless.lib.gui.gl.Renderer import Renderer, VertexAttribute\nfrom seamless.lib.gui.gl import glstate as glstate_module\n\ninitialized = False\nshader_program = None\nrenderer = False\nuniform_types = {}\nuniform_locations = {}\nuniform_values = {}\nuniform_dirty = set()\ntexture_locations = OrderedDict()\nwarnings = []\n\ndef init():\n    global initialized, shader_program, renderer, uniform_types, \\\n     glstate, glclear, texdict\n    from seamless.dtypes.gl import GLStore, GLTexStore\n\n    if initialized:\n        return\n\n    # Compile shaders\n    vertex_code = PINS.vertex_shader.get()\n    fragment_code = PINS.fragment_shader.get()\n    vertex_shader = shaders.compileShader(vertex_code, GL_VERTEX_SHADER)\n    fragment_shader = shaders.compileShader(fragment_code, GL_FRAGMENT_SHADER)\n    shader_program = shaders.compileProgram(vertex_shader, fragment_shader)\n\n    program = PINS.program.get()\n\n    # Bind vertex attributes\n    storedict = {}\n    for ar in program[\"arrays\"]:\n        attr = \"array_\" + ar\n        store = getattr( getattr(PINS, attr), \"store\", None)\n        assert isinstance(store, GLStore), ar #TODO: nicer error message\n        #store.bind() #superfluous\n        storedict[ar] = store\n\n    # Bind textures\n    texdict = {}\n    texture_locations.clear()\n    for ar in program.get(\"textures\",[]):\n        attr = \"array_\" + ar\n        store = getattr( getattr(PINS, attr), \"store\", None)\n        assert isinstance(store, GLTexStore), ar #TODO: nicer error message\n        #store.bind() #superfluous\n        texdict[ar] = store\n        loc = gl.glGetUniformLocation(shader_program, ar)\n        if loc == -1:\n            print(\"WARNING: unknown texture '%s'\" % ar)\n            continue\n        texture_locations[ar] = loc\n\n    # Create renderer and set glstate\n    render = program[\"render\"]\n    glstate = render[\"glstate\"]\n    glclear = glstate.pop(\"clear\", True)\n    renderer = Renderer(render, shader_program, storedict)\n    renderer.bind()\n\n    # Get uniform bindings\n    shaders.glUseProgram(shader_program)\n    uniform_locations.clear()\n    uniform_dirty.clear()\n    uniform_types = program.get(\"uniforms\", {})\n    for uniform in uniform_types:\n        loc = gl.glGetUniformLocation(shader_program, uniform)\n        if loc == -1:\n            print(\"WARNING: unknown uniform '%s'\" % uniform)\n            continue\n        uniform_locations[uniform] = loc\n        uniform_dirty.add(uniform)\n\n    initialized = True\n\ndef paint():\n            #print(\"DRAW\")\n    if not initialized:\n        init()\n    shaders.glUseProgram(shader_program)\n\n    old_warnings = warnings[:]\n    warnings.clear()\n\n    #re-bind the textures every draw, to be safe\n    for texnr, tex in enumerate(texture_locations):\n        gl.glActiveTexture(gl.GL_TEXTURE0+texnr)\n        loc = texture_locations[tex]\n        gl.glUniform1i(loc, texnr)\n        store = texdict[tex]\n        store.bind()\n\n    for uniform in list(uniform_dirty):\n        if uniform not in uniform_locations:\n            continue\n        if uniform not in uniform_types:\n            continue\n        utype = uniform_types[uniform]\n        value = uniform_values.get(uniform, None)\n        if value is None:\n            warnings.append(\"WARNING: unset uniform '%s'\" % uniform)\n            continue\n        loc = uniform_locations[uniform]\n        set_uniform(value, utype, loc)\n        uniform_dirty.remove(uniform)\n\n    glstate_module.set_state(**glstate)\n    if glclear not in (None, False):\n        if glclear == True:\n            glstate_module.clear()\n        else:\n            glstate_module.clear(*glclear)\n    renderer.draw()\n\n    # Heisenbug!!! see below. Seems to be solved now\n    try:\n        warnings\n    except NameError:\n        return\n\n    if warnings != old_warnings:\n        for warning in warnings:\n            print(warning)\n    #print(\"/DRAW\")\n\ndef do_update():\n    global initialized\n\n    \"\"\"\n    Outside of \"init\" and \"paint\", we have to use \"dirty\" flags,\n     rather than direct GL commands!\n    \"\"\"\n\n    updated = set()\n    for attr in PINS.__dict__:\n        pin = getattr(PINS, attr)\n        if hasattr(pin, \"updated\") and pin.updated:\n            updated.add(attr)\n\n\n    arrays = PINS.program.get()[\"arrays\"]\n    textures = PINS.program.get().get(\"textures\", [])\n\n    gl_context = opengl()\n\n    dirty_renderer = False\n    repaint = False\n    for ar in arrays + textures:\n        attr = \"array_\" + ar\n        pin = getattr(PINS, attr)\n        if pin.updated:\n            dirty_renderer = True\n\n    if PINS.init.updated:\n        initialized = False\n        if gl_context:\n            init()\n        else:\n            PINS.init.unclear()\n\n    if PINS.uniforms.updated:\n        new_uniform_values = PINS.uniforms.get()\n        for uniform in new_uniform_values:\n            v_old = uniform_values.get(uniform, None)\n            v_new = new_uniform_values.get(uniform, None)\n            if v_old != v_new:\n                uniform_values[uniform] = v_new\n                uniform_dirty.add(uniform)\n                repaint = True\n\n    if PINS.paint.updated:\n        if gl_context:\n            paint()\n            repaint = False\n        else:\n            repaint = True\n\n    # Heisenbug!!! see test-gl-BUG.py\n    # As of now, seems to be solved, see cell-glwindow.py\n    try:\n        initialized\n    except NameError:\n        import sys\n        msg = \"\"\"seamless/lib/gui/cell-glprogram.py\nSomething has gone wrong, PyQt has corrupted Python's memory\nA crash will now happen... no idea why, sorry\n\"\"\"\n        print(msg, file=sys.stderr)\n        return\n    # /heisenbug\n\n    if PINS.program.updated or \\\n      PINS.vertex_shader.updated or PINS.fragment_shader.updated:\n        initialized = False\n        repaint = True\n\n    if initialized and dirty_renderer:\n        renderer.set_dirty()\n        repaint = True\n\n    if repaint:\n        PINS.repaint.set()\n"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "do_update()"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": ""
          },
          "cell4": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "{\n  \"arrays\": [\n    \"coordinates\",\n    \"edges\"\n  ],\n  \"render\": {\n    \"attributes\": {\n      \"a_position\": {\n        \"dtype\": \"vec3\",\n        \"array\": \"coordinates\"\n      }\n    },\n    \"command\": \"lines\",\n    \"glstate\": {\n      \"multisample\": true,\n      \"depth_test\": true,\n      \"clear_color\": \"black\",\n      \"clear\": true,\n      \"blend\": true,\n      \"line_width\": 1\n    },\n    \"indices\": {\n      \"array\": \"edges\",\n      \"dtype\": \"short\"\n    }\n  },\n  \"uniforms\": {\n    \"u_mvp_matrix\": \"mat4\",\n    \"u_modelview_matrix\": \"mat4\"\n  }\n}"
          },
          "rc": {
            "type": "reactor",
            "mode": "sync",
            "params": {
              "array_coordinates": {
                "dtype": "array",
                "pin": "input"
              },
              "array_edges": {
                "dtype": "array",
                "pin": "input"
              },
              "fragment_shader": {
                "dtype": [
                  "text",
                  "code",
                  "fragmentshader"
                ],
                "pin": "input"
              },
              "init": {
                "dtype": "signal",
                "pin": "input"
              },
              "paint": {
                "dtype": "signal",
                "pin": "input"
              },
              "program": {
                "dtype": "json",
                "pin": "input"
              },
              "repaint": {
                "dtype": "signal",
                "pin": "output"
              },
              "uniforms": {
                "dtype": "json",
                "pin": "input"
              },
              "vertex_shader": {
                "dtype": [
                  "text",
                  "code",
                  "vertexshader"
                ],
                "pin": "input"
              }
            }
          },
          "rcparams": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "{\n  \"repaint\": {\n    \"dtype\": \"signal\",\n    \"pin\": \"output\"\n  },\n  \"array_coordinates\": {\n    \"dtype\": \"array\",\n    \"pin\": \"input\"\n  },\n  \"paint\": {\n    \"dtype\": \"signal\",\n    \"pin\": \"input\"\n  },\n  \"init\": {\n    \"dtype\": \"signal\",\n    \"pin\": \"input\"\n  },\n  \"array_edges\": {\n    \"dtype\": \"array\",\n    \"pin\": \"input\"\n  },\n  \"vertex_shader\": {\n    \"dtype\": [\n      \"text\",\n      \"code\",\n      \"vertexshader\"\n    ],\n    \"pin\": \"input\"\n  },\n  \"uniforms\": {\n    \"dtype\": \"json\",\n    \"pin\": \"input\"\n  },\n  \"program\": {\n    \"dtype\": \"json\",\n    \"pin\": \"input\"\n  },\n  \"fragment_shader\": {\n    \"dtype\": [\n      \"text\",\n      \"code\",\n      \"fragmentshader\"\n    ],\n    \"pin\": \"input\"\n  }\n}"
          },
          "signal1": {
            "dtype": "signal",
            "owner": "lines_program.rc"
          }
        }
      },
      "lines_vertexshader": {
        "dtype": [
          "text",
          "code",
          "vertexshader"
        ],
        "resource": {
          "filepath": "./lines.vert",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "data": "uniform mat4 u_mvp_matrix;\nattribute vec3  a_position;\nvarying float fade_factor;\n\nvoid main() {\n  gl_Position = u_mvp_matrix * vec4(a_position, 1.0);\n  gl_Position.z -= 0.0001;\n  float depth = length(gl_Position);\n  fade_factor = smoothstep(25.0, 10.0, depth);\n  fade_factor = 1.0;/// \n}\n"
      },
      "links": {
        "type": "context",
        "like_worker": false,
        "like_cell": false,
        "pins": {},
        "auto": [],
        "children": {
          "code_gen_sphere": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.code_gen_sphere.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.code_gen_sphere.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.code_gen_sphere.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "python"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "code_selector": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.code_selector.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.code_selector.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.code_selector.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "python"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "ftri": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.ftri.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.ftri.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.ftri.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "lines": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.lines.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.lines.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.lines.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "lines_fragmentshader": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.lines_fragmentshader.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.lines_fragmentshader.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.lines_fragmentshader.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "fragmentshader"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "lines_vertexshader": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.lines_vertexshader.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.lines_vertexshader.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.lines_vertexshader.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "vertexshader"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "params_gen_sphere": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.params_gen_sphere.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.params_gen_sphere.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.params_gen_sphere.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "cson",
                      "seamless",
                      "reactor_params"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "params_selector": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.params_selector.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.params_selector.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.params_selector.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "cson",
                      "seamless",
                      "reactor_params"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "tri": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.tri.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.tri.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.tri.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": "cson",
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "tri_fragmentshader": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.tri_fragmentshader.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.tri_fragmentshader.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.tri_fragmentshader.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "fragmentshader"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          },
          "tri_vertexshader": {
            "type": "context",
            "like_worker": true,
            "like_cell": false,
            "pins": {
              "filepath": [
                "ExportedInputPin",
                "links.tri_vertexshader.rc.filepath"
              ],
              "latency": [
                "ExportedInputPin",
                "links.tri_vertexshader.rc.latency"
              ],
              "value": [
                "ExportedEditPin",
                "links.tri_vertexshader.rc.value"
              ]
            },
            "auto": [
              "cell1",
              "cell2",
              "cell3"
            ],
            "children": {
              "cell1": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": "/cell-filelink-start.py",
                  "lib": true,
                  "mode": 2,
                  "save_policy": 1
                },
                "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n\n    class dummy:\n        pass\n\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n            self.defined = True\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n    PINS = dummy()\n    PINS.value = EditPin(\"test\")\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    PINS.filepath = Getter(os.path.join(directory, filename))\n    PINS.latency = Getter(float(sys.argv[3]))\n    def serializer(v):\n        return str(v.get())\n    print(\"Edit in \" + filepath.get())\nelse:\n    from seamless.dtypes import serialize\n    def serializer(v):\n        return serialize(v._dtype, v.get())\n\n\nimport os, time, functools, traceback\nfrom threading import Thread, RLock, Event\nlast_value = None\nlast_serialized_value = None\nlast_exc = None\nlast_mtime = None\n\ndef write_file(fpath):\n    global last_mtime, last_value, last_serialized_value\n    if not PINS.value.defined:\n        last_mtime = -1 #will trigger a file read\n        return\n    if last_value == PINS.value.get():\n        return\n    val = serializer(PINS.value)\n    if last_serialized_value == val:\n        return\n    with lock:\n        if last_serialized_value != val:\n            #print(\"WRITE\", val)\n            if PINS.value._dtype == \"object\":\n                with open(fpath, \"wb\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            else:\n                with open(fpath, \"w\", encoding=\"utf-8\") as f:\n                    f.write(val)\n                    last_value = PINS.value.get()\n                    last_serialized_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except Exception:\n                pass\n\nsleeptime = 0.01\n\ndef poll():\n    global last_time, last_mtime, last_value, last_serialized_value, last_exc\n    fpath = PINS.filepath.get()\n    while 1:\n        sleeps = int(PINS.latency.get() / sleeptime + 0.9999)\n        for n in range(sleeps):\n            time.sleep(sleeptime)\n            if terminate.is_set():\n                break\n        if terminate.is_set():\n            break\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            try:\n                write_file(fpath)\n            except Exception:\n                exc = traceback.format_exc()\n                if exc != last_exc:\n                    print(exc)\n                    last_exc = exc\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                try:\n                    if last_mtime is None or stat.st_mtime > last_mtime:\n                        data = None\n                        if PINS.value._dtype == \"object\":\n                            with open(fpath, \"rb\") as f:\n                                data = f.read()\n                        else:\n                            with open(fpath, encoding=\"utf-8\") as f:\n                                data = f.read()\n                        if data is not None:\n                            if last_serialized_value != data:\n                                #print(\"LOAD\")\n                                PINS.value.set(data)\n                                last_value = None\n                                last_serialized_value = data\n                        last_mtime = stat.st_mtime\n                except Exception:\n                    exc = traceback.format_exc()\n                    if exc != last_exc:\n                        print(exc)\n                        last_exc = exc\n\nterminate = Event()\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nwrite_file(PINS.filepath.get())\nt.start()\n"
              },
              "cell2": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "write_file(PINS.filepath.get())"
              },
              "cell3": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "resource": {
                  "filepath": null,
                  "lib": null,
                  "mode": null,
                  "save_policy": 1
                },
                "data": "terminate.set(); t.join()"
              },
              "rc": {
                "type": "reactor",
                "mode": "sync",
                "params": {
                  "filepath": {
                    "dtype": "str",
                    "pin": "input"
                  },
                  "latency": {
                    "dtype": "float",
                    "pin": "input"
                  },
                  "value": {
                    "dtype": [
                      "text",
                      "code",
                      "vertexshader"
                    ],
                    "must_be_defined": false,
                    "pin": "edit"
                  }
                }
              }
            }
          }
        }
      },
      "minimizations": {
        "dtype": "int",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "data": "20"
      },
      "normals": {
        "dtype": "array",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "hash": "85c0b7a8d5c26bc01d795c4fa7432abc",
        "store": {
          "mode": "GL",
          "params": {}
        }
      },
      "params": {
        "type": "context",
        "like_worker": false,
        "like_cell": false,
        "pins": {},
        "auto": [],
        "children": {
          "ftri": {
            "dtype": "cson",
            "resource": {
              "filepath": "./triangles-flat.cson",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "{\n  \"arrays\": [\n    \"coordinates\", \"normals\"\n  ],\n  \"uniforms\": {\n    \"u_mvp_matrix\": \"mat4\",\n    \"u_modelview_matrix\": \"mat4\",\n    \"u_normal_matrix\": \"mat3\",\n  },\n  \"render\": {\n    \"command\": \"triangles\",\n    \"attributes\": {\n      \"a_position\": {\n        \"dtype\": \"vec3\",\n        \"array\": \"coordinates\"\n      },\n      \"a_normal\": {\n        \"dtype\": \"vec3\",\n        \"array\": \"normals\"\n      }\n    }\n    \"glstate\": {\n      \"cull_face\": true\n      \"clear\": false,\n      \"depth_test\": true\n      \"clear_color\": \"black\",\n      \"blend\": true,\n    }\n  },\n}\n"
          },
          "gen_sphere": {
            "dtype": [
              "cson",
              "seamless",
              "reactor_params"
            ],
            "resource": {
              "filepath": "./params-gen-sphere.cson",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "subdivisions:\n  pin: \"input\"\n  dtype: \"int\"\n\nminimizations:\n  pin: \"input\"\n  dtype: \"int\"\n\ncoordinates:\n  pin: \"output\"\n  dtype: \"array\"\n\nnormals:\n  pin: \"output\"\n  dtype: \"array\"\n\nedges:\n  pin: \"output\"\n  dtype: \"array\"\n\ntriangle_indices:\n  pin: \"output\"\n  dtype: \"array\"\n\ntriangle_coordinates:\n  pin: \"output\"\n  dtype: \"array\"\n\ntriangle_normals:\n  pin: \"output\"\n  dtype: \"array\"\n"
          },
          "gen_uniforms": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "{\n  \"input\": {\n    \"dtype\": \"json\",\n    \"pin\": \"input\"\n  },\n  \"output\": {\n    \"dtype\": \"json\",\n    \"pin\": \"output\"\n  }\n}"
          },
          "lines": {
            "dtype": "cson",
            "resource": {
              "filepath": "./lines.cson",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "{\n  \"arrays\": [\n    \"coordinates\", \"edges\"\n  ],\n  \"uniforms\": {\n    \"u_mvp_matrix\": \"mat4\",\n    \"u_modelview_matrix\": \"mat4\",\n  },\n  \"render\": {\n    \"command\": \"lines\",\n    \"attributes\": {\n      \"a_position\": {\n        \"dtype\": \"vec3\",\n        \"array\": \"coordinates\"\n      }\n    }\n    \"glstate\": {\n      \"clear\": true,\n      \"depth_test\": true\n      \"clear_color\": \"black\",\n      \"blend\": true,\n      \"multisample\": true\n      \"line_width\": 1,\n    }\n    \"indices\": {\n      \"array\": \"edges\",\n      \"dtype\": \"short\"\n    }\n  },\n}\n"
          },
          "selector": {
            "dtype": [
              "cson",
              "seamless",
              "reactor_params"
            ],
            "resource": {
              "filepath": "./params-selector.cson",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "key:\n  pin: \"input\"\n  dtype: \"str\"\n  must_be_defined: false\n\npaint:\n  pin: \"input\"\n  dtype: \"signal\"\n\npaint_lines:\n  pin: \"output\"\n  dtype: \"signal\"\n\npaint_triangles_smooth:\n  pin: \"output\"\n  dtype: \"signal\"\n\npaint_triangles_flat:\n  pin: \"output\"\n  dtype: \"signal\"\n\nrepaint:\n  pin: \"output\"\n  dtype: \"signal\"\n"
          },
          "tri": {
            "dtype": "cson",
            "resource": {
              "filepath": "./triangles-smooth.cson",
              "lib": false,
              "mode": 5,
              "save_policy": 1
            },
            "data": "{\n  \"arrays\": [\n    \"coordinates\", \"normals\", \"indices\"\n  ],\n  \"uniforms\": {\n    \"u_mvp_matrix\": \"mat4\",\n    \"u_modelview_matrix\": \"mat4\",\n    \"u_normal_matrix\": \"mat3\",\n  },\n  \"render\": {\n    \"command\": \"triangles\",\n    \"attributes\": {\n      \"a_position\": {\n        \"dtype\": \"vec3\",\n        \"array\": \"coordinates\"\n      },\n      \"a_normal\": {\n        \"dtype\": \"vec3\",\n        \"array\": \"normals\"\n      }\n    }\n    \"glstate\": {\n      \"clear\": false,\n      \"depth_test\": true\n      \"clear_color\": \"black\",\n      \"blend\": true,\n    },\n    \"indices\": {\n      \"array\": \"indices\",\n      \"dtype\": \"short\"\n    }\n  },\n}\n"
          }
        }
      },
      "scale": {
        "dtype": "float",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "data": "3.5"
      },
      "selector": {
        "type": "reactor",
        "mode": "sync",
        "params": {
          "key": {
            "dtype": "str",
            "must_be_defined": false,
            "pin": "input"
          },
          "paint": {
            "dtype": "signal",
            "pin": "input"
          },
          "paint_lines": {
            "dtype": "signal",
            "pin": "output"
          },
          "paint_triangles_flat": {
            "dtype": "signal",
            "pin": "output"
          },
          "paint_triangles_smooth": {
            "dtype": "signal",
            "pin": "output"
          },
          "repaint": {
            "dtype": "signal",
            "pin": "output"
          }
        }
      },
      "subdivisions": {
        "dtype": "int",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "data": "3"
      },
      "tri_fragmentshader": {
        "dtype": [
          "text",
          "code",
          "fragmentshader"
        ],
        "resource": {
          "filepath": "./triangles.frag",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "data": "//from http://www.mathematik.uni-marburg.de/~thormae/lectures/graphics1/code/WebGLShaderLightMat/ShaderLightMat.html\nvarying vec3 normalInterp;\nvarying vec3 vertPos;\n\nconst vec3 lightPos = vec3(2.0, 2.0, 1.0);\nconst vec3 diffuseColor = vec3(0.5, 0.0, 0.0);\nconst vec3 specColor = vec3(1.0, 1.0, 1.0);\n\nvoid main() {\n  vec3 normal = normalize(normalInterp);\n  vec3 lightDir = normalize(lightPos - vertPos);\n  vec3 reflectDir = reflect(-lightDir, normal);\n  vec3 viewDir = normalize(-vertPos);\n\n  float lambertian = max(dot(lightDir,normal), 0.0);\n  float specular = 0.0;\n\n  if(lambertian > 0.0) {\n\n    vec3 viewDir = normalize(-vertPos);\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float specAngle = max(dot(halfDir, normal), 0.0);\n    specular = pow(specAngle, 16.0);\n\n  }\n\n  gl_FragColor = vec4(lambertian*diffuseColor + specular*specColor, 1.0);\n\n}\n"
      },
      "tri_program": {
        "type": "context",
        "like_worker": true,
        "like_cell": false,
        "pins": {
          "array_coordinates": [
            "ExportedInputPin",
            "tri_program.rc.array_coordinates"
          ],
          "array_indices": [
            "ExportedInputPin",
            "tri_program.rc.array_indices"
          ],
          "array_normals": [
            "ExportedInputPin",
            "tri_program.rc.array_normals"
          ],
          "fragment_shader": [
            "ExportedInputPin",
            "tri_program.rc.fragment_shader"
          ],
          "init": [
            "ExportedInputPin",
            "tri_program.rc.init"
          ],
          "paint": [
            "ExportedInputPin",
            "tri_program.rc.paint"
          ],
          "repaint": [
            "ExportedOutputPin",
            "tri_program.rc.repaint"
          ],
          "uniforms": [
            "ExportedInputPin",
            "tri_program.rc.uniforms"
          ],
          "vertex_shader": [
            "ExportedInputPin",
            "tri_program.rc.vertex_shader"
          ]
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4",
          "signal1"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": "/gui/gl/cell-glprogram.py",
              "lib": true,
              "mode": 2,
              "save_policy": 1
            },
            "data": "from collections import OrderedDict\nimport numpy as np\nfrom OpenGL.arrays import vbo\nfrom OpenGL.GL import shaders\nfrom OpenGL.GL import *\nfrom OpenGL import GL as gl\n\nfrom seamless import opengl\nfrom seamless.lib.gui.gl.set_uniform import set_uniform\n\nfrom seamless.lib.gui.gl.Renderer import Renderer, VertexAttribute\nfrom seamless.lib.gui.gl import glstate as glstate_module\n\ninitialized = False\nshader_program = None\nrenderer = False\nuniform_types = {}\nuniform_locations = {}\nuniform_values = {}\nuniform_dirty = set()\ntexture_locations = OrderedDict()\nwarnings = []\n\ndef init():\n    global initialized, shader_program, renderer, uniform_types, \\\n     glstate, glclear, texdict\n    from seamless.dtypes.gl import GLStore, GLTexStore\n\n    if initialized:\n        return\n\n    # Compile shaders\n    vertex_code = PINS.vertex_shader.get()\n    fragment_code = PINS.fragment_shader.get()\n    vertex_shader = shaders.compileShader(vertex_code, GL_VERTEX_SHADER)\n    fragment_shader = shaders.compileShader(fragment_code, GL_FRAGMENT_SHADER)\n    shader_program = shaders.compileProgram(vertex_shader, fragment_shader)\n\n    program = PINS.program.get()\n\n    # Bind vertex attributes\n    storedict = {}\n    for ar in program[\"arrays\"]:\n        attr = \"array_\" + ar\n        store = getattr( getattr(PINS, attr), \"store\", None)\n        assert isinstance(store, GLStore), ar #TODO: nicer error message\n        #store.bind() #superfluous\n        storedict[ar] = store\n\n    # Bind textures\n    texdict = {}\n    texture_locations.clear()\n    for ar in program.get(\"textures\",[]):\n        attr = \"array_\" + ar\n        store = getattr( getattr(PINS, attr), \"store\", None)\n        assert isinstance(store, GLTexStore), ar #TODO: nicer error message\n        #store.bind() #superfluous\n        texdict[ar] = store\n        loc = gl.glGetUniformLocation(shader_program, ar)\n        if loc == -1:\n            print(\"WARNING: unknown texture '%s'\" % ar)\n            continue\n        texture_locations[ar] = loc\n\n    # Create renderer and set glstate\n    render = program[\"render\"]\n    glstate = render[\"glstate\"]\n    glclear = glstate.pop(\"clear\", True)\n    renderer = Renderer(render, shader_program, storedict)\n    renderer.bind()\n\n    # Get uniform bindings\n    shaders.glUseProgram(shader_program)\n    uniform_locations.clear()\n    uniform_dirty.clear()\n    uniform_types = program.get(\"uniforms\", {})\n    for uniform in uniform_types:\n        loc = gl.glGetUniformLocation(shader_program, uniform)\n        if loc == -1:\n            print(\"WARNING: unknown uniform '%s'\" % uniform)\n            continue\n        uniform_locations[uniform] = loc\n        uniform_dirty.add(uniform)\n\n    initialized = True\n\ndef paint():\n            #print(\"DRAW\")\n    if not initialized:\n        init()\n    shaders.glUseProgram(shader_program)\n\n    old_warnings = warnings[:]\n    warnings.clear()\n\n    #re-bind the textures every draw, to be safe\n    for texnr, tex in enumerate(texture_locations):\n        gl.glActiveTexture(gl.GL_TEXTURE0+texnr)\n        loc = texture_locations[tex]\n        gl.glUniform1i(loc, texnr)\n        store = texdict[tex]\n        store.bind()\n\n    for uniform in list(uniform_dirty):\n        if uniform not in uniform_locations:\n            continue\n        if uniform not in uniform_types:\n            continue\n        utype = uniform_types[uniform]\n        value = uniform_values.get(uniform, None)\n        if value is None:\n            warnings.append(\"WARNING: unset uniform '%s'\" % uniform)\n            continue\n        loc = uniform_locations[uniform]\n        set_uniform(value, utype, loc)\n        uniform_dirty.remove(uniform)\n\n    glstate_module.set_state(**glstate)\n    if glclear not in (None, False):\n        if glclear == True:\n            glstate_module.clear()\n        else:\n            glstate_module.clear(*glclear)\n    renderer.draw()\n\n    # Heisenbug!!! see below. Seems to be solved now\n    try:\n        warnings\n    except NameError:\n        return\n\n    if warnings != old_warnings:\n        for warning in warnings:\n            print(warning)\n    #print(\"/DRAW\")\n\ndef do_update():\n    global initialized\n\n    \"\"\"\n    Outside of \"init\" and \"paint\", we have to use \"dirty\" flags,\n     rather than direct GL commands!\n    \"\"\"\n\n    updated = set()\n    for attr in PINS.__dict__:\n        pin = getattr(PINS, attr)\n        if hasattr(pin, \"updated\") and pin.updated:\n            updated.add(attr)\n\n\n    arrays = PINS.program.get()[\"arrays\"]\n    textures = PINS.program.get().get(\"textures\", [])\n\n    gl_context = opengl()\n\n    dirty_renderer = False\n    repaint = False\n    for ar in arrays + textures:\n        attr = \"array_\" + ar\n        pin = getattr(PINS, attr)\n        if pin.updated:\n            dirty_renderer = True\n\n    if PINS.init.updated:\n        initialized = False\n        if gl_context:\n            init()\n        else:\n            PINS.init.unclear()\n\n    if PINS.uniforms.updated:\n        new_uniform_values = PINS.uniforms.get()\n        for uniform in new_uniform_values:\n            v_old = uniform_values.get(uniform, None)\n            v_new = new_uniform_values.get(uniform, None)\n            if v_old != v_new:\n                uniform_values[uniform] = v_new\n                uniform_dirty.add(uniform)\n                repaint = True\n\n    if PINS.paint.updated:\n        if gl_context:\n            paint()\n            repaint = False\n        else:\n            repaint = True\n\n    # Heisenbug!!! see test-gl-BUG.py\n    # As of now, seems to be solved, see cell-glwindow.py\n    try:\n        initialized\n    except NameError:\n        import sys\n        msg = \"\"\"seamless/lib/gui/cell-glprogram.py\nSomething has gone wrong, PyQt has corrupted Python's memory\nA crash will now happen... no idea why, sorry\n\"\"\"\n        print(msg, file=sys.stderr)\n        return\n    # /heisenbug\n\n    if PINS.program.updated or \\\n      PINS.vertex_shader.updated or PINS.fragment_shader.updated:\n        initialized = False\n        repaint = True\n\n    if initialized and dirty_renderer:\n        renderer.set_dirty()\n        repaint = True\n\n    if repaint:\n        PINS.repaint.set()\n"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "do_update()"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": ""
          },
          "cell4": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "{\n  \"arrays\": [\n    \"coordinates\",\n    \"normals\",\n    \"indices\"\n  ],\n  \"render\": {\n    \"attributes\": {\n      \"a_normal\": {\n        \"dtype\": \"vec3\",\n        \"array\": \"normals\"\n      },\n      \"a_position\": {\n        \"dtype\": \"vec3\",\n        \"array\": \"coordinates\"\n      }\n    },\n    \"command\": \"triangles\",\n    \"glstate\": {\n      \"depth_test\": true,\n      \"blend\": true,\n      \"clear_color\": \"black\",\n      \"clear\": false\n    },\n    \"indices\": {\n      \"array\": \"indices\",\n      \"dtype\": \"short\"\n    }\n  },\n  \"uniforms\": {\n    \"u_normal_matrix\": \"mat3\",\n    \"u_mvp_matrix\": \"mat4\",\n    \"u_modelview_matrix\": \"mat4\"\n  }\n}"
          },
          "rc": {
            "type": "reactor",
            "mode": "sync",
            "params": {
              "array_coordinates": {
                "dtype": "array",
                "pin": "input"
              },
              "array_indices": {
                "dtype": "array",
                "pin": "input"
              },
              "array_normals": {
                "dtype": "array",
                "pin": "input"
              },
              "fragment_shader": {
                "dtype": [
                  "text",
                  "code",
                  "fragmentshader"
                ],
                "pin": "input"
              },
              "init": {
                "dtype": "signal",
                "pin": "input"
              },
              "paint": {
                "dtype": "signal",
                "pin": "input"
              },
              "program": {
                "dtype": "json",
                "pin": "input"
              },
              "repaint": {
                "dtype": "signal",
                "pin": "output"
              },
              "uniforms": {
                "dtype": "json",
                "pin": "input"
              },
              "vertex_shader": {
                "dtype": [
                  "text",
                  "code",
                  "vertexshader"
                ],
                "pin": "input"
              }
            }
          },
          "rcparams": {
            "dtype": "json",
            "resource": {
              "filepath": null,
              "lib": null,
              "mode": null,
              "save_policy": 1
            },
            "data": "{\n  \"repaint\": {\n    \"dtype\": \"signal\",\n    \"pin\": \"output\"\n  },\n  \"array_coordinates\": {\n    \"dtype\": \"array\",\n    \"pin\": \"input\"\n  },\n  \"paint\": {\n    \"dtype\": \"signal\",\n    \"pin\": \"input\"\n  },\n  \"init\": {\n    \"dtype\": \"signal\",\n    \"pin\": \"input\"\n  },\n  \"array_indices\": {\n    \"dtype\": \"array\",\n    \"pin\": \"input\"\n  },\n  \"vertex_shader\": {\n    \"dtype\": [\n      \"text\",\n      \"code\",\n      \"vertexshader\"\n    ],\n    \"pin\": \"input\"\n  },\n  \"uniforms\": {\n    \"dtype\": \"json\",\n    \"pin\": \"input\"\n  },\n  \"array_normals\": {\n    \"dtype\": \"array\",\n    \"pin\": \"input\"\n  },\n  \"program\": {\n    \"dtype\": \"json\",\n    \"pin\": \"input\"\n  },\n  \"fragment_shader\": {\n    \"dtype\": [\n      \"text\",\n      \"code\",\n      \"fragmentshader\"\n    ],\n    \"pin\": \"input\"\n  }\n}"
          },
          "signal1": {
            "dtype": "signal",
            "owner": "tri_program.rc"
          }
        }
      },
      "tri_vertexshader": {
        "dtype": [
          "text",
          "code",
          "vertexshader"
        ],
        "resource": {
          "filepath": "./triangles.vert",
          "lib": false,
          "mode": 5,
          "save_policy": 1
        },
        "data": "uniform mat4 u_mvp_matrix;\nuniform mat4 u_modelview_matrix;\nuniform mat3 u_normal_matrix;\nattribute vec3  a_position;\nattribute vec3  a_normal;\nvarying vec3 normalInterp;\nvarying vec3 vertPos;\n\n//adapted from http://www.mathematik.uni-marburg.de/~thormae/lectures/graphics1/code/WebGLShaderLightMat/ShaderLightMat.html\nvoid main() {\n  gl_Position = u_mvp_matrix * vec4(a_position, 1.0);\n\n  // all following gemetric computations are performed in the\n  // camera coordinate system (aka eye coordinates)\n  vec3 normal = u_normal_matrix * a_normal;\n  gl_Position = u_mvp_matrix * vec4(a_position, 1.0);\n  vec4 vertPos4 = u_modelview_matrix * vec4(a_position, 1.0);\n  vertPos = vec3(vertPos4) / vertPos4.w;\n  normalInterp = u_normal_matrix * a_normal;\n\n}\n"
      },
      "triangle_coordinates": {
        "dtype": "array",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "hash": "492b89fd03838504d50e4933fb6a0aed",
        "store": {
          "mode": "GL",
          "params": {}
        }
      },
      "triangle_coordinates_prescale": {
        "dtype": "array",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "hash": "f850912625e636287ca1443017938ebb"
      },
      "triangle_indices": {
        "dtype": "array",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "hash": "0286f070b51224719b7e62909ee34f5b",
        "store": {
          "mode": "GL",
          "params": {}
        }
      },
      "triangle_normals": {
        "dtype": "array",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "hash": "e28a616dda5bba39cb87f6d465f02b41",
        "store": {
          "mode": "GL",
          "params": {}
        }
      },
      "uniforms": {
        "dtype": "json",
        "resource": {
          "filepath": null,
          "lib": null,
          "mode": null,
          "save_policy": 1
        },
        "data": "{\n  \"azimuth\": 45,\n  \"normal_matrix\": [\n    [\n      -0.7071067690849304,\n      -0.3535533547401428,\n      0.6123724579811096\n    ],\n    [\n      0.7071067690849304,\n      -0.3535533547401428,\n      0.6123724579811096\n    ],\n    [\n      0.0,\n      0.866025447845459,\n      0.4999999701976776\n    ]\n  ],\n  \"fov\": 60,\n  \"elevation\": 30,\n  \"modelview_matrix\": [\n    [\n      -0.7071067690849304,\n      -0.3535533547401428,\n      0.6123724579811096,\n      -0.0\n    ],\n    [\n      0.7071067690849304,\n      -0.3535533547401428,\n      0.6123724579811096,\n      0.0\n    ],\n    [\n      0.0,\n      0.866025447845459,\n      0.4999999701976776,\n      0.0\n    ],\n    [\n      0.0,\n      0.0,\n      -10.0,\n      1.0\n    ]\n  ],\n  \"center\": [\n    0.0,\n    0.0,\n    0.0\n  ],\n  \"position\": [\n    6.123724356957946,\n    6.123724356957945,\n    4.999999999999999\n  ],\n  \"mvp_matrix\": [\n    [\n      -1.2247447441552737,\n      -0.8164964834737987,\n      -0.6123736259888801,\n      -0.6123724579811096\n    ],\n    [\n      1.2247447441552737,\n      -0.8164964834737987,\n      -0.6123736259888801,\n      -0.6123724579811096\n    ],\n    [\n      0.0,\n      2.000000065858103,\n      -0.5000009238719372,\n      -0.4999999701976776\n    ],\n    [\n      0.0,\n      0.0,\n      9.980019053444266,\n      10.0\n    ]\n  ],\n  \"projection_matrix\": [\n    [\n      1.7320506572723389,\n      0.0,\n      0.0,\n      0.0\n    ],\n    [\n      0.0,\n      2.309401035308838,\n      0.0,\n      0.0\n    ],\n    [\n      0.0,\n      0.0,\n      -1.0000019073486328,\n      -1.0\n    ],\n    [\n      0.0,\n      0.0,\n      -0.020000020042061806,\n      0.0\n    ]\n  ],\n  \"height\": 480,\n  \"distance\": 10.0,\n  \"width\": 640\n}"
      },
      "window": {
        "type": "reactor",
        "mode": "sync",
        "params": {
          "camera": {
            "dtype": "json",
            "must_be_defined": false,
            "pin": "edit"
          },
          "geometry": {
            "dtype": "json",
            "pin": "input"
          },
          "init": {
            "dtype": "signal",
            "pin": "output"
          },
          "last_key": {
            "dtype": "str",
            "pin": "output"
          },
          "paint": {
            "dtype": "signal",
            "pin": "output"
          },
          "painted": {
            "dtype": "signal",
            "pin": "output"
          },
          "title": {
            "dtype": "str",
            "pin": "input"
          },
          "update": {
            "dtype": "signal",
            "pin": "input"
          }
        }
      }
    },
    "macro_objects": [
      {
        "args": [
          null
        ],
        "kwargs": {},
        "cell_args": {
          "0": "params.gen_uniforms"
        },
        "macro_module_name": "seamless.core.transformer",
        "macro_func_name": "transformer",
        "macro_order": 0,
        "target": "gen_uniforms"
      },
      {
        "args": [
          null
        ],
        "kwargs": {},
        "cell_args": {
          "0": "tri_program.rcparams"
        },
        "macro_module_name": "seamless.core.reactor",
        "macro_func_name": "reactor",
        "macro_order": 2,
        "target": "tri_program.rc"
      },
      {
        "args": [
          null
        ],
        "kwargs": {
          "with_window": false
        },
        "cell_args": {
          "0": "params.lines"
        },
        "macro_module_name": "seamless.lib.gui.gl.glprogram",
        "macro_func_name": "glprogram",
        "macro_order": 0,
        "target": "lines_program"
      },
      {
        "args": [
          null
        ],
        "kwargs": {},
        "cell_args": {
          "0": "lines_program.rcparams"
        },
        "macro_module_name": "seamless.core.reactor",
        "macro_func_name": "reactor",
        "macro_order": 1,
        "target": "lines_program.rc"
      },
      {
        "args": [
          null
        ],
        "kwargs": {},
        "cell_args": {
          "0": "params.selector"
        },
        "macro_module_name": "seamless.core.reactor",
        "macro_func_name": "reactor",
        "macro_order": 4,
        "target": "selector"
      },
      {
        "args": [
          null
        ],
        "kwargs": {},
        "cell_args": {
          "0": "params.gen_sphere"
        },
        "macro_module_name": "seamless.core.reactor",
        "macro_func_name": "reactor",
        "macro_order": 0,
        "target": "gen_sphere"
      },
      {
        "args": [
          null
        ],
        "kwargs": {
          "with_window": false
        },
        "cell_args": {
          "0": "params.ftri"
        },
        "macro_module_name": "seamless.lib.gui.gl.glprogram",
        "macro_func_name": "glprogram",
        "macro_order": 2,
        "target": "ftri_program"
      },
      {
        "args": [
          null
        ],
        "kwargs": {
          "with_window": false
        },
        "cell_args": {
          "0": "params.tri"
        },
        "macro_module_name": "seamless.lib.gui.gl.glprogram",
        "macro_func_name": "glprogram",
        "macro_order": 1,
        "target": "tri_program"
      },
      {
        "args": [
          null
        ],
        "kwargs": {},
        "cell_args": {
          "0": "ftri_program.rcparams"
        },
        "macro_module_name": "seamless.core.reactor",
        "macro_func_name": "reactor",
        "macro_order": 3,
        "target": "ftri_program.rc"
      }
    ],
    "macro_listeners": [
      {
        "cell": "params.gen_uniforms",
        "macro_target": "gen_uniforms",
        "macro_arg": 0
      },
      {
        "cell": "tri_program.rcparams",
        "macro_target": "tri_program.rc",
        "macro_arg": 0
      },
      {
        "cell": "params.lines",
        "macro_target": "lines_program",
        "macro_arg": 0
      },
      {
        "cell": "lines_program.rcparams",
        "macro_target": "lines_program.rc",
        "macro_arg": 0
      },
      {
        "cell": "params.selector",
        "macro_target": "selector",
        "macro_arg": 0
      },
      {
        "cell": "params.gen_sphere",
        "macro_target": "gen_sphere",
        "macro_arg": 0
      },
      {
        "cell": "params.ftri",
        "macro_target": "ftri_program",
        "macro_arg": 0
      },
      {
        "cell": "params.tri",
        "macro_target": "tri_program",
        "macro_arg": 0
      },
      {
        "cell": "ftri_program.rcparams",
        "macro_target": "ftri_program.rc",
        "macro_arg": 0
      }
    ],
    "registrar_items": [],
    "registrar_listeners": [],
    "registrar_cells": [],
    "pin_cell_connections": [
      [
        "do_scale.output",
        "coordinates"
      ],
      [
        "do_scale2.output",
        "triangle_coordinates"
      ],
      [
        "ftri_program.rc.repaint",
        "ftri_program.signal1"
      ],
      [
        "gen_sphere.coordinates",
        "code.cell5"
      ],
      [
        "gen_sphere.coordinates",
        "coordinates_prescale"
      ],
      [
        "gen_sphere.edges",
        "code.cell3"
      ],
      [
        "gen_sphere.edges",
        "edges"
      ],
      [
        "gen_sphere.normals",
        "code.cell6"
      ],
      [
        "gen_sphere.normals",
        "normals"
      ],
      [
        "gen_sphere.triangle_coordinates",
        "code.cell8"
      ],
      [
        "gen_sphere.triangle_coordinates",
        "triangle_coordinates_prescale"
      ],
      [
        "gen_sphere.triangle_indices",
        "code.cell4"
      ],
      [
        "gen_sphere.triangle_indices",
        "triangle_indices"
      ],
      [
        "gen_sphere.triangle_normals",
        "code.cell7"
      ],
      [
        "gen_sphere.triangle_normals",
        "triangle_normals"
      ],
      [
        "gen_uniforms.output",
        "code.cell24"
      ],
      [
        "lines_program.rc.repaint",
        "lines_program.signal1"
      ],
      [
        "selector.paint_lines",
        "code.signal5"
      ],
      [
        "selector.paint_triangles_flat",
        "code.signal6"
      ],
      [
        "selector.paint_triangles_smooth",
        "code.signal4"
      ],
      [
        "selector.repaint",
        "code.signal7"
      ],
      [
        "tri_program.rc.repaint",
        "tri_program.signal1"
      ],
      [
        "window.init",
        "code.signal2"
      ],
      [
        "window.last_key",
        "code.cell15"
      ],
      [
        "window.paint",
        "code.signal1"
      ],
      [
        "window.painted",
        "code.signal3"
      ]
    ],
    "cell_pin_connections": [
      [
        "code.cell10",
        "links.code_gen_sphere.rc.latency"
      ],
      [
        "code.cell11",
        "gen_sphere.code_start"
      ],
      [
        "code.cell12",
        "gen_sphere.code_stop"
      ],
      [
        "code.cell13",
        "do_scale.code"
      ],
      [
        "code.cell14",
        "do_scale2.code"
      ],
      [
        "code.cell15",
        "selector.key"
      ],
      [
        "code.cell16",
        "window.title"
      ],
      [
        "code.cell17",
        "window.geometry"
      ],
      [
        "code.cell18",
        "window.code_start"
      ],
      [
        "code.cell19",
        "window.code_update"
      ],
      [
        "code.cell1",
        "links.params_gen_sphere.rc.filepath"
      ],
      [
        "code.cell20",
        "window.code_stop"
      ],
      [
        "code.cell21",
        "gen_uniforms.code"
      ],
      [
        "code.cell22",
        "links.lines.rc.filepath"
      ],
      [
        "code.cell23",
        "links.lines.rc.latency"
      ],
      [
        "code.cell24",
        "ftri_program.rc.uniforms"
      ],
      [
        "code.cell24",
        "lines_program.rc.uniforms"
      ],
      [
        "code.cell24",
        "tri_program.rc.uniforms"
      ],
      [
        "code.cell25",
        "links.lines_vertexshader.rc.filepath"
      ],
      [
        "code.cell26",
        "links.lines_vertexshader.rc.latency"
      ],
      [
        "code.cell27",
        "links.lines_fragmentshader.rc.filepath"
      ],
      [
        "code.cell28",
        "links.lines_fragmentshader.rc.latency"
      ],
      [
        "code.cell29",
        "links.tri_vertexshader.rc.filepath"
      ],
      [
        "code.cell2",
        "links.params_gen_sphere.rc.latency"
      ],
      [
        "code.cell30",
        "links.tri_vertexshader.rc.latency"
      ],
      [
        "code.cell31",
        "links.tri_fragmentshader.rc.filepath"
      ],
      [
        "code.cell32",
        "links.tri_fragmentshader.rc.latency"
      ],
      [
        "code.cell33",
        "links.tri.rc.filepath"
      ],
      [
        "code.cell34",
        "links.tri.rc.latency"
      ],
      [
        "code.cell35",
        "links.ftri.rc.filepath"
      ],
      [
        "code.cell36",
        "links.ftri.rc.latency"
      ],
      [
        "code.cell37",
        "links.params_selector.rc.filepath"
      ],
      [
        "code.cell38",
        "links.params_selector.rc.latency"
      ],
      [
        "code.cell39",
        "selector.code_start"
      ],
      [
        "code.cell40",
        "selector.code_stop"
      ],
      [
        "code.cell41",
        "links.code_selector.rc.filepath"
      ],
      [
        "code.cell42",
        "links.code_selector.rc.latency"
      ],
      [
        "code.cell9",
        "links.code_gen_sphere.rc.filepath"
      ],
      [
        "code.gen_sphere",
        "gen_sphere.code_update"
      ],
      [
        "code.gen_sphere",
        "links.code_gen_sphere.rc.value"
      ],
      [
        "code.selector",
        "links.code_selector.rc.value"
      ],
      [
        "code.selector",
        "selector.code_update"
      ],
      [
        "code.signal1",
        "selector.paint"
      ],
      [
        "code.signal2",
        "ftri_program.rc.init"
      ],
      [
        "code.signal2",
        "lines_program.rc.init"
      ],
      [
        "code.signal2",
        "tri_program.rc.init"
      ],
      [
        "code.signal4",
        "tri_program.rc.paint"
      ],
      [
        "code.signal5",
        "lines_program.rc.paint"
      ],
      [
        "code.signal6",
        "ftri_program.rc.paint"
      ],
      [
        "code.signal7",
        "window.update"
      ],
      [
        "coordinates_prescale",
        "do_scale.input"
      ],
      [
        "coordinates",
        "lines_program.rc.array_coordinates"
      ],
      [
        "coordinates",
        "tri_program.rc.array_coordinates"
      ],
      [
        "edges",
        "lines_program.rc.array_edges"
      ],
      [
        "edit.minimizations.cell1",
        "edit.minimizations.rc.title"
      ],
      [
        "edit.minimizations.cell2",
        "edit.minimizations.rc.maximum"
      ],
      [
        "edit.minimizations.cell3",
        "edit.minimizations.rc.code_start"
      ],
      [
        "edit.minimizations.cell4",
        "edit.minimizations.rc.code_stop"
      ],
      [
        "edit.minimizations.cell5",
        "edit.minimizations.rc.code_update"
      ],
      [
        "edit.scale.cell1",
        "edit.scale.rc.title"
      ],
      [
        "edit.scale.cell2",
        "edit.scale.rc.code_start"
      ],
      [
        "edit.scale.cell3",
        "edit.scale.rc.code_stop"
      ],
      [
        "edit.scale.cell4",
        "edit.scale.rc.code_update"
      ],
      [
        "edit.subdivisions.cell1",
        "edit.subdivisions.rc.title"
      ],
      [
        "edit.subdivisions.cell2",
        "edit.subdivisions.rc.maximum"
      ],
      [
        "edit.subdivisions.cell3",
        "edit.subdivisions.rc.code_start"
      ],
      [
        "edit.subdivisions.cell4",
        "edit.subdivisions.rc.code_stop"
      ],
      [
        "edit.subdivisions.cell5",
        "edit.subdivisions.rc.code_update"
      ],
      [
        "ftri_program.cell1",
        "ftri_program.rc.code_start"
      ],
      [
        "ftri_program.cell2",
        "ftri_program.rc.code_update"
      ],
      [
        "ftri_program.cell3",
        "ftri_program.rc.code_stop"
      ],
      [
        "ftri_program.cell4",
        "ftri_program.rc.program"
      ],
      [
        "ftri_program.signal1",
        "window.update"
      ],
      [
        "lines_fragmentshader",
        "lines_program.rc.fragment_shader"
      ],
      [
        "lines_fragmentshader",
        "links.lines_fragmentshader.rc.value"
      ],
      [
        "lines_program.cell1",
        "lines_program.rc.code_start"
      ],
      [
        "lines_program.cell2",
        "lines_program.rc.code_update"
      ],
      [
        "lines_program.cell3",
        "lines_program.rc.code_stop"
      ],
      [
        "lines_program.cell4",
        "lines_program.rc.program"
      ],
      [
        "lines_program.signal1",
        "window.update"
      ],
      [
        "lines_vertexshader",
        "lines_program.rc.vertex_shader"
      ],
      [
        "lines_vertexshader",
        "links.lines_vertexshader.rc.value"
      ],
      [
        "links.code_gen_sphere.cell1",
        "links.code_gen_sphere.rc.code_start"
      ],
      [
        "links.code_gen_sphere.cell2",
        "links.code_gen_sphere.rc.code_update"
      ],
      [
        "links.code_gen_sphere.cell3",
        "links.code_gen_sphere.rc.code_stop"
      ],
      [
        "links.code_selector.cell1",
        "links.code_selector.rc.code_start"
      ],
      [
        "links.code_selector.cell2",
        "links.code_selector.rc.code_update"
      ],
      [
        "links.code_selector.cell3",
        "links.code_selector.rc.code_stop"
      ],
      [
        "links.ftri.cell1",
        "links.ftri.rc.code_start"
      ],
      [
        "links.ftri.cell2",
        "links.ftri.rc.code_update"
      ],
      [
        "links.ftri.cell3",
        "links.ftri.rc.code_stop"
      ],
      [
        "links.lines.cell1",
        "links.lines.rc.code_start"
      ],
      [
        "links.lines.cell2",
        "links.lines.rc.code_update"
      ],
      [
        "links.lines.cell3",
        "links.lines.rc.code_stop"
      ],
      [
        "links.lines_fragmentshader.cell1",
        "links.lines_fragmentshader.rc.code_start"
      ],
      [
        "links.lines_fragmentshader.cell2",
        "links.lines_fragmentshader.rc.code_update"
      ],
      [
        "links.lines_fragmentshader.cell3",
        "links.lines_fragmentshader.rc.code_stop"
      ],
      [
        "links.lines_vertexshader.cell1",
        "links.lines_vertexshader.rc.code_start"
      ],
      [
        "links.lines_vertexshader.cell2",
        "links.lines_vertexshader.rc.code_update"
      ],
      [
        "links.lines_vertexshader.cell3",
        "links.lines_vertexshader.rc.code_stop"
      ],
      [
        "links.params_gen_sphere.cell1",
        "links.params_gen_sphere.rc.code_start"
      ],
      [
        "links.params_gen_sphere.cell2",
        "links.params_gen_sphere.rc.code_update"
      ],
      [
        "links.params_gen_sphere.cell3",
        "links.params_gen_sphere.rc.code_stop"
      ],
      [
        "links.params_selector.cell1",
        "links.params_selector.rc.code_start"
      ],
      [
        "links.params_selector.cell2",
        "links.params_selector.rc.code_update"
      ],
      [
        "links.params_selector.cell3",
        "links.params_selector.rc.code_stop"
      ],
      [
        "links.tri.cell1",
        "links.tri.rc.code_start"
      ],
      [
        "links.tri.cell2",
        "links.tri.rc.code_update"
      ],
      [
        "links.tri.cell3",
        "links.tri.rc.code_stop"
      ],
      [
        "links.tri_fragmentshader.cell1",
        "links.tri_fragmentshader.rc.code_start"
      ],
      [
        "links.tri_fragmentshader.cell2",
        "links.tri_fragmentshader.rc.code_update"
      ],
      [
        "links.tri_fragmentshader.cell3",
        "links.tri_fragmentshader.rc.code_stop"
      ],
      [
        "links.tri_vertexshader.cell1",
        "links.tri_vertexshader.rc.code_start"
      ],
      [
        "links.tri_vertexshader.cell2",
        "links.tri_vertexshader.rc.code_update"
      ],
      [
        "links.tri_vertexshader.cell3",
        "links.tri_vertexshader.rc.code_stop"
      ],
      [
        "minimizations",
        "edit.minimizations.rc.value"
      ],
      [
        "minimizations",
        "gen_sphere.minimizations"
      ],
      [
        "normals",
        "tri_program.rc.array_normals"
      ],
      [
        "params.ftri",
        "links.ftri.rc.value"
      ],
      [
        "params.gen_sphere",
        "links.params_gen_sphere.rc.value"
      ],
      [
        "params.lines",
        "links.lines.rc.value"
      ],
      [
        "params.selector",
        "links.params_selector.rc.value"
      ],
      [
        "params.tri",
        "links.tri.rc.value"
      ],
      [
        "scale",
        "do_scale.scale"
      ],
      [
        "scale",
        "do_scale2.scale"
      ],
      [
        "scale",
        "edit.scale.rc.value"
      ],
      [
        "subdivisions",
        "edit.subdivisions.rc.value"
      ],
      [
        "subdivisions",
        "gen_sphere.subdivisions"
      ],
      [
        "tri_fragmentshader",
        "ftri_program.rc.fragment_shader"
      ],
      [
        "tri_fragmentshader",
        "links.tri_fragmentshader.rc.value"
      ],
      [
        "tri_fragmentshader",
        "tri_program.rc.fragment_shader"
      ],
      [
        "tri_program.cell1",
        "tri_program.rc.code_start"
      ],
      [
        "tri_program.cell2",
        "tri_program.rc.code_update"
      ],
      [
        "tri_program.cell3",
        "tri_program.rc.code_stop"
      ],
      [
        "tri_program.cell4",
        "tri_program.rc.program"
      ],
      [
        "tri_program.signal1",
        "window.update"
      ],
      [
        "tri_vertexshader",
        "ftri_program.rc.vertex_shader"
      ],
      [
        "tri_vertexshader",
        "links.tri_vertexshader.rc.value"
      ],
      [
        "tri_vertexshader",
        "tri_program.rc.vertex_shader"
      ],
      [
        "triangle_coordinates_prescale",
        "do_scale2.input"
      ],
      [
        "triangle_coordinates",
        "ftri_program.rc.array_coordinates"
      ],
      [
        "triangle_indices",
        "tri_program.rc.array_indices"
      ],
      [
        "triangle_normals",
        "ftri_program.rc.array_normals"
      ],
      [
        "uniforms",
        "gen_uniforms.input"
      ],
      [
        "uniforms",
        "window.camera"
      ]
    ],
    "cell_cell_connections": []
  }
}