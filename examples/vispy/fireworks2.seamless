{
  "lib": {
    "/cell-filelink-start.py": {
      "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n\n    value = EditPin(\"test\")\n\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    filepath = Getter(os.path.join(directory, filename))\n    latency = Getter(float(sys.argv[3]))\n    print(\"Edit in \" + filepath.get())\n\nimport os, time, functools\nfrom seamless import add_work\nfrom threading import Thread, RLock\nlast_value = None\n\ndef write_file(fpath):\n    global last_mtime, last_value\n    val = str(value.get())\n    if last_value == val:\n        return\n    with lock:\n        if last_value != val:\n            with open(fpath, \"w\") as f:\n                f.write(val)\n                last_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value\n    fpath = filepath.get()\n    while 1:\n        time.sleep(latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            write_file(fpath)\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                if stat.st_mtime > last_mtime:\n                    data = None\n                    with open(fpath) as f:\n                        data = f.read()\n                    if data is not None:\n                        w = functools.partial(value.set, data)\n                        add_work(w)\n                        last_value = data\n                    last_mtime = stat.st_mtime\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nval = str(value.get())\nwrite_file(filepath.get())\nt.start()\n",
      "links": [
        "ed_vert.cell1",
        "ed_frag.cell1",
        "ed_vertexformat.cell1",
        "ed_hive.cell1",
        "ed_gen_vertexbuffer.cell1",
        "ed_gen_texturedict.cell1"
      ]
    },
    "/gui/cell-basic_editor_UPDATE.py": {
      "data": "if value.updated:\n    b.setValue(value.get())\nif title.updated:\n    w.setWindowTitle(title.get())\n",
      "links": [
        "ed_delay.cell4",
        "ed_radius.cell4",
        "ed_N.cell4"
      ]
    },
    "/gui/cell-basic_editor_float.py": {
      "data": "from seamless.qt.QtWidgets import QDoubleSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(title.get())\nw.show()\nb = QDoubleSpinBox()\nb.setSingleStep(0.1)\nb.setMaximum(1000000)\nb.setValue(value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(value.set)\n",
      "links": [
        "ed_delay.cell2"
      ]
    },
    "/gui/cell-basic_editor_int.py": {
      "data": "from seamless.qt.QtWidgets import QSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(title.get())\nw.show()\nb = QSpinBox()\nb.setMaximum(1000000)\nb.setValue(value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(value.set)\n",
      "links": [
        "ed_radius.cell2",
        "ed_N.cell2"
      ]
    },
    "/gui/cell-basic_editor_json.py": {
      "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\nimport json\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(title.get())\n\nclass MyTextEdit(QTextEdit):\n    def focusOutEvent(self, event):\n        value.set(self.toPlainText())\n        QTextEdit.focusOutEvent(self, event)\n\nw.show()\nb = MyTextEdit()\nb.setFontPointSize(15)\nb.setText(json.dumps(value.get(), indent=2))\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n",
      "links": [
        "ed_gen_vertexbuffer_params.cell2",
        "ed_gen_texture_dict_params.cell2"
      ]
    },
    "/gui/cell-basic_editor_json_UPDATE.py": {
      "data": "if value.updated:\n    b.setText(json.dumps(value.get(), indent=2))\nif title.updated:\n    w.setWindowTitle(title.get())\n",
      "links": [
        "ed_gen_vertexbuffer_params.cell4",
        "ed_gen_texture_dict_params.cell4"
      ]
    }
  },
  "macro": [
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": [
        "json",
        "seamless",
        "editor_params"
      ],
      "module_name": "seamless.core.editor",
      "func_name": "editor",
      "code": "@macro(type=(\"json\", \"seamless\", \"editor_params\"),with_context=False)\ndef editor(kwargs):\n    from seamless.core.editor import Editor #code must be standalone\n    #TODO: remapping, e.g. output_finish, destroy, ...\n    return Editor(kwargs)\n"
    },
    {
      "with_context": false,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": [
        "json",
        "seamless",
        "transformer_params"
      ],
      "module_name": "seamless.core.transformer",
      "func_name": "transformer",
      "code": "@macro(type=(\"json\", \"seamless\", \"transformer_params\"), with_context=False)\ndef transformer(kwargs):\n    from seamless.core.transformer import Transformer #code must be standalone\n    #TODO: remapping, e.g. output_finish, destroy, ...\n    return Transformer(kwargs)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": "str",
      "module_name": "seamless.lib.filelink",
      "func_name": "filelink",
      "code": "@macro(\"str\")\ndef filelink(ctx, cell_type):\n    from seamless import editor\n    pinparams = {\n       \"value\": {\n         \"pin\": \"edit\",\n         \"dtype\": cell_type\n       },\n       \"filepath\" : {\n         \"pin\": \"input\",\n         \"dtype\": \"str\"\n       },\n       \"latency\" : {\n         \"pin\": \"input\",\n         \"dtype\": \"float\"\n       },\n    }\n    ed = ctx.ed = editor(pinparams)\n    ed.code_start.cell().fromfile(\"cell-filelink-start.py\")\n    ed.code_update.cell().set(\"write_file(filepath.get())\")\n    ed.code_stop.cell().set('t.join(0)')\n    ctx.export(ed)\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": {
        "editor_type": "str",
        "title": {
          "default": "Basic editor",
          "type": "str"
        }
      },
      "module_name": "seamless.lib.gui.basic_editor",
      "func_name": "basic_editor",
      "code": "@macro(OrderedDict((\n    (\"editor_type\",\"str\"),\n    (\"title\",{\"type\": \"str\", \"default\": \"Basic editor\"})\n)))\ndef basic_editor(ctx, editor_type, title):\n    from seamless import editor\n\n    _editors = {\n      \"int\": {\n        \"code\": \"cell-basic_editor_int.py\",\n        \"update\": \"cell-basic_editor_UPDATE.py\",\n      },\n      \"float\": {\n        \"code\": \"cell-basic_editor_float.py\",\n        \"update\": \"cell-basic_editor_UPDATE.py\",\n      },\n      \"text\": {\n        \"code\": \"cell-basic_editor_text.py\",\n        \"update\": \"cell-basic_editor_text_UPDATE.py\",\n      },\n      \"json\": {\n        \"code\": \"cell-basic_editor_json.py\",\n        \"update\": \"cell-basic_editor_json_UPDATE.py\",\n      },\n    }\n\n    def _match_type(type, typelist):\n        typelist = list(typelist)\n        type2 = type\n        if isinstance(type, str):\n            type2 = (type,)\n        typelist2 = []\n        for t in typelist:\n            if isinstance(t, str):\n                typelist2.append((t,))\n            else:\n                typelist2.append(t)\n        matches = []\n        for n in range(len(typelist)):\n            ltype = typelist2[n]\n            k = min(len(type2), len(ltype))\n            if type2[:k] == ltype[:k]:\n                matches.append((n, k))\n        if not len(matches):\n            raise TypeError(\"Cannot find editor for cell type '{0}'\".format(type))\n        matches.sort(key=lambda v: -v[1])\n        bestmatch = matches[0][0]\n        return typelist[bestmatch]\n\n    editor_type = _match_type(editor_type, _editors.keys())\n    pinparams = {\n      \"value\": {\n        \"pin\": \"edit\",\n        \"dtype\": editor_type\n      },\n      \"title\": {\n        \"pin\": \"input\",\n        \"dtype\": \"str\",\n      },\n    }\n    ed = ctx.ed = editor(pinparams)\n    ed.title.cell().set(title)\n    ed.code_start.cell().fromfile(_editors[editor_type][\"code\"])\n    ed.code_stop.cell().set('w.destroy()')\n    upfile = _editors[editor_type][\"update\"]\n    c_up = ed.code_update.cell(True)\n    if upfile is not None:\n        c_up.fromfile(upfile)\n    else:\n        c_up.set(\"\")\n    ctx.export(ed, forced=[\"title\"])\n"
    },
    {
      "with_context": true,
      "dtype": [
        "text",
        "code",
        "python"
      ],
      "type_args": "str",
      "module_name": "seamless.lib.hive.hiveprocess",
      "func_name": "hiveprocess",
      "code": "@macro(\"str\")\ndef hiveprocess(ctx, hivename):\n\n    from hive.ppin import PushInBee\n    from hive.ppout import PushOutBee\n    from hive.classes.resolve_bee import ResolveBee\n    from hive.antenna import HiveAntenna\n    from hive.output import HiveOutput\n    from hive.attribute import Attribute\n    from hive.hive import HiveObject, HiveBuilder\n    from hive.manager import hive_mode_as\n    from seamless.core.editor import editor\n\n    def hiveprocess_start():\n        import hive\n        global myhive\n        myhive = hivecls()\n        for attr, hivepin_type in hive_attributes.get().items():\n            if hivepin_type == \"push_out\":\n                output = globals()[attr]\n                hive.connect(getattr(myhive, attr), hive.push_in(output.set))\n\n    def hiveprocess_update():\n        for attr, hivepin_type in hive_attributes.get().items():\n            at = globals()[attr]\n            try:\n                if not at.updated:\n                    continue\n            except AttributeError:\n                continue\n            value = at.get()\n            if hivepin_type == \"attribute\":\n                setattr(myhive, attr, value)\n            elif hivepin_type == \"push_in\":\n                getattr(myhive, attr).push(value)\n\n    def hiveprocess_stop():\n        global myhive\n        if hasattr(myhive, \"destroy\"):\n            myhive.destroy()\n        del myhive\n\n\n    ctx.registrar.hive.connect(hivename, ctx)\n    hivecls = ctx.registrar.hive.get(hivename)\n    assert issubclass(hivecls, HiveBuilder)\n    with hive_mode_as(\"build\"):\n        hiveobject = hivecls() #hive must take no arguments!\n    assert isinstance(hiveobject, HiveObject)\n    hive_attributes = {}\n    editor_params = { \"hive_attributes\": {\"pin\": \"input\", \"dtype\": \"json\"}}\n    for attr in dir(hiveobject._hive_ex):\n        hivepin = getattr(hiveobject._hive_ex, attr)\n        hivepin_type = None\n        if isinstance(hivepin, HiveAntenna):\n            hivepin = hivepin.export()\n        if isinstance(hivepin, HiveOutput):\n            hivepin = hivepin.export()\n        while isinstance(hivepin, ResolveBee):\n            hivepin = hivepin._bee\n\n        if isinstance(hivepin, Attribute):\n            #hivepin_type = \"attribute\"\n            #pin = \"input\"\n            continue ### keep it like this??\n        elif isinstance(hivepin, PushInBee):\n            hivepin_type = \"push_in\"\n            pin = \"input\"\n        elif isinstance(hivepin, PushOutBee):\n            hivepin_type = \"push_out\"\n            pin = \"output\"\n        else:\n            continue\n\n        hive_attributes[attr] = hivepin_type\n        dtype = hivepin.data_type\n        if dtype is None:\n            dtype = \"object\"\n        editor_params[attr] = {\"pin\": pin, \"dtype\": dtype}\n    ed = ctx.ed = editor(editor_params)\n    ctx.registrar.hive.connect(hivename, ed, \"hivecls\")\n    ctx.hive_attributes = ed.hive_attributes.cell().set(hive_attributes)\n    ed.code_start.cell().set(hiveprocess_start)\n    ed.code_update.cell().set(hiveprocess_update)\n    ed.code_stop.cell().set(hiveprocess_stop)\n    ctx.export(ed)\n"
    }
  ],
  "main": {
    "type": "context",
    "like_process": false,
    "like_cell": false,
    "pins": {},
    "auto": [
      "cell1",
      "cell10",
      "cell11",
      "cell12",
      "cell13",
      "cell14",
      "cell15",
      "cell16",
      "cell17",
      "cell18",
      "cell19",
      "cell2",
      "cell20",
      "cell3",
      "cell4",
      "cell5",
      "cell6",
      "cell7",
      "cell8",
      "cell9",
      "registrar_object1",
      "registrar_object2",
      "registrar_object3",
      "registrar_object4"
    ],
    "children": {
      "c1": {
        "dtype": [
          "text",
          "code",
          "silk"
        ],
        "resource": {
          "filename": "vertexdata.silk",
          "lib": false,
          "mode": 5
        },
        "data": "Type Vec3 {\n  Float x\n  Float y\n  Float z\n}\n\nType VertexData {\n  Float a_lifetime\n  Vec3 a_startPosition\n  Vec3 a_endPosition\n}\n"
      },
      "c2": {
        "dtype": [
          "text",
          "code",
          "python"
        ],
        "resource": {
          "filename": "fireworkhive.py",
          "lib": false,
          "mode": 5
        },
        "data": "import hive\nimport numpy as np\nimport time\nfrom seamless.lib.hive.canvashive import canvashive\nfrom vispy import gloo\n\ndef build_fireworkhive(i, ex, args):\n    ex.canvas = canvashive(keys='interactive', size=(800, 600))\n    i.starttime = hive.attribute(data_type=\"float\")\n\n    def draw(self):\n        program = self.canvas.program\n        currtime = time.time()\n        if self._starttime is None or currtime - self._starttime > self.v_delay:\n            self.new_explosion()\n\n        # Draw\n        program['u_time'] = time.time() - self._starttime\n        program.draw('points')\n    i.draw = hive.modifier(draw)\n    hive.connect(ex.canvas.draw, i.draw)\n\n    def new_explosion(self):\n        program = self.canvas.program\n        if program is None:\n            return\n        vertexbuffer = self.canvas.v_vertexbuffer\n        # New centerpos\n        centerpos = np.random.uniform(-0.5, 0.5, (3,))\n        program['u_centerPosition'] = centerpos\n\n        # New color, scale alpha with N\n        N = len(vertexbuffer)\n        alpha = 1.0 / N ** 0.08\n        color = np.random.uniform(0.1, 0.9, (3,))\n\n        program['u_color'] = tuple(color) + (alpha,)\n\n        # Create new vertex data\n        p = vertexbuffer.make_numpy()\n        p['a_lifetime'] = np.random.normal(2.0, 0.5, (N,))\n        start = p['a_startPosition']\n        end = p['a_endPosition']\n        start_values = np.random.normal(0.0, 0.2, (N, 3))\n        end_values = np.random.normal(0.0, 0.2, (N, 3))\n        # The following does not work in Numpy:\n        # start[:] = start_values\n        # end[:] = end_values\n        for n in range(3):\n            field = (\"x\",\"y\",\"z\")[n]\n            start[field] = start_values[:, n]\n            end[field] = end_values[:, n]\n\n        # Set time to zero\n        self._starttime = time.time()\n\n        program.bind(gloo.VertexBuffer(p))\n    i.new_explosion = hive.modifier(new_explosion)\n    hive.trigger(ex.canvas.program_rebuilt, i.new_explosion)\n\n    #make new_explosion triggerable from the outside\n    i.t_new_explosion = hive.triggerfunc(i.new_explosion)\n    ex.new_explosion = hive.hook(i.t_new_explosion)\n    ex.v_delay = hive.attribute(data_type=\"float\", start_value=1.5)\n    i.p_delay = hive.push_in(ex.v_delay)\n    ex.delay = hive.antenna(i.p_delay)\n\n    #export the canvas parameters\n    ex.vert_shader = hive.antenna(ex.canvas.vert_shader)\n    ex.frag_shader = hive.antenna(ex.canvas.frag_shader)\n    ex.texture_dict = hive.antenna(ex.canvas.texture_dict)\n    ex.vertexbuffer = hive.antenna(ex.canvas.vertexbuffer)\n    #ex.title = hive.antenna(ex.canvas.title)\n\n    #export the destroy() function\n    def destroy(self):\n        self.canvas.destroy()\n    i.destroy = hive.modifier(destroy)\n    ex.destroy = hive.entry(i.destroy)\n\nfireworkhive = hive.hive(\"fireworkhive\", build_fireworkhive)\n"
      },
      "cell1": {
        "dtype": [
          "text",
          "code",
          "vertexshader"
        ],
        "resource": {
          "filename": "fireworks.vert",
          "lib": false,
          "mode": 5
        },
        "data": "uniform float u_time;\nuniform vec3 u_centerPosition;\nattribute float a_lifetime;\nattribute vec3 a_startPosition;\nattribute vec3 a_endPosition;\nvarying float v_lifetime;\n\nvoid main () {\n    if (u_time <= a_lifetime)\n    {\n        gl_Position.xyz = a_startPosition + (u_time * a_endPosition);\n        gl_Position.xyz += u_centerPosition;\n        gl_Position.y -= 1.0 * u_time * u_time;\n        gl_Position.w = 1.0;\n    }\n    else\n        gl_Position = vec4(-1000, -1000, 0, 0);\n\n    v_lifetime = 1.0 - (u_time / a_lifetime);\n    v_lifetime = clamp(v_lifetime, 0.0, 1.0);\n    gl_PointSize = (v_lifetime * v_lifetime) * 40.0;\n}\n"
      },
      "cell10": {
        "dtype": "float",
        "data": "0.2"
      },
      "cell11": {
        "dtype": "str",
        "data": "/tmp/fireworks/Fragment_shader.glsl"
      },
      "cell12": {
        "dtype": "float",
        "data": "0.2"
      },
      "cell13": {
        "dtype": "str",
        "data": "/tmp/fireworks/Vertex_format.silk"
      },
      "cell14": {
        "dtype": "float",
        "data": "0.2"
      },
      "cell15": {
        "dtype": "str",
        "data": "/tmp/fireworks/Hive.py"
      },
      "cell16": {
        "dtype": "float",
        "data": "0.2"
      },
      "cell17": {
        "dtype": "str",
        "data": "/tmp/fireworks/Vertexbuffer_generation.py"
      },
      "cell18": {
        "dtype": "float",
        "data": "0.2"
      },
      "cell19": {
        "dtype": "str",
        "data": "/tmp/fireworks/Texture_dict_generation.py"
      },
      "cell2": {
        "dtype": [
          "text",
          "code",
          "fragmentshader"
        ],
        "resource": {
          "filename": "fireworks.frag",
          "lib": false,
          "mode": 5
        },
        "data": "precision highp float;\nuniform sampler2D texture1;\nuniform vec4 u_color;\nvarying float v_lifetime;\nuniform highp sampler2D s_texture;\n\nvoid main()\n{\n    highp vec4 texColor;\n    texColor = texture2D(s_texture, gl_PointCoord);\n    gl_FragColor = vec4(u_color) * texColor;\n    gl_FragColor.a *= v_lifetime;\n}\n"
      },
      "cell20": {
        "dtype": "float",
        "data": "0.2"
      },
      "cell3": {
        "dtype": "int",
        "data": "10000"
      },
      "cell4": {
        "dtype": [
          "text",
          "code",
          "python"
        ],
        "data": "\nassert N > 0\nimport numpy as np\ndata = np.zeros(N, VertexData.dtype)\ndata = VertexDataArray.from_numpy(data, copy=False, validate=False)\nreturn data\n"
      },
      "cell5": {
        "dtype": "object"
      },
      "cell6": {
        "dtype": [
          "text",
          "code",
          "python"
        ],
        "data": "\nimport numpy as np\n# Create a texture\nim1 = np.random.normal(\n    0.8, 0.3, (radius * 2 + 1, radius * 2 + 1)).astype(np.float32)\n\n# Mask it with a disk\nL = np.linspace(-radius, radius, 2 * radius + 1)\n(X, Y) = np.meshgrid(L, L)\nim1 *= np.array((X ** 2 + Y ** 2) <= radius * radius, dtype='float32')\nreturn {'s_texture': im1}\n"
      },
      "cell7": {
        "dtype": "int",
        "data": "32"
      },
      "cell8": {
        "dtype": "object"
      },
      "cell9": {
        "dtype": "str",
        "data": "/tmp/fireworks/Vertex_shader.glsl"
      },
      "delay": {
        "dtype": "float",
        "data": "1.5"
      },
      "ed_N": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "title": "ed_N.ed.title",
          "value": "ed_N.ed.value"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "data": "N"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/gui/cell-basic_editor_int.py",
              "lib": true,
              "mode": 2
            },
            "data": "from seamless.qt.QtWidgets import QSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(title.get())\nw.show()\nb = QSpinBox()\nb.setMaximum(1000000)\nb.setValue(value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(value.set)\n"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "w.destroy()"
          },
          "cell4": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/gui/cell-basic_editor_UPDATE.py",
              "lib": true,
              "mode": 2
            },
            "data": "if value.updated:\n    b.setValue(value.get())\nif title.updated:\n    w.setWindowTitle(title.get())\n",
            "owner": "ed_N.ed.code_update"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "title": {
                "dtype": "str",
                "pin": "input"
              },
              "value": {
                "dtype": "int",
                "pin": "edit"
              }
            }
          }
        }
      },
      "ed_delay": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "title": "ed_delay.ed.title",
          "value": "ed_delay.ed.value"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "data": "Delay"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/gui/cell-basic_editor_float.py",
              "lib": true,
              "mode": 2
            },
            "data": "from seamless.qt.QtWidgets import QDoubleSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(title.get())\nw.show()\nb = QDoubleSpinBox()\nb.setSingleStep(0.1)\nb.setMaximum(1000000)\nb.setValue(value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(value.set)\n"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "w.destroy()"
          },
          "cell4": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/gui/cell-basic_editor_UPDATE.py",
              "lib": true,
              "mode": 2
            },
            "data": "if value.updated:\n    b.setValue(value.get())\nif title.updated:\n    w.setWindowTitle(title.get())\n",
            "owner": "ed_delay.ed.code_update"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "title": {
                "dtype": "str",
                "pin": "input"
              },
              "value": {
                "dtype": "float",
                "pin": "edit"
              }
            }
          }
        }
      },
      "ed_frag": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "filepath": "ed_frag.ed.filepath",
          "latency": "ed_frag.ed.latency",
          "value": "ed_frag.ed.value"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/cell-filelink-start.py",
              "lib": true,
              "mode": 2
            },
            "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n\n    value = EditPin(\"test\")\n\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    filepath = Getter(os.path.join(directory, filename))\n    latency = Getter(float(sys.argv[3]))\n    print(\"Edit in \" + filepath.get())\n\nimport os, time, functools\nfrom seamless import add_work\nfrom threading import Thread, RLock\nlast_value = None\n\ndef write_file(fpath):\n    global last_mtime, last_value\n    val = str(value.get())\n    if last_value == val:\n        return\n    with lock:\n        if last_value != val:\n            with open(fpath, \"w\") as f:\n                f.write(val)\n                last_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value\n    fpath = filepath.get()\n    while 1:\n        time.sleep(latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            write_file(fpath)\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                if stat.st_mtime > last_mtime:\n                    data = None\n                    with open(fpath) as f:\n                        data = f.read()\n                    if data is not None:\n                        w = functools.partial(value.set, data)\n                        add_work(w)\n                        last_value = data\n                    last_mtime = stat.st_mtime\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nval = str(value.get())\nwrite_file(filepath.get())\nt.start()\n"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "write_file(filepath.get())"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "t.join(0)"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "filepath": {
                "dtype": "str",
                "pin": "input"
              },
              "latency": {
                "dtype": "float",
                "pin": "input"
              },
              "value": {
                "dtype": [
                  "text",
                  "code",
                  "fragmentshader"
                ],
                "pin": "edit"
              }
            }
          }
        }
      },
      "ed_gen_texture_dict_params": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "title": "ed_gen_texture_dict_params.ed.title",
          "value": "ed_gen_texture_dict_params.ed.value"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "data": "Texdict gen params"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/gui/cell-basic_editor_json.py",
              "lib": true,
              "mode": 2
            },
            "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\nimport json\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(title.get())\n\nclass MyTextEdit(QTextEdit):\n    def focusOutEvent(self, event):\n        value.set(self.toPlainText())\n        QTextEdit.focusOutEvent(self, event)\n\nw.show()\nb = MyTextEdit()\nb.setFontPointSize(15)\nb.setText(json.dumps(value.get(), indent=2))\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "w.destroy()"
          },
          "cell4": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/gui/cell-basic_editor_json_UPDATE.py",
              "lib": true,
              "mode": 2
            },
            "data": "if value.updated:\n    b.setText(json.dumps(value.get(), indent=2))\nif title.updated:\n    w.setWindowTitle(title.get())\n",
            "owner": "ed_gen_texture_dict_params.ed.code_update"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "title": {
                "dtype": "str",
                "pin": "input"
              },
              "value": {
                "dtype": "json",
                "pin": "edit"
              }
            }
          }
        }
      },
      "ed_gen_texturedict": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "filepath": "ed_gen_texturedict.ed.filepath",
          "latency": "ed_gen_texturedict.ed.latency",
          "value": "ed_gen_texturedict.ed.value"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/cell-filelink-start.py",
              "lib": true,
              "mode": 2
            },
            "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n\n    value = EditPin(\"test\")\n\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    filepath = Getter(os.path.join(directory, filename))\n    latency = Getter(float(sys.argv[3]))\n    print(\"Edit in \" + filepath.get())\n\nimport os, time, functools\nfrom seamless import add_work\nfrom threading import Thread, RLock\nlast_value = None\n\ndef write_file(fpath):\n    global last_mtime, last_value\n    val = str(value.get())\n    if last_value == val:\n        return\n    with lock:\n        if last_value != val:\n            with open(fpath, \"w\") as f:\n                f.write(val)\n                last_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value\n    fpath = filepath.get()\n    while 1:\n        time.sleep(latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            write_file(fpath)\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                if stat.st_mtime > last_mtime:\n                    data = None\n                    with open(fpath) as f:\n                        data = f.read()\n                    if data is not None:\n                        w = functools.partial(value.set, data)\n                        add_work(w)\n                        last_value = data\n                    last_mtime = stat.st_mtime\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nval = str(value.get())\nwrite_file(filepath.get())\nt.start()\n"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "write_file(filepath.get())"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "t.join(0)"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "filepath": {
                "dtype": "str",
                "pin": "input"
              },
              "latency": {
                "dtype": "float",
                "pin": "input"
              },
              "value": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "pin": "edit"
              }
            }
          }
        }
      },
      "ed_gen_vertexbuffer": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "filepath": "ed_gen_vertexbuffer.ed.filepath",
          "latency": "ed_gen_vertexbuffer.ed.latency",
          "value": "ed_gen_vertexbuffer.ed.value"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/cell-filelink-start.py",
              "lib": true,
              "mode": 2
            },
            "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n\n    value = EditPin(\"test\")\n\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    filepath = Getter(os.path.join(directory, filename))\n    latency = Getter(float(sys.argv[3]))\n    print(\"Edit in \" + filepath.get())\n\nimport os, time, functools\nfrom seamless import add_work\nfrom threading import Thread, RLock\nlast_value = None\n\ndef write_file(fpath):\n    global last_mtime, last_value\n    val = str(value.get())\n    if last_value == val:\n        return\n    with lock:\n        if last_value != val:\n            with open(fpath, \"w\") as f:\n                f.write(val)\n                last_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value\n    fpath = filepath.get()\n    while 1:\n        time.sleep(latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            write_file(fpath)\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                if stat.st_mtime > last_mtime:\n                    data = None\n                    with open(fpath) as f:\n                        data = f.read()\n                    if data is not None:\n                        w = functools.partial(value.set, data)\n                        add_work(w)\n                        last_value = data\n                    last_mtime = stat.st_mtime\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nval = str(value.get())\nwrite_file(filepath.get())\nt.start()\n"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "write_file(filepath.get())"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "t.join(0)"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "filepath": {
                "dtype": "str",
                "pin": "input"
              },
              "latency": {
                "dtype": "float",
                "pin": "input"
              },
              "value": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "pin": "edit"
              }
            }
          }
        }
      },
      "ed_gen_vertexbuffer_params": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "title": "ed_gen_vertexbuffer_params.ed.title",
          "value": "ed_gen_vertexbuffer_params.ed.value"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "data": "Vertexbuffer gen params"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/gui/cell-basic_editor_json.py",
              "lib": true,
              "mode": 2
            },
            "data": "from seamless.qt.QtWidgets import QTextEdit, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\nfrom PyQt5.QtGui import QColor\nimport json\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\n#vbox.addStretch(1)\nw.resize(600,600)\nw.setLayout(vbox)\nw.setWindowTitle(title.get())\n\nclass MyTextEdit(QTextEdit):\n    def focusOutEvent(self, event):\n        value.set(self.toPlainText())\n        QTextEdit.focusOutEvent(self, event)\n\nw.show()\nb = MyTextEdit()\nb.setFontPointSize(15)\nb.setText(json.dumps(value.get(), indent=2))\n#b.setFontItalic(True)\n#b.setTextColor(QColor(255,0,0))\nvbox.addWidget(b)\n"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "w.destroy()"
          },
          "cell4": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/gui/cell-basic_editor_json_UPDATE.py",
              "lib": true,
              "mode": 2
            },
            "data": "if value.updated:\n    b.setText(json.dumps(value.get(), indent=2))\nif title.updated:\n    w.setWindowTitle(title.get())\n",
            "owner": "ed_gen_vertexbuffer_params.ed.code_update"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "title": {
                "dtype": "str",
                "pin": "input"
              },
              "value": {
                "dtype": "json",
                "pin": "edit"
              }
            }
          }
        }
      },
      "ed_hive": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "filepath": "ed_hive.ed.filepath",
          "latency": "ed_hive.ed.latency",
          "value": "ed_hive.ed.value"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/cell-filelink-start.py",
              "lib": true,
              "mode": 2
            },
            "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n\n    value = EditPin(\"test\")\n\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    filepath = Getter(os.path.join(directory, filename))\n    latency = Getter(float(sys.argv[3]))\n    print(\"Edit in \" + filepath.get())\n\nimport os, time, functools\nfrom seamless import add_work\nfrom threading import Thread, RLock\nlast_value = None\n\ndef write_file(fpath):\n    global last_mtime, last_value\n    val = str(value.get())\n    if last_value == val:\n        return\n    with lock:\n        if last_value != val:\n            with open(fpath, \"w\") as f:\n                f.write(val)\n                last_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value\n    fpath = filepath.get()\n    while 1:\n        time.sleep(latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            write_file(fpath)\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                if stat.st_mtime > last_mtime:\n                    data = None\n                    with open(fpath) as f:\n                        data = f.read()\n                    if data is not None:\n                        w = functools.partial(value.set, data)\n                        add_work(w)\n                        last_value = data\n                    last_mtime = stat.st_mtime\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nval = str(value.get())\nwrite_file(filepath.get())\nt.start()\n"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "write_file(filepath.get())"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "t.join(0)"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "filepath": {
                "dtype": "str",
                "pin": "input"
              },
              "latency": {
                "dtype": "float",
                "pin": "input"
              },
              "value": {
                "dtype": [
                  "text",
                  "code",
                  "python"
                ],
                "pin": "edit"
              }
            }
          }
        }
      },
      "ed_radius": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "title": "ed_radius.ed.title",
          "value": "ed_radius.ed.value"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3",
          "cell4"
        ],
        "children": {
          "cell1": {
            "dtype": "str",
            "data": "Radius"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/gui/cell-basic_editor_int.py",
              "lib": true,
              "mode": 2
            },
            "data": "from seamless.qt.QtWidgets import QSpinBox, QWidget, QVBoxLayout\nfrom seamless.qt.QtCore import Qt\n\nw = QWidget()\n#w.setWindowFlags(Qt.WindowStaysOnTopHint)\nw.setAttribute(Qt.WA_ShowWithoutActivating)\nvbox = QVBoxLayout()\nvbox.addStretch(1)\nw.setLayout(vbox)\nw.resize(300,100)\nw.setWindowTitle(title.get())\nw.show()\nb = QSpinBox()\nb.setMaximum(1000000)\nb.setValue(value.get())\nvbox.addWidget(b)\nb.valueChanged.connect(value.set)\n"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "w.destroy()"
          },
          "cell4": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/gui/cell-basic_editor_UPDATE.py",
              "lib": true,
              "mode": 2
            },
            "data": "if value.updated:\n    b.setValue(value.get())\nif title.updated:\n    w.setWindowTitle(title.get())\n",
            "owner": "ed_radius.ed.code_update"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "title": {
                "dtype": "str",
                "pin": "input"
              },
              "value": {
                "dtype": "int",
                "pin": "edit"
              }
            }
          }
        }
      },
      "ed_vert": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "filepath": "ed_vert.ed.filepath",
          "latency": "ed_vert.ed.latency",
          "value": "ed_vert.ed.value"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/cell-filelink-start.py",
              "lib": true,
              "mode": 2
            },
            "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n\n    value = EditPin(\"test\")\n\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    filepath = Getter(os.path.join(directory, filename))\n    latency = Getter(float(sys.argv[3]))\n    print(\"Edit in \" + filepath.get())\n\nimport os, time, functools\nfrom seamless import add_work\nfrom threading import Thread, RLock\nlast_value = None\n\ndef write_file(fpath):\n    global last_mtime, last_value\n    val = str(value.get())\n    if last_value == val:\n        return\n    with lock:\n        if last_value != val:\n            with open(fpath, \"w\") as f:\n                f.write(val)\n                last_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value\n    fpath = filepath.get()\n    while 1:\n        time.sleep(latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            write_file(fpath)\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                if stat.st_mtime > last_mtime:\n                    data = None\n                    with open(fpath) as f:\n                        data = f.read()\n                    if data is not None:\n                        w = functools.partial(value.set, data)\n                        add_work(w)\n                        last_value = data\n                    last_mtime = stat.st_mtime\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nval = str(value.get())\nwrite_file(filepath.get())\nt.start()\n"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "write_file(filepath.get())"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "t.join(0)"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "filepath": {
                "dtype": "str",
                "pin": "input"
              },
              "latency": {
                "dtype": "float",
                "pin": "input"
              },
              "value": {
                "dtype": [
                  "text",
                  "code",
                  "vertexshader"
                ],
                "pin": "edit"
              }
            }
          }
        }
      },
      "ed_vertexformat": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "filepath": "ed_vertexformat.ed.filepath",
          "latency": "ed_vertexformat.ed.latency",
          "value": "ed_vertexformat.ed.value"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "resource": {
              "filename": "/cell-filelink-start.py",
              "lib": true,
              "mode": 2
            },
            "data": "if __name__ == \"__main__\":\n    #test with ipython -i\n    import sys, os\n    class EditPin:\n        def __init__(self, value):\n            self.value = value\n        def set(self, value):\n            print(\"SET\", value)\n            self.value = value\n        def get(self):\n            return self.value\n\n    class Getter:\n        def __init__(self, arg):\n            self.arg = arg\n        def get(self):\n            return self.arg\n\n    value = EditPin(\"test\")\n\n    directory = sys.argv[1]\n    filename = sys.argv[2]\n    filepath = Getter(os.path.join(directory, filename))\n    latency = Getter(float(sys.argv[3]))\n    print(\"Edit in \" + filepath.get())\n\nimport os, time, functools\nfrom seamless import add_work\nfrom threading import Thread, RLock\nlast_value = None\n\ndef write_file(fpath):\n    global last_mtime, last_value\n    val = str(value.get())\n    if last_value == val:\n        return\n    with lock:\n        if last_value != val:\n            with open(fpath, \"w\") as f:\n                f.write(val)\n                last_value = val\n            last_time = time.time()\n            try:\n                stat = os.stat(fpath)\n                last_mtime = stat.st_mtime\n            except:\n                pass\n\ndef poll():\n    global last_time, last_mtime, last_value\n    fpath = filepath.get()\n    while 1:\n        time.sleep(latency.get())\n        curr_time = time.time()\n        last_time = curr_time\n        if not os.path.exists(fpath):\n            write_file(fpath)\n        else:\n            with lock:\n                stat = os.stat(fpath)\n                if stat.st_mtime > last_mtime:\n                    data = None\n                    with open(fpath) as f:\n                        data = f.read()\n                    if data is not None:\n                        w = functools.partial(value.set, data)\n                        add_work(w)\n                        last_value = data\n                    last_mtime = stat.st_mtime\n\nt = Thread(target=poll)\nt.setDaemon(True)\nlock = RLock()\nval = str(value.get())\nwrite_file(filepath.get())\nt.start()\n"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "write_file(filepath.get())"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "t.join(0)"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "filepath": {
                "dtype": "str",
                "pin": "input"
              },
              "latency": {
                "dtype": "float",
                "pin": "input"
              },
              "value": {
                "dtype": [
                  "text",
                  "code",
                  "silk"
                ],
                "pin": "edit"
              }
            }
          }
        }
      },
      "gen_texture_dict": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "output": {
            "dtype": "object",
            "pin": "output"
          },
          "radius": {
            "dtype": "int",
            "pin": "input"
          }
        }
      },
      "gen_texture_dict_params": {
        "dtype": [
          "json",
          "seamless",
          "transformer_params"
        ],
        "data": "{\"output\": {\"dtype\": \"object\", \"pin\": \"output\"}, \"radius\": {\"dtype\": \"int\", \"pin\": \"input\"}}"
      },
      "gen_vertexbuffer": {
        "type": "transformer",
        "mode": "thread",
        "params": {
          "N": {
            "dtype": "int",
            "pin": "input"
          },
          "VertexData": {
            "pin": "registrar",
            "registrar": "silk"
          },
          "VertexDataArray": {
            "pin": "registrar",
            "registrar": "silk"
          },
          "output": {
            "dtype": "object",
            "pin": "output"
          }
        }
      },
      "gen_vertexbuffer_params": {
        "dtype": [
          "json",
          "seamless",
          "transformer_params"
        ],
        "data": "{\"output\": {\"dtype\": \"object\", \"pin\": \"output\"}, \"VertexData\": {\"registrar\": \"silk\", \"pin\": \"registrar\"}, \"N\": {\"dtype\": \"int\", \"pin\": \"input\"}, \"VertexDataArray\": {\"registrar\": \"silk\", \"pin\": \"registrar\"}}"
      },
      "hp": {
        "type": "context",
        "like_process": true,
        "like_cell": false,
        "pins": {
          "delay": "hp.ed.delay",
          "frag_shader": "hp.ed.frag_shader",
          "texture_dict": "hp.ed.texture_dict",
          "vert_shader": "hp.ed.vert_shader",
          "vertexbuffer": "hp.ed.vertexbuffer"
        },
        "auto": [
          "cell1",
          "cell2",
          "cell3"
        ],
        "children": {
          "cell1": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "def hiveprocess_start():\n    import hive\n    global myhive\n    myhive = hivecls()\n    for attr, hivepin_type in hive_attributes.get().items():\n        if hivepin_type == \"push_out\":\n            output = globals()[attr]\n            hive.connect(getattr(myhive, attr), hive.push_in(output.set))\n"
          },
          "cell2": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "def hiveprocess_update():\n    for attr, hivepin_type in hive_attributes.get().items():\n        at = globals()[attr]\n        try:\n            if not at.updated:\n                continue\n        except AttributeError:\n            continue\n        value = at.get()\n        if hivepin_type == \"attribute\":\n            setattr(myhive, attr, value)\n        elif hivepin_type == \"push_in\":\n            getattr(myhive, attr).push(value)\n"
          },
          "cell3": {
            "dtype": [
              "text",
              "code",
              "python"
            ],
            "data": "def hiveprocess_stop():\n    global myhive\n    if hasattr(myhive, \"destroy\"):\n        myhive.destroy()\n    del myhive\n"
          },
          "ed": {
            "type": "editor",
            "mode": "sync",
            "params": {
              "delay": {
                "dtype": "float",
                "pin": "input"
              },
              "frag_shader": {
                "dtype": [
                  "text",
                  "code",
                  "fragmentshader"
                ],
                "pin": "input"
              },
              "hive_attributes": {
                "dtype": "json",
                "pin": "input"
              },
              "texture_dict": {
                "dtype": "object",
                "pin": "input"
              },
              "vert_shader": {
                "dtype": [
                  "text",
                  "code",
                  "vertexshader"
                ],
                "pin": "input"
              },
              "vertexbuffer": {
                "dtype": "object",
                "pin": "input"
              }
            }
          },
          "hive_attributes": {
            "dtype": "json",
            "data": "{\"frag_shader\": \"push_in\", \"texture_dict\": \"push_in\", \"delay\": \"push_in\", \"vert_shader\": \"push_in\", \"vertexbuffer\": \"push_in\"}"
          }
        }
      },
      "registrar_object1": {
        "registrar": "silk",
        "registered": [
          "Vec3",
          "VertexData"
        ],
        "data": "Type Vec3 {\n  Float x\n  Float y\n  Float z\n}\n\nType VertexData {\n  Float a_lifetime\n  Vec3 a_startPosition\n  Vec3 a_endPosition\n}\n",
        "data_name": null
      },
      "registrar_object2": {
        "registrar": "hive",
        "registered": [
          "canvashive",
          "fireworkhive",
          "hive",
          "time",
          "np",
          "build_fireworkhive",
          "gloo"
        ],
        "data": "import hive\nimport numpy as np\nimport time\nfrom seamless.lib.hive.canvashive import canvashive\nfrom vispy import gloo\n\ndef build_fireworkhive(i, ex, args):\n    ex.canvas = canvashive(keys='interactive', size=(800, 600))\n    i.starttime = hive.attribute(data_type=\"float\")\n\n    def draw(self):\n        program = self.canvas.program\n        currtime = time.time()\n        if self._starttime is None or currtime - self._starttime > self.v_delay:\n            self.new_explosion()\n\n        # Draw\n        program['u_time'] = time.time() - self._starttime\n        program.draw('points')\n    i.draw = hive.modifier(draw)\n    hive.connect(ex.canvas.draw, i.draw)\n\n    def new_explosion(self):\n        program = self.canvas.program\n        if program is None:\n            return\n        vertexbuffer = self.canvas.v_vertexbuffer\n        # New centerpos\n        centerpos = np.random.uniform(-0.5, 0.5, (3,))\n        program['u_centerPosition'] = centerpos\n\n        # New color, scale alpha with N\n        N = len(vertexbuffer)\n        alpha = 1.0 / N ** 0.08\n        color = np.random.uniform(0.1, 0.9, (3,))\n\n        program['u_color'] = tuple(color) + (alpha,)\n\n        # Create new vertex data\n        p = vertexbuffer.make_numpy()\n        p['a_lifetime'] = np.random.normal(2.0, 0.5, (N,))\n        start = p['a_startPosition']\n        end = p['a_endPosition']\n        start_values = np.random.normal(0.0, 0.2, (N, 3))\n        end_values = np.random.normal(0.0, 0.2, (N, 3))\n        # The following does not work in Numpy:\n        # start[:] = start_values\n        # end[:] = end_values\n        for n in range(3):\n            field = (\"x\",\"y\",\"z\")[n]\n            start[field] = start_values[:, n]\n            end[field] = end_values[:, n]\n\n        # Set time to zero\n        self._starttime = time.time()\n\n        program.bind(gloo.VertexBuffer(p))\n    i.new_explosion = hive.modifier(new_explosion)\n    hive.trigger(ex.canvas.program_rebuilt, i.new_explosion)\n\n    #make new_explosion triggerable from the outside\n    i.t_new_explosion = hive.triggerfunc(i.new_explosion)\n    ex.new_explosion = hive.hook(i.t_new_explosion)\n    ex.v_delay = hive.attribute(data_type=\"float\", start_value=1.5)\n    i.p_delay = hive.push_in(ex.v_delay)\n    ex.delay = hive.antenna(i.p_delay)\n\n    #export the canvas parameters\n    ex.vert_shader = hive.antenna(ex.canvas.vert_shader)\n    ex.frag_shader = hive.antenna(ex.canvas.frag_shader)\n    ex.texture_dict = hive.antenna(ex.canvas.texture_dict)\n    ex.vertexbuffer = hive.antenna(ex.canvas.vertexbuffer)\n    #ex.title = hive.antenna(ex.canvas.title)\n\n    #export the destroy() function\n    def destroy(self):\n        self.canvas.destroy()\n    i.destroy = hive.modifier(destroy)\n    ex.destroy = hive.entry(i.destroy)\n\nfireworkhive = hive.hive(\"fireworkhive\", build_fireworkhive)\n",
        "data_name": null
      },
      "registrar_object3": {
        "registrar": "silk",
        "registered": [
          "Vec3",
          "VertexData"
        ],
        "data": "Type Vec3 {\n  Float x\n  Float y\n  Float z\n}\n\nType VertexData {\n  Float a_lifetime\n  Vec3 a_startPosition\n  Vec3 a_endPosition\n}\n",
        "data_name": null
      },
      "registrar_object4": {
        "registrar": "hive",
        "registered": [
          "time",
          "np",
          "hive",
          "gloo",
          "fireworkhive",
          "build_fireworkhive",
          "canvashive"
        ],
        "data": "import hive\nimport numpy as np\nimport time\nfrom seamless.lib.hive.canvashive import canvashive\nfrom vispy import gloo\n\ndef build_fireworkhive(i, ex, args):\n    ex.canvas = canvashive(keys='interactive', size=(800, 600))\n    i.starttime = hive.attribute(data_type=\"float\")\n\n    def draw(self):\n        program = self.canvas.program\n        currtime = time.time()\n        if self._starttime is None or currtime - self._starttime > self.v_delay:\n            self.new_explosion()\n\n        # Draw\n        program['u_time'] = time.time() - self._starttime\n        program.draw('points')\n    i.draw = hive.modifier(draw)\n    hive.connect(ex.canvas.draw, i.draw)\n\n    def new_explosion(self):\n        program = self.canvas.program\n        if program is None:\n            return\n        vertexbuffer = self.canvas.v_vertexbuffer\n        # New centerpos\n        centerpos = np.random.uniform(-0.5, 0.5, (3,))\n        program['u_centerPosition'] = centerpos\n\n        # New color, scale alpha with N\n        N = len(vertexbuffer)\n        alpha = 1.0 / N ** 0.08\n        color = np.random.uniform(0.1, 0.9, (3,))\n\n        program['u_color'] = tuple(color) + (alpha,)\n\n        # Create new vertex data\n        p = vertexbuffer.make_numpy()\n        p['a_lifetime'] = np.random.normal(2.0, 0.5, (N,))\n        start = p['a_startPosition']\n        end = p['a_endPosition']\n        start_values = np.random.normal(0.0, 0.2, (N, 3))\n        end_values = np.random.normal(0.0, 0.2, (N, 3))\n        # The following does not work in Numpy:\n        # start[:] = start_values\n        # end[:] = end_values\n        for n in range(3):\n            field = (\"x\",\"y\",\"z\")[n]\n            start[field] = start_values[:, n]\n            end[field] = end_values[:, n]\n\n        # Set time to zero\n        self._starttime = time.time()\n\n        program.bind(gloo.VertexBuffer(p))\n    i.new_explosion = hive.modifier(new_explosion)\n    hive.trigger(ex.canvas.program_rebuilt, i.new_explosion)\n\n    #make new_explosion triggerable from the outside\n    i.t_new_explosion = hive.triggerfunc(i.new_explosion)\n    ex.new_explosion = hive.hook(i.t_new_explosion)\n    ex.v_delay = hive.attribute(data_type=\"float\", start_value=1.5)\n    i.p_delay = hive.push_in(ex.v_delay)\n    ex.delay = hive.antenna(i.p_delay)\n\n    #export the canvas parameters\n    ex.vert_shader = hive.antenna(ex.canvas.vert_shader)\n    ex.frag_shader = hive.antenna(ex.canvas.frag_shader)\n    ex.texture_dict = hive.antenna(ex.canvas.texture_dict)\n    ex.vertexbuffer = hive.antenna(ex.canvas.vertexbuffer)\n    #ex.title = hive.antenna(ex.canvas.title)\n\n    #export the destroy() function\n    def destroy(self):\n        self.canvas.destroy()\n    i.destroy = hive.modifier(destroy)\n    ex.destroy = hive.entry(i.destroy)\n\nfireworkhive = hive.hive(\"fireworkhive\", build_fireworkhive)\n",
        "data_name": null
      }
    },
    "macro_objects": [
      {
        "args": [
          null
        ],
        "kwargs": {},
        "cell_args": {
          "_arg1": "gen_vertexbuffer_params"
        },
        "macro_module_name": "seamless.core.transformer",
        "macro_func_name": "transformer",
        "macro_order": 0,
        "target": "gen_vertexbuffer"
      },
      {
        "args": [
          null
        ],
        "kwargs": {},
        "cell_args": {
          "_arg1": "gen_texture_dict_params"
        },
        "macro_module_name": "seamless.core.transformer",
        "macro_func_name": "transformer",
        "macro_order": 1,
        "target": "gen_texture_dict"
      }
    ],
    "macro_listeners": [
      {
        "cell": "gen_vertexbuffer_params",
        "macro_target": "gen_vertexbuffer",
        "macro_arg": "_arg1"
      },
      {
        "cell": "gen_texture_dict_params",
        "macro_target": "gen_texture_dict",
        "macro_arg": "_arg1"
      }
    ],
    "registrar_items": [
      {
        "registrar_name": "silk",
        "dtype": [
          "text",
          "code",
          "silk"
        ],
        "data": "Type Vec3 {\n  Float x\n  Float y\n  Float z\n}\n\nType VertexData {\n  Float a_lifetime\n  Vec3 a_startPosition\n  Vec3 a_endPosition\n}\n",
        "data_name": null
      },
      {
        "registrar_name": "hive",
        "dtype": [
          "text",
          "code",
          "python"
        ],
        "data": "import hive\nimport numpy as np\nimport time\nfrom seamless.lib.hive.canvashive import canvashive\nfrom vispy import gloo\n\ndef build_fireworkhive(i, ex, args):\n    ex.canvas = canvashive(keys='interactive', size=(800, 600))\n    i.starttime = hive.attribute(data_type=\"float\")\n\n    def draw(self):\n        program = self.canvas.program\n        currtime = time.time()\n        if self._starttime is None or currtime - self._starttime > self.v_delay:\n            self.new_explosion()\n\n        # Draw\n        program['u_time'] = time.time() - self._starttime\n        program.draw('points')\n    i.draw = hive.modifier(draw)\n    hive.connect(ex.canvas.draw, i.draw)\n\n    def new_explosion(self):\n        program = self.canvas.program\n        if program is None:\n            return\n        vertexbuffer = self.canvas.v_vertexbuffer\n        # New centerpos\n        centerpos = np.random.uniform(-0.5, 0.5, (3,))\n        program['u_centerPosition'] = centerpos\n\n        # New color, scale alpha with N\n        N = len(vertexbuffer)\n        alpha = 1.0 / N ** 0.08\n        color = np.random.uniform(0.1, 0.9, (3,))\n\n        program['u_color'] = tuple(color) + (alpha,)\n\n        # Create new vertex data\n        p = vertexbuffer.make_numpy()\n        p['a_lifetime'] = np.random.normal(2.0, 0.5, (N,))\n        start = p['a_startPosition']\n        end = p['a_endPosition']\n        start_values = np.random.normal(0.0, 0.2, (N, 3))\n        end_values = np.random.normal(0.0, 0.2, (N, 3))\n        # The following does not work in Numpy:\n        # start[:] = start_values\n        # end[:] = end_values\n        for n in range(3):\n            field = (\"x\",\"y\",\"z\")[n]\n            start[field] = start_values[:, n]\n            end[field] = end_values[:, n]\n\n        # Set time to zero\n        self._starttime = time.time()\n\n        program.bind(gloo.VertexBuffer(p))\n    i.new_explosion = hive.modifier(new_explosion)\n    hive.trigger(ex.canvas.program_rebuilt, i.new_explosion)\n\n    #make new_explosion triggerable from the outside\n    i.t_new_explosion = hive.triggerfunc(i.new_explosion)\n    ex.new_explosion = hive.hook(i.t_new_explosion)\n    ex.v_delay = hive.attribute(data_type=\"float\", start_value=1.5)\n    i.p_delay = hive.push_in(ex.v_delay)\n    ex.delay = hive.antenna(i.p_delay)\n\n    #export the canvas parameters\n    ex.vert_shader = hive.antenna(ex.canvas.vert_shader)\n    ex.frag_shader = hive.antenna(ex.canvas.frag_shader)\n    ex.texture_dict = hive.antenna(ex.canvas.texture_dict)\n    ex.vertexbuffer = hive.antenna(ex.canvas.vertexbuffer)\n    #ex.title = hive.antenna(ex.canvas.title)\n\n    #export the destroy() function\n    def destroy(self):\n        self.canvas.destroy()\n    i.destroy = hive.modifier(destroy)\n    ex.destroy = hive.entry(i.destroy)\n\nfireworkhive = hive.hive(\"fireworkhive\", build_fireworkhive)\n",
        "data_name": null
      }
    ],
    "registrar_listeners": [
      {
        "registrar": "hive",
        "key": "fireworkhive",
        "target_type": "process",
        "target_process": "hp.ed",
        "namespace_name": "hivecls"
      },
      {
        "registrar": "silk",
        "key": "VertexData",
        "target_type": "process",
        "target_process": "gen_vertexbuffer",
        "namespace_name": "VertexData"
      },
      {
        "registrar": "silk",
        "key": "VertexData",
        "target_type": "process",
        "target_process": "gen_vertexbuffer",
        "namespace_name": "VertexData"
      },
      {
        "registrar": "silk",
        "key": "VertexDataArray",
        "target_type": "process",
        "target_process": "gen_vertexbuffer",
        "namespace_name": "VertexDataArray"
      },
      {
        "registrar": "silk",
        "key": "VertexDataArray",
        "target_type": "process",
        "target_process": "gen_vertexbuffer",
        "namespace_name": "VertexDataArray"
      }
    ],
    "registrar_cells": [
      {
        "cell": "c1",
        "macro_target": "registrar_object1",
        "registrar": "silk"
      },
      {
        "cell": "c2",
        "macro_target": "registrar_object2",
        "registrar": "hive"
      }
    ],
    "pin_cell_connections": [
      [
        "gen_texture_dict.output",
        "cell8"
      ],
      [
        "gen_vertexbuffer.output",
        "cell5"
      ]
    ],
    "cell_pin_connections": [
      [
        "c1",
        "ed_vertexformat.ed.value"
      ],
      [
        "c2",
        "ed_hive.ed.value"
      ],
      [
        "cell10",
        "ed_vert.ed.latency"
      ],
      [
        "cell11",
        "ed_frag.ed.filepath"
      ],
      [
        "cell12",
        "ed_frag.ed.latency"
      ],
      [
        "cell13",
        "ed_vertexformat.ed.filepath"
      ],
      [
        "cell14",
        "ed_vertexformat.ed.latency"
      ],
      [
        "cell15",
        "ed_hive.ed.filepath"
      ],
      [
        "cell16",
        "ed_hive.ed.latency"
      ],
      [
        "cell17",
        "ed_gen_vertexbuffer.ed.filepath"
      ],
      [
        "cell18",
        "ed_gen_vertexbuffer.ed.latency"
      ],
      [
        "cell19",
        "ed_gen_texturedict.ed.filepath"
      ],
      [
        "cell1",
        "ed_vert.ed.value"
      ],
      [
        "cell1",
        "hp.ed.vert_shader"
      ],
      [
        "cell20",
        "ed_gen_texturedict.ed.latency"
      ],
      [
        "cell2",
        "ed_frag.ed.value"
      ],
      [
        "cell2",
        "hp.ed.frag_shader"
      ],
      [
        "cell3",
        "ed_N.ed.value"
      ],
      [
        "cell3",
        "gen_vertexbuffer.N"
      ],
      [
        "cell4",
        "ed_gen_vertexbuffer.ed.value"
      ],
      [
        "cell4",
        "gen_vertexbuffer.code"
      ],
      [
        "cell5",
        "hp.ed.vertexbuffer"
      ],
      [
        "cell6",
        "ed_gen_texturedict.ed.value"
      ],
      [
        "cell6",
        "gen_texture_dict.code"
      ],
      [
        "cell7",
        "ed_radius.ed.value"
      ],
      [
        "cell7",
        "gen_texture_dict.radius"
      ],
      [
        "cell8",
        "hp.ed.texture_dict"
      ],
      [
        "cell9",
        "ed_vert.ed.filepath"
      ],
      [
        "delay",
        "ed_delay.ed.value"
      ],
      [
        "delay",
        "hp.ed.delay"
      ],
      [
        "ed_N.cell1",
        "ed_N.ed.title"
      ],
      [
        "ed_N.cell2",
        "ed_N.ed.code_start"
      ],
      [
        "ed_N.cell3",
        "ed_N.ed.code_stop"
      ],
      [
        "ed_N.cell4",
        "ed_N.ed.code_update"
      ],
      [
        "ed_delay.cell1",
        "ed_delay.ed.title"
      ],
      [
        "ed_delay.cell2",
        "ed_delay.ed.code_start"
      ],
      [
        "ed_delay.cell3",
        "ed_delay.ed.code_stop"
      ],
      [
        "ed_delay.cell4",
        "ed_delay.ed.code_update"
      ],
      [
        "ed_frag.cell1",
        "ed_frag.ed.code_start"
      ],
      [
        "ed_frag.cell2",
        "ed_frag.ed.code_update"
      ],
      [
        "ed_frag.cell3",
        "ed_frag.ed.code_stop"
      ],
      [
        "ed_gen_texture_dict_params.cell1",
        "ed_gen_texture_dict_params.ed.title"
      ],
      [
        "ed_gen_texture_dict_params.cell2",
        "ed_gen_texture_dict_params.ed.code_start"
      ],
      [
        "ed_gen_texture_dict_params.cell3",
        "ed_gen_texture_dict_params.ed.code_stop"
      ],
      [
        "ed_gen_texture_dict_params.cell4",
        "ed_gen_texture_dict_params.ed.code_update"
      ],
      [
        "ed_gen_texturedict.cell1",
        "ed_gen_texturedict.ed.code_start"
      ],
      [
        "ed_gen_texturedict.cell2",
        "ed_gen_texturedict.ed.code_update"
      ],
      [
        "ed_gen_texturedict.cell3",
        "ed_gen_texturedict.ed.code_stop"
      ],
      [
        "ed_gen_vertexbuffer.cell1",
        "ed_gen_vertexbuffer.ed.code_start"
      ],
      [
        "ed_gen_vertexbuffer.cell2",
        "ed_gen_vertexbuffer.ed.code_update"
      ],
      [
        "ed_gen_vertexbuffer.cell3",
        "ed_gen_vertexbuffer.ed.code_stop"
      ],
      [
        "ed_gen_vertexbuffer_params.cell1",
        "ed_gen_vertexbuffer_params.ed.title"
      ],
      [
        "ed_gen_vertexbuffer_params.cell2",
        "ed_gen_vertexbuffer_params.ed.code_start"
      ],
      [
        "ed_gen_vertexbuffer_params.cell3",
        "ed_gen_vertexbuffer_params.ed.code_stop"
      ],
      [
        "ed_gen_vertexbuffer_params.cell4",
        "ed_gen_vertexbuffer_params.ed.code_update"
      ],
      [
        "ed_hive.cell1",
        "ed_hive.ed.code_start"
      ],
      [
        "ed_hive.cell2",
        "ed_hive.ed.code_update"
      ],
      [
        "ed_hive.cell3",
        "ed_hive.ed.code_stop"
      ],
      [
        "ed_radius.cell1",
        "ed_radius.ed.title"
      ],
      [
        "ed_radius.cell2",
        "ed_radius.ed.code_start"
      ],
      [
        "ed_radius.cell3",
        "ed_radius.ed.code_stop"
      ],
      [
        "ed_radius.cell4",
        "ed_radius.ed.code_update"
      ],
      [
        "ed_vert.cell1",
        "ed_vert.ed.code_start"
      ],
      [
        "ed_vert.cell2",
        "ed_vert.ed.code_update"
      ],
      [
        "ed_vert.cell3",
        "ed_vert.ed.code_stop"
      ],
      [
        "ed_vertexformat.cell1",
        "ed_vertexformat.ed.code_start"
      ],
      [
        "ed_vertexformat.cell2",
        "ed_vertexformat.ed.code_update"
      ],
      [
        "ed_vertexformat.cell3",
        "ed_vertexformat.ed.code_stop"
      ],
      [
        "gen_texture_dict_params",
        "ed_gen_texture_dict_params.ed.value"
      ],
      [
        "gen_vertexbuffer_params",
        "ed_gen_vertexbuffer_params.ed.value"
      ],
      [
        "hp.cell1",
        "hp.ed.code_start"
      ],
      [
        "hp.cell2",
        "hp.ed.code_update"
      ],
      [
        "hp.cell3",
        "hp.ed.code_stop"
      ],
      [
        "hp.hive_attributes",
        "hp.ed.hive_attributes"
      ]
    ]
  }
}